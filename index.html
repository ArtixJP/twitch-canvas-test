<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 3rem; text-align: center; margin-bottom: 2rem; }
        .planet-system {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .planet {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a90d9 0%, #1e5799 50%, #0d2f5c 100%);
            box-shadow: 
                inset -30px -30px 60px rgba(0,0,0,0.5),
                inset 10px 10px 40px rgba(255,255,255,0.2),
                0 0 60px rgba(74, 144, 217, 0.4);
            animation: float 4s ease-in-out infinite;
            position: relative;
            transition: background 0.5s ease, box-shadow 0.5s ease;
        }
        .planet.caught {
            animation: float 4s ease-in-out infinite, planetPulse 0.5s ease-out;
        }
        .planet::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 15%;
            width: 30%;
            height: 20%;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            filter: blur(5px);
        }
        .planet::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            width: 80%;
            height: 8%;
            background: rgba(30, 87, 153, 0.6);
            border-radius: 50%;
            transform: rotate(-5deg);
            transition: background 0.5s ease;
        }
        .moon-orbit {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            animation: orbit 6s linear infinite;
        }
        .moon {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e8e8e8 0%, #b8b8b8 50%, #888888 100%);
            box-shadow: 
                inset -8px -8px 16px rgba(0,0,0,0.4),
                inset 4px 4px 12px rgba(255,255,255,0.3),
                0 0 20px rgba(200, 200, 200, 0.3);
        }
        .moon::before {
            content: '';
            position: absolute;
            top: 25%;
            left: 20%;
            width: 8px;
            height: 8px;
            background: rgba(100,100,100,0.5);
            border-radius: 50%;
        }
        .moon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 55%;
            width: 12px;
            height: 12px;
            background: rgba(100,100,100,0.4);
            border-radius: 50%;
        }
        .kitty-orbit {
            position: absolute;
            width: 380px;
            height: 380px;
            border-radius: 50%;
        }
        .kitty {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            filter: drop-shadow(0 0 10px rgba(255, 182, 193, 0.6));
            animation: kitty-wiggle 0.5s ease-in-out infinite;
            transition: filter 0.3s;
        }
        .kitty.scared {
            filter: drop-shadow(0 0 20px rgba(255, 100, 100, 0.9));
        }
        .doggy-orbit {
            position: absolute;
            width: 380px;
            height: 380px;
            border-radius: 50%;
        }
        .doggy {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            filter: drop-shadow(0 0 10px rgba(255, 200, 100, 0.6));
            animation: doggy-bounce 0.3s ease-in-out infinite;
        }
        @keyframes doggy-bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }
        @keyframes orbit {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes orbit-reverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }
        @keyframes kitty-wiggle {
            0%, 100% { transform: translateX(-50%) rotate(-5deg); }
            50% { transform: translateX(-50%) rotate(5deg); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        @keyframes planetPulse {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
   #three-container canvas {
  position: fixed;
  top: 0;
  left: 0;
}
.planet-system, h1, #musicBtn {
  position: relative;
  z-index: 1;
}
   @keyframes catchPop {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    50% { transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(1); }
}
#dogScore {
    transition: transform 0.3s, color 0.3s;
    font-weight: bold;
}
  </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
</script>
</head>
<body>
<h1>
   Hello World
  </h1>
<div id="scoreBoard" style="font-size: 1.5rem; margin-bottom: 1rem; display: flex; gap: 2rem; background: rgba(255,255,255,0.1); padding: 15px 30px; border-radius: 15px; backdrop-filter: blur(10px);">
<span>
     Dog:
    <span id="dogScore">
     0
    </span>
</span>
</div>
<div id="three-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;">
</div>
<div class="planet-system">
<div class="planet" id="planet">
</div>
<div class="moon-orbit">
<div class="moon">
</div>
</div>
<div class="kitty-orbit">
<div class="kitty">
     
    </div>
</div>
<div class="doggy-orbit">
<div class="doggy">
     
    </div>
</div>
</div>
<div class="stars" id="stars">
</div>
<script>
   const starsContainer = document.getElementById('stars');
    for(let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 2 + 's';
        star.style.width = Math.random() * 3 + 1 + 'px';
        star.style.height = star.style.width;
        starsContainer.appendChild(star);
    }
  </script>
<script>
   function toggleMusic() {
    const audio = document.getElementById('bgMusic');
    const icon = document.getElementById('musicIcon');
    const text = document.getElementById('musicText');
    if (audio.paused) {
      audio.play();
      icon.textContent = '革';
      text.textContent = 'Pause';
    } else {
      audio.pause();
      icon.textContent = '讹';
      text.textContent = 'Play';
    }
  }
  
  // Try to play on load
  window.addEventListener('load', function() {
    const audio = document.getElementById('bgMusic');
    audio.volume = 0.5;
    audio.play().then(function() {
      document.getElementById('musicIcon').textContent = '革';
      document.getElementById('musicText').textContent = 'Pause';
    }).catch(function() {
      document.getElementById('musicIcon').textContent = '讹';
      document.getElementById('musicText').textContent = 'Play';
      // Try to play on first user interaction
      document.addEventListener('click', function playOnInteraction() {
        audio.play().then(function() {
          document.getElementById('musicIcon').textContent = '革';
          document.getElementById('musicText').textContent = 'Pause';
        });
        document.removeEventListener('click', playOnInteraction);
      }, { once: true });
    });
  });
  </script>
<audio autoplay="" id="bgMusic" loop="">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="musicBtn" onclick="toggleMusic()" onmouseout="this.style.background='rgba(255,255,255,0.1)'" onmouseover="this.style.background='rgba(255,255,255,0.2)'" style="position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 25px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; font-family: system-ui, sans-serif; backdrop-filter: blur(10px); transition: all 0.3s ease;">
<span id="musicIcon">
    革
   </span>
<span id="musicText">
    Pause
   </span>
</button>
<script>
   // Three.js Sun with lighting effects
const container = document.getElementById('three-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

// Sun geometry
const sunGeometry = new THREE.SphereGeometry(2, 64, 64);
const sunMaterial = new THREE.MeshBasicMaterial({
  color: 0xffdd00,
});
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
sun.position.set(-8, 5, -5);
scene.add(sun);

// Sun glow effect
const glowGeometry = new THREE.SphereGeometry(2.5, 32, 32);
const glowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    c: { type: 'f', value: 0.5 },
    p: { type: 'f', value: 4.0 },
    glowColor: { type: 'c', value: new THREE.Color(0xffaa00) },
    viewVector: { type: 'v3', value: camera.position }
  },
  vertexShader: `
    uniform vec3 viewVector;
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      vec3 vNormel = normalize(normalMatrix * viewVector);
      intensity = pow(0.7 - dot(vNormal, vNormel), 2.0);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      vec3 glow = glowColor * intensity;
      gl_FragColor = vec4(glow, intensity * 0.8);
    }
  `,
  side: THREE.FrontSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
sunGlow.position.copy(sun.position);
scene.add(sunGlow);

// Outer glow
const outerGlowGeometry = new THREE.SphereGeometry(4, 32, 32);
const outerGlowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    glowColor: { type: 'c', value: new THREE.Color(0xff6600) }
  },
  vertexShader: `
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      gl_FragColor = vec4(glowColor, intensity * 0.4);
    }
  `,
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
outerGlow.position.copy(sun.position);
scene.add(outerGlow);

// Point light from sun
const sunLight = new THREE.PointLight(0xffdd88, 2, 100);
sunLight.position.copy(sun.position);
sunLight.castShadow = true;
scene.add(sunLight);

// Ambient light
const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
scene.add(ambientLight);

// Light rays particles
const rayCount = 200;
const rayGeometry = new THREE.BufferGeometry();
const rayPositions = new Float32Array(rayCount * 3);
const raySizes = new Float32Array(rayCount);
for(let i = 0; i < rayCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 2 + Math.random() * 6;
  rayPositions[i * 3] = sun.position.x + Math.cos(angle) * radius;
  rayPositions[i * 3 + 1] = sun.position.y + (Math.random() - 0.5) * 4;
  rayPositions[i * 3 + 2] = sun.position.z + Math.sin(angle) * radius;
  raySizes[i] = Math.random() * 0.1 + 0.05;
}
rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
rayGeometry.setAttribute('size', new THREE.BufferAttribute(raySizes, 1));
const rayMaterial = new THREE.PointsMaterial({
  color: 0xffcc44,
  size: 0.15,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending
});
const rays = new THREE.Points(rayGeometry, rayMaterial);
scene.add(rays);

camera.position.z = 15;

// Animation
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Pulsing sun
  const pulse = 1 + Math.sin(time * 2) * 0.05;
  sun.scale.set(pulse, pulse, pulse);
  sunGlow.scale.set(pulse * 1.2, pulse * 1.2, pulse * 1.2);
  
  // Rotate rays
  rays.rotation.x += 0.002;
  rays.rotation.y += 0.003;
  
  renderer.render(scene, camera);
}
animate();

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
  </script>
<script>
   // Cat and Dog chase logic
const kittyOrbit = document.querySelector('.kitty-orbit');
const doggyOrbit = document.querySelector('.doggy-orbit');
const kitty = document.querySelector('.kitty');

let catAngle = 0;
let dogAngle = Math.PI; // Start opposite to cat
let catSpeed = 0.02; // Normal cat speed
let dogSpeed = 0.035; // Dog is faster
const normalCatSpeed = 0.02;
const scaredCatSpeed = 0.08; // Cat runs very fast when scared
const dangerDistance = 0.8; // Radians - how close before cat gets scared

function updateChase() {
    // Calculate angular distance between cat and dog
    let angleDiff = catAngle - dogAngle;
    // Normalize to -PI to PI
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    
    const distance = Math.abs(angleDiff);
    
    // If dog is close, cat gets scared and speeds up
    if (distance < dangerDistance) {
        catSpeed = scaredCatSpeed;
        kitty.classList.add('scared');
    } else {
        catSpeed = normalCatSpeed;
        kitty.classList.remove('scared');
    }
    
    // Cat moves (counter-clockwise)
    catAngle -= catSpeed;
    
    // Dog chases cat (moves toward cat's position)
    if (angleDiff > 0) {
        dogAngle += dogSpeed;
    } else {
        dogAngle -= dogSpeed;
    }
    
    // Keep angles in reasonable range
    if (catAngle < -Math.PI * 2) catAngle += Math.PI * 2;
    if (dogAngle > Math.PI * 2) dogAngle -= Math.PI * 2;
    if (dogAngle < -Math.PI * 2) dogAngle += Math.PI * 2;
    
    // Apply rotations
    kittyOrbit.style.transform = `rotate(${catAngle}rad)`;
    doggyOrbit.style.transform = `rotate(${dogAngle}rad)`;
    
    requestAnimationFrame(updateChase);
}

updateChase();
  </script>
<script>
   // Score system
let dogPoints = 0;
const dogScoreEl = document.getElementById('dogScore');
const catchDistance = 0.3; // Radians - how close to count as a catch
let catchCooldown = false;

function checkCatch() {
    if (catchCooldown) return;
    
    // Get current angles from the chase system
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const doggyOrbit = document.querySelector('.doggy-orbit');
    
    // Extract rotation values
    const catTransform = kittyOrbit.style.transform;
    const dogTransform = doggyOrbit.style.transform;
    
    const catMatch = catTransform.match(/rotate\(([\d.-]+)rad\)/);
    const dogMatch = dogTransform.match(/rotate\(([\d.-]+)rad\)/);
    
    if (catMatch && dogMatch) {
        const catAng = parseFloat(catMatch[1]);
        const dogAng = parseFloat(dogMatch[1]);
        
        let angleDiff = catAng - dogAng;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        const distance = Math.abs(angleDiff);
        
        if (distance < catchDistance) {
            // Dog caught the cat!
            dogPoints++;
            dogScoreEl.textContent = dogPoints;
            
            // Visual feedback
            dogScoreEl.style.transform = 'scale(1.5)';
            dogScoreEl.style.color = '#ffdd00';
            setTimeout(() => {
                dogScoreEl.style.transform = 'scale(1)';
                dogScoreEl.style.color = 'white';
            }, 300);
            
            // Show catch effect
            const catchEffect = document.createElement('div');
            catchEffect.textContent = '+1 ';
            catchEffect.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; color: #ffdd00; text-shadow: 0 0 20px #ff6600; animation: catchPop 1s ease-out forwards; z-index: 100;';
            document.body.appendChild(catchEffect);
            setTimeout(() => catchEffect.remove(), 1000);
            
            // Cooldown to prevent multiple catches
            catchCooldown = true;
            setTimeout(() => { catchCooldown = false; }, 2000);
        }
    }
    
    requestAnimationFrame(checkCatch);
}

checkCatch();
  </script>
<script>
   // Planet color change on catch
const planetColors = [
    { gradient: 'linear-gradient(135deg, #ff6b6b 0%, #c92a2a 50%, #5c0a0a 100%)', glow: 'rgba(255, 107, 107, 0.4)' },
    { gradient: 'linear-gradient(135deg, #51cf66 0%, #2f9e44 50%, #0d3d14 100%)', glow: 'rgba(81, 207, 102, 0.4)' },
    { gradient: 'linear-gradient(135deg, #ffd43b 0%, #fab005 50%, #5c4200 100%)', glow: 'rgba(255, 212, 59, 0.4)' },
    { gradient: 'linear-gradient(135deg, #cc5de8 0%, #9c36b5 50%, #3d0d4a 100%)', glow: 'rgba(204, 93, 232, 0.4)' },
    { gradient: 'linear-gradient(135deg, #ff922b 0%, #e8590c 50%, #5c2200 100%)', glow: 'rgba(255, 146, 43, 0.4)' },
    { gradient: 'linear-gradient(135deg, #22b8cf 0%, #1098ad 50%, #043d45 100%)', glow: 'rgba(34, 184, 207, 0.4)' },
    { gradient: 'linear-gradient(135deg, #f06595 0%, #d6336c 50%, #5c0d2a 100%)', glow: 'rgba(240, 101, 149, 0.4)' }
];
const originalColor = { gradient: 'linear-gradient(135deg, #4a90d9 0%, #1e5799 50%, #0d2f5c 100%)', glow: 'rgba(74, 144, 217, 0.4)' };

function changePlanetColor() {
    const planet = document.getElementById('planet');
    if (!planet) return;
    
    // Pick a random color
    const randomColor = planetColors[Math.floor(Math.random() * planetColors.length)];
    
    // Apply the new color
    planet.style.background = randomColor.gradient;
    planet.style.boxShadow = `inset -30px -30px 60px rgba(0,0,0,0.5), inset 10px 10px 40px rgba(255,255,255,0.2), 0 0 60px ${randomColor.glow}`;
    
    // Add pulse animation class
    planet.classList.add('caught');
    
    // Return to original color after 2 seconds
    setTimeout(() => {
        planet.style.background = originalColor.gradient;
        planet.style.boxShadow = `inset -30px -30px 60px rgba(0,0,0,0.5), inset 10px 10px 40px rgba(255,255,255,0.2), 0 0 60px ${originalColor.glow}`;
        planet.classList.remove('caught');
    }, 2000);
}

// Override the catch detection to include planet color change
const originalCheckCatch = checkCatch;
let catchCooldownPlanet = false;

function checkCatchWithPlanet() {
    if (catchCooldownPlanet) {
        requestAnimationFrame(checkCatchWithPlanet);
        return;
    }
    
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const doggyOrbit = document.querySelector('.doggy-orbit');
    
    const catTransform = kittyOrbit.style.transform;
    const dogTransform = doggyOrbit.style.transform;
    
    const catMatch = catTransform.match(/rotate\(([\d.-]+)rad\)/);
    const dogMatch = dogTransform.match(/rotate\(([\d.-]+)rad\)/);
    
    if (catMatch && dogMatch) {
        const catAng = parseFloat(catMatch[1]);
        const dogAng = parseFloat(dogMatch[1]);
        
        let angleDiff = catAng - dogAng;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        const distance = Math.abs(angleDiff);
        
        if (distance < 0.3) {
            // Change planet color!
            changePlanetColor();
            
            catchCooldownPlanet = true;
            setTimeout(() => { catchCooldownPlanet = false; }, 2000);
        }
    }
    
    requestAnimationFrame(checkCatchWithPlanet);
}

checkCatchWithPlanet();
  </script>
</body>
</html>
