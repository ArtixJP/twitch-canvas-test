<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code - 3D Globe
  </title>
<style>
   * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
        font-family: system-ui, sans-serif; 
        min-height: 100vh; 
        background: #000;
        color: white;
        overflow: hidden;
    }
    #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    h1 { 
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2.5rem; 
        text-align: center;
        z-index: 10;
        text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
        letter-spacing: 3px;
    }
    .credit {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        opacity: 0.7;
        z-index: 10;
    }
  </style>
</head>
<body>
<div id="container">
</div>
<h1>
   üåç World Explorer üåô
   <span style="font-size: 1rem; display: block; margin-top: 10px; opacity: 0.8;">
    Watch the little adventurer walk around... and the Moon orbit!
   </span>
</h1>
<p class="credit">
   Demand√© par @artix187
  </p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
</script>
<script>
   // Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('container').appendChild(renderer.domElement);

// Stars background
const starsGeometry = new THREE.BufferGeometry();
const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
const starsVertices = [];
for (let i = 0; i < 10000; i++) {
    starsVertices.push(
        (Math.random() - 0.5) * 2000,
        (Math.random() - 0.5) * 2000,
        (Math.random() - 0.5) * 2000
    );
}
starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
const stars = new THREE.Points(starsGeometry, starsMaterial);
scene.add(stars);

// Earth
const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
const textureLoader = new THREE.TextureLoader();
const earthMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg'),
    bumpMap: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-topology.png'),
    bumpScale: 0.1,
    specularMap: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-water.png'),
    specular: new THREE.Color(0x333333),
    shininess: 15
});
const earth = new THREE.Mesh(earthGeometry, earthMaterial);
scene.add(earth);

// Atmosphere glow
const atmosphereGeometry = new THREE.SphereGeometry(5.2, 64, 64);
const atmosphereMaterial = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
});
const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
scene.add(atmosphere);

// Clouds layer
const cloudsGeometry = new THREE.SphereGeometry(5.1, 64, 64);
const cloudsMaterial = new THREE.MeshPhongMaterial({
    map: textureLoader.load('https://unpkg.com/three-globe/example/img/earth-clouds.png'),
    transparent: true,
    opacity: 0.4
});
const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
scene.add(clouds);

// === THE MOON ===
const moonGroup = new THREE.Group();

// Moon sphere
const moonGeometry = new THREE.SphereGeometry(1.2, 32, 32);
const moonMaterial = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    bumpScale: 0.05,
    shininess: 5
});
const moon = new THREE.Mesh(moonGeometry, moonMaterial);

// Add craters to the moon!
const craterMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
for (let i = 0; i < 15; i++) {
    const craterSize = 0.1 + Math.random() * 0.2;
    const craterGeometry = new THREE.SphereGeometry(craterSize, 16, 16);
    const crater = new THREE.Mesh(craterGeometry, craterMaterial);
    
    // Random position on moon surface
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    crater.position.x = 1.15 * Math.sin(phi) * Math.cos(theta);
    crater.position.y = 1.15 * Math.sin(phi) * Math.sin(theta);
    crater.position.z = 1.15 * Math.cos(phi);
    crater.scale.z = 0.3; // Flatten the crater
    crater.lookAt(0, 0, 0);
    moon.add(crater);
}

moonGroup.add(moon);
moonGroup.position.x = 15;
scene.add(moonGroup);

// Moon glow
const moonGlowGeometry = new THREE.SphereGeometry(1.4, 32, 32);
const moonGlowMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffee,
    transparent: true,
    opacity: 0.1,
    side: THREE.BackSide
});
const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
moonGroup.add(moonGlow);

// === CUTE EXPLORER CHARACTER ===
const stickmanGroup = new THREE.Group();

// Head
const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
const head = new THREE.Mesh(headGeometry, headMaterial);
head.position.y = 0.9;
stickmanGroup.add(head);

// Explorer Hat!
const hatBrimGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.05, 16);
const hatMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
const hatBrim = new THREE.Mesh(hatBrimGeometry, hatMaterial);
hatBrim.position.y = 1.1;
stickmanGroup.add(hatBrim);

const hatTopGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.2, 16);
const hatTop = new THREE.Mesh(hatTopGeometry, hatMaterial);
hatTop.position.y = 1.2;
stickmanGroup.add(hatTop);

// Eyes
const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
leftEye.position.set(-0.08, 0.95, 0.2);
stickmanGroup.add(leftEye);
const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
rightEye.position.set(0.08, 0.95, 0.2);
stickmanGroup.add(rightEye);

// Rosy cheeks
const cheekGeometry = new THREE.SphereGeometry(0.04, 8, 8);
const cheekMaterial = new THREE.MeshBasicMaterial({ color: 0xff9999 });
const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
leftCheek.position.set(-0.15, 0.85, 0.18);
stickmanGroup.add(leftCheek);
const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
rightCheek.position.set(0.15, 0.85, 0.18);
stickmanGroup.add(rightCheek);

// Big smile
const smileCurve = new THREE.QuadraticBezierCurve3(
    new THREE.Vector3(-0.12, 0.8, 0.2),
    new THREE.Vector3(0, 0.72, 0.28),
    new THREE.Vector3(0.12, 0.8, 0.2)
);
const smileGeometry = new THREE.TubeGeometry(smileCurve, 12, 0.025, 8, false);
const smileMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });
const smile = new THREE.Mesh(smileGeometry, smileMaterial);
stickmanGroup.add(smile);

// Body (shirt)
const bodyGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.5, 8);
const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x22aa44 });
const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
body.position.y = 0.5;
stickmanGroup.add(body);

// Backpack!
const backpackGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.15);
const backpackMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
backpack.position.set(0, 0.5, -0.15);
stickmanGroup.add(backpack);

// Backpack pocket
const pocketGeometry = new THREE.BoxGeometry(0.12, 0.1, 0.05);
const pocketMaterial = new THREE.MeshPhongMaterial({ color: 0xcc5500 });
const pocket = new THREE.Mesh(pocketGeometry, pocketMaterial);
pocket.position.set(0, 0.4, -0.23);
stickmanGroup.add(pocket);

// Arms
const armGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.35, 8);
const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffcc99 });
const leftArm = new THREE.Mesh(armGeometry, armMaterial);
leftArm.position.set(-0.2, 0.55, 0);
leftArm.rotation.z = Math.PI / 4;
stickmanGroup.add(leftArm);
const rightArm = new THREE.Mesh(armGeometry, armMaterial);
rightArm.position.set(0.2, 0.55, 0);
rightArm.rotation.z = -Math.PI / 4;
stickmanGroup.add(rightArm);

// Legs (pants)
const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
const legMaterial = new THREE.MeshPhongMaterial({ color: 0x4444aa });
const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
leftLeg.position.set(-0.08, 0.05, 0);
stickmanGroup.add(leftLeg);
const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
rightLeg.position.set(0.08, 0.05, 0);
stickmanGroup.add(rightLeg);

// Boots!
const bootGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.12);
const bootMaterial = new THREE.MeshPhongMaterial({ color: 0x553300 });
const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
leftBoot.position.set(-0.08, -0.15, 0.02);
stickmanGroup.add(leftBoot);
const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
rightBoot.position.set(0.08, -0.15, 0.02);
stickmanGroup.add(rightBoot);

// Walking stick
const stickGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
const stickMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
const walkingStick = new THREE.Mesh(stickGeometry, stickMaterial);
walkingStick.position.set(0.35, 0.3, 0);
walkingStick.rotation.z = -0.3;
stickmanGroup.add(walkingStick);

// Position stickman on globe surface
stickmanGroup.scale.set(0.6, 0.6, 0.6);
scene.add(stickmanGroup);

let walkAngle = 0;
let moonOrbitAngle = 0;

// Lighting
const ambientLight = new THREE.AmbientLight(0x444444);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
sunLight.position.set(5, 3, 5);
scene.add(sunLight);

// Rim light for character
const rimLight = new THREE.PointLight(0x88ccff, 0.5, 20);
scene.add(rimLight);

camera.position.z = 18;

// Mouse interaction
let mouseX = 0, mouseY = 0;
document.addEventListener('mousemove', (e) => {
    mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
    mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
});

// Animation
function animate() {
    requestAnimationFrame(animate);
    
    // Earth rotation
    earth.rotation.y += 0.001;
    clouds.rotation.y += 0.0015;
    
    // Moon orbit around Earth!
    moonOrbitAngle += 0.003;
    const moonDistance = 15;
    moonGroup.position.x = Math.cos(moonOrbitAngle) * moonDistance;
    moonGroup.position.z = Math.sin(moonOrbitAngle) * moonDistance;
    moonGroup.position.y = Math.sin(moonOrbitAngle * 0.5) * 2;
    
    // Moon always faces Earth (tidal locking)
    moon.rotation.y = -moonOrbitAngle;
    
    // Stickman walking around the globe!
    walkAngle += 0.012;
    const radius = 5.5;
    const lat = Math.sin(walkAngle * 0.5) * 0.4;
    
    stickmanGroup.position.x = Math.cos(walkAngle) * Math.cos(lat) * radius;
    stickmanGroup.position.z = Math.sin(walkAngle) * Math.cos(lat) * radius;
    stickmanGroup.position.y = Math.sin(lat) * radius;
    
    // Make stickman face forward
    stickmanGroup.lookAt(0, 0, 0);
    stickmanGroup.rotateX(Math.PI);
    
    // Walking animation
    const walkCycle = walkAngle * 10;
    leftLeg.rotation.x = Math.sin(walkCycle) * 0.6;
    rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.6;
    leftBoot.position.y = -0.15 + Math.max(0, Math.sin(walkCycle)) * 0.05;
    rightBoot.position.y = -0.15 + Math.max(0, Math.sin(walkCycle + Math.PI)) * 0.05;
    leftArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.4;
    rightArm.rotation.x = Math.sin(walkCycle) * 0.4;
    walkingStick.rotation.x = Math.sin(walkCycle) * 0.2;
    
    // Happy bounce!
    const bounce = Math.abs(Math.sin(walkCycle)) * 0.08;
    stickmanGroup.position.normalize().multiplyScalar(radius + bounce);
    
    // Head bob
    head.rotation.z = Math.sin(walkCycle * 0.5) * 0.1;
    hatBrim.rotation.z = head.rotation.z;
    hatTop.rotation.z = head.rotation.z;
    
    // Rim light follows character
    rimLight.position.copy(stickmanGroup.position).multiplyScalar(1.5);
    
    // Subtle tilt based on mouse
    earth.rotation.x = mouseY * 0.3;
    clouds.rotation.x = mouseY * 0.3;
    atmosphere.rotation.x = mouseY * 0.3;
    
    // Camera follows mouse
    camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
    camera.position.y += (-mouseY * 3 - camera.position.y) * 0.05;
    camera.lookAt(earth.position);
    
    // Stars twinkle
    stars.rotation.y += 0.0001;
    
    renderer.render(scene, camera);
}

animate();

// Resize handler
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
  </script>
</body>
</html>
