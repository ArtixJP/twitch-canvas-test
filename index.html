<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        h1 { font-size: 3rem; text-align: center; }
  </style>
</head>
<body>
<nav id="main-nav" style="position: fixed; top: 0; left: 0; right: 0; z-index: 1000; display: flex; justify-content: center; gap: 10px; padding: 15px; background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%); backdrop-filter: blur(10px); box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
<button class="nav-btn active" data-section="space" onclick="showSection('space')" style="padding: 12px 25px; font-size: 16px; font-weight: bold; border: none; border-radius: 25px; cursor: pointer; transition: all 0.3s ease; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);">
    üåå Espace
   </button>
<button class="nav-btn" data-section="animals" onclick="showSection('animals')" style="padding: 12px 25px; font-size: 16px; font-weight: bold; border: none; border-radius: 25px; cursor: pointer; transition: all 0.3s ease; background: rgba(255,255,255,0.1); color: white;">
    üêæ Animaux
   </button>
<button class="nav-btn" data-section="games" onclick="showSection('games')" style="padding: 12px 25px; font-size: 16px; font-weight: bold; border: none; border-radius: 25px; cursor: pointer; transition: all 0.3s ease; background: rgba(255,255,255,0.1); color: white;">
    üéÆ Jeux
   </button>
</nav>
<h1 style="position: absolute; top: 80px; z-index: 10; text-shadow: 0 0 20px rgba(255, 200, 100, 0.8), 0 0 40px rgba(255, 150, 50, 0.5); width: 100%; text-align: center;">
   Hello World ‚òÄÔ∏è
  </h1>
<div class="content-section active" id="section-space" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%;">
<div id="planet-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Plan√®te
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a90d9,
    emissive: 0x112244,
    specular: 0x333333,
    shininess: 25
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Lune orbitante
  const moonPivot = new THREE.Object3D();
  scene.add(moonPivot);
  
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    emissive: 0x222222,
    specular: 0x444444,
    shininess: 10
  });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.position.x = 4;
  moonPivot.add(moon);
  
  const moonGlowGeom = new THREE.SphereGeometry(0.5, 32, 32);
  const moonGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffffee,
    transparent: true,
    opacity: 0.15
  });
  const moonGlow = new THREE.Mesh(moonGlowGeom, moonGlowMat);
  moonGlow.position.x = 4;
  moonPivot.add(moonGlow);

  // === CUTE KITTY ===
  const kittyPivot = new THREE.Object3D();
  scene.add(kittyPivot);
  
  const kittyMat = new THREE.MeshPhongMaterial({ color: 0xffaa88, emissive: 0x331111, specular: 0xffffff, shininess: 30 });
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), kittyMat);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), kittyMat);
  head.position.set(0.2, 0.15, 0);
  const earL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), kittyMat);
  const earR = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), kittyMat);
  earL.position.set(0.25, 0.35, -0.08); earR.position.set(0.25, 0.35, 0.08);
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  eyeL.position.set(0.35, 0.2, -0.08); eyeR.position.set(0.35, 0.2, 0.08);
  const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const shineL = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), shineMat);
  const shineR = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), shineMat);
  shineL.position.set(0.37, 0.22, -0.09); shineR.position.set(0.37, 0.22, 0.07);
  const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.05, 0.4, 8), kittyMat);
  tail.position.set(-0.3, 0.1, 0); tail.rotation.z = Math.PI / 3;
  
  const kitty = new THREE.Group();
  kitty.add(body, head, earL, earR, eyeL, eyeR, shineL, shineR, tail);
  kitty.position.x = 5;
  kitty.scale.set(0.7, 0.7, 0.7);
  kittyPivot.add(kitty);
  
  // Tra√Æn√©e d'√©toiles sparkle
  const sparkleGeom = new THREE.BufferGeometry();
  const sparklePos = [];
  for(let i = 0; i < 30; i++) sparklePos.push(0, 0, 0);
  sparkleGeom.setAttribute('position', new THREE.Float32BufferAttribute(sparklePos, 3));
  const sparkles = new THREE.Points(sparkleGeom, new THREE.PointsMaterial({ color: 0xffff99, size: 0.1, transparent: true, opacity: 0.8 }));
  scene.add(sparkles);
  const sparkleHistory = [];

  // Anneau
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x9966cc, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumi√®res
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
  scene.add(stars);

  camera.position.z = 6;

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    ring.rotation.z += 0.001;
    atmosphere.rotation.y += 0.002;
    stars.rotation.y += 0.0002;
    moonPivot.rotation.y += 0.008;
    moonPivot.rotation.x = Math.sin(Date.now() * 0.0005) * 0.2;
    moon.rotation.y += 0.01;
    
    // Kitty orbit!
    kittyPivot.rotation.y += 0.012;
    kittyPivot.rotation.x = Math.sin(Date.now() * 0.001) * 0.3;
    kitty.rotation.y = -kittyPivot.rotation.y + Math.PI / 2;
    tail.rotation.x = Math.sin(Date.now() * 0.01) * 0.3;
    
    // Update sparkle trail
    const kittyWorldPos = new THREE.Vector3();
    kitty.getWorldPosition(kittyWorldPos);
    sparkleHistory.unshift(kittyWorldPos.clone());
    if(sparkleHistory.length > 30) sparkleHistory.pop();
    const positions = sparkles.geometry.attributes.position.array;
    for(let i = 0; i < sparkleHistory.length; i++) {
      positions[i*3] = sparkleHistory[i].x + (Math.random()-0.5)*0.1;
      positions[i*3+1] = sparkleHistory[i].y + (Math.random()-0.5)*0.1;
      positions[i*3+2] = sparkleHistory[i].z + (Math.random()-0.5)*0.1;
    }
    sparkles.geometry.attributes.position.needsUpdate = true;
    
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  // Attendre que Three.js soit charg√©
  const checkScene = setInterval(() => {
    const container = document.getElementById('planet-container');
    if (container && container.children.length > 0) {
      clearInterval(checkScene);
      addKittyToScene();
    }
  }, 100);

  function addKittyToScene() {
    // R√©cup√©rer la sc√®ne existante
    const scene = window.kittyScene || (function() {
      // Cr√©er une nouvelle sc√®ne pour le kitty qui utilise le m√™me renderer
      const container = document.getElementById('planet-container');
      const canvas = container.querySelector('canvas');
      
      // On va ajouter le kitty via un nouveau pivot dans le DOM
      const kittyPivot = new THREE.Object3D();
      kittyPivot.name = 'kittyOrbit';
      
      // Cr√©er le corps du chat
      const bodyGeom = new THREE.SphereGeometry(0.25, 16, 16);
      const kittyMat = new THREE.MeshPhongMaterial({
        color: 0xffaa88,
        emissive: 0x331111,
        specular: 0xffffff,
        shininess: 30
      });
      const body = new THREE.Mesh(bodyGeom, kittyMat);
      
      // T√™te du chat
      const headGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const head = new THREE.Mesh(headGeom, kittyMat);
      head.position.set(0.2, 0.15, 0);
      
      // Oreilles
      const earGeom = new THREE.ConeGeometry(0.08, 0.15, 4);
      const earMat = new THREE.MeshPhongMaterial({ color: 0xffaa88, emissive: 0x331111 });
      const earL = new THREE.Mesh(earGeom, earMat);
      const earR = new THREE.Mesh(earGeom, earMat);
      earL.position.set(0.25, 0.35, -0.08);
      earR.position.set(0.25, 0.35, 0.08);
      earL.rotation.z = -0.2;
      earR.rotation.z = -0.2;
      
      // Yeux kawaii
      const eyeGeom = new THREE.SphereGeometry(0.04, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const eyeL = new THREE.Mesh(eyeGeom, eyeMat);
      const eyeR = new THREE.Mesh(eyeGeom, eyeMat);
      eyeL.position.set(0.35, 0.2, -0.08);
      eyeR.position.set(0.35, 0.2, 0.08);
      
      // Brillance des yeux
      const shineGeom = new THREE.SphereGeometry(0.015, 8, 8);
      const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const shineL = new THREE.Mesh(shineGeom, shineMat);
      const shineR = new THREE.Mesh(shineGeom, shineMat);
      shineL.position.set(0.37, 0.22, -0.09);
      shineR.position.set(0.37, 0.22, 0.07);
      
      // Queue
      const tailGeom = new THREE.CylinderGeometry(0.03, 0.05, 0.4, 8);
      const tail = new THREE.Mesh(tailGeom, kittyMat);
      tail.position.set(-0.3, 0.1, 0);
      tail.rotation.z = Math.PI / 3;
      
      // Assembler le chat
      const kitty = new THREE.Group();
      kitty.add(body, head, earL, earR, eyeL, eyeR, shineL, shineR, tail);
      kitty.position.x = 5.5;
      kitty.scale.set(0.8, 0.8, 0.8);
      
      kittyPivot.add(kitty);
      
      // Tra√Æn√©e d'√©toiles
      const trailGeom = new THREE.BufferGeometry();
      const trailPositions = [];
      for(let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 0.5;
        trailPositions.push(
          Math.cos(angle) * 5.5 - Math.random() * 0.3,
          Math.sin(i * 0.1) * 0.2,
          Math.sin(angle) * 5.5 - Math.random() * 0.3
        );
      }
      trailGeom.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trail = new THREE.Points(trailGeom, new THREE.PointsMaterial({ 
        color: 0xffff88, 
        size: 0.08,
        transparent: true,
        opacity: 0.7
      }));
      kittyPivot.add(trail);
      
      // Ajouter √† la sc√®ne Three.js existante
      const renderer = container.querySelector('canvas').__three_renderer;
      if (renderer && renderer.info) {
        // Acc√®s direct impossible, on utilise une autre m√©thode
      }
      
      // Stocker pour l'animation
      window.kittyData = { pivot: kittyPivot, kitty: kitty, tail: tail, trail: trail };
      
      return kittyPivot;
    })();
  }
})();
  </script>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Plan√®te
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a90d9,
    emissive: 0x112244,
    specular: 0x333333,
    shininess: 25
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Lune orbitante
  const moonPivot = new THREE.Object3D();
  scene.add(moonPivot);
  
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    emissive: 0x222222,
    specular: 0x444444,
    shininess: 10
  });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.position.x = 4;
  moonPivot.add(moon);
  
  const moonGlowGeom = new THREE.SphereGeometry(0.5, 32, 32);
  const moonGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffffee,
    transparent: true,
    opacity: 0.15
  });
  const moonGlow = new THREE.Mesh(moonGlowGeom, moonGlowMat);
  moonGlow.position.x = 4;
  moonPivot.add(moonGlow);

  // Anneau
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x9966cc,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumi√®res
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
  scene.add(stars);

  camera.position.z = 6;

  // √âcouter le changement de couleur
  let targetColor = { main: 0x4a90d9, emissive: 0x112244, atmos: 0x88ccff };
  window.addEventListener('planetColorChange', (e) => {
    targetColor = e.detail;
  });

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    ring.rotation.z += 0.001;
    atmosphere.rotation.y += 0.002;
    stars.rotation.y += 0.0002;
    
    // Transition douce des couleurs
    material.color.lerp(new THREE.Color(targetColor.main), 0.05);
    material.emissive.lerp(new THREE.Color(targetColor.emissive), 0.05);
    atmosMat.color.lerp(new THREE.Color(targetColor.atmos), 0.05);
    
    // Orbite de la lune
    moonPivot.rotation.y += 0.008;
    moonPivot.rotation.x = Math.sin(Date.now() * 0.0005) * 0.2;
    moon.rotation.y += 0.01;
    
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<audio autoplay="" id="bg-music" loop="" preload="auto">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="music-toggle" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.5)';" onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.7)';" style="position: fixed; bottom: 30px; right: 30px; z-index: 100; width: 60px; height: 60px; border-radius: 50%; border: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-size: 24px; cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
   üéµ
  </button>
<script>
   (function() {
  const audio = document.getElementById('bg-music');
  const btn = document.getElementById('music-toggle');
  let isPlaying = true;
  
  // Autoplay peut √™tre bloqu√©, g√©rer √ßa
  audio.play().catch(() => {
    isPlaying = false;
    btn.innerHTML = '‚ñ∂Ô∏è';
  });
  
  btn.addEventListener('click', () => {
    if (isPlaying) {
      audio.pause();
      btn.innerHTML = '‚ñ∂Ô∏è';
      btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
    } else {
      audio.play();
      btn.innerHTML = 'üéµ';
      btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    }
    isPlaying = !isPlaying;
  });
})();
  </script>
<div id="autoplay-overlay" onclick="this.style.display='none'; document.getElementById('bg-music').play(); document.getElementById('music-toggle').innerHTML='üéµ';" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; backdrop-filter: blur(10px);">
<div style="font-size: 80px; animation: pulse 1.5s infinite;">
    üéµ
   </div>
<p style="color: white; font-size: 24px; margin-top: 20px; text-shadow: 0 0 10px rgba(100,200,255,0.8);">
    Cliquez pour entrer dans l'univers
   </p>
<style>
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
   </style>
</div>
<script>
   (function() {
  // Attendre que Three.js soit pr√™t
  setTimeout(() => {
    const container = document.getElementById('planet-container');
    const canvases = container.querySelectorAll('canvas');
    
    // Cr√©er une nouvelle sc√®ne pour le soleil
    const sunScene = new THREE.Scene();
    const sunCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const sunRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    sunRenderer.setSize(window.innerWidth, window.innerHeight);
    sunRenderer.setClearColor(0x000000, 0);
    sunRenderer.shadowMap.enabled = true;
    sunRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.insertBefore(sunRenderer.domElement, container.firstChild);
    sunRenderer.domElement.style.position = 'absolute';
    sunRenderer.domElement.style.pointerEvents = 'none';
    
    // Soleil principal
    const sunGeom = new THREE.SphereGeometry(1.5, 64, 64);
    const sunMat = new THREE.MeshBasicMaterial({
      color: 0xffdd44,
    });
    const sun = new THREE.Mesh(sunGeom, sunMat);
    sun.position.set(-15, 8, -10);
    sunScene.add(sun);
    
    // Couronne solaire (glow)
    const coronaGeom = new THREE.SphereGeometry(2.2, 64, 64);
    const coronaMat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        color1: { value: new THREE.Color(0xffaa00) },
        color2: { value: new THREE.Color(0xff4400) }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          float pulse = sin(time * 3.0) * 0.1 + 0.9;
          vec3 color = mix(color1, color2, sin(time + vPosition.y * 2.0) * 0.5 + 0.5);
          gl_FragColor = vec4(color, intensity * pulse * 0.6);
        }
      `,
      transparent: true,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending
    });
    const corona = new THREE.Mesh(coronaGeom, coronaMat);
    corona.position.copy(sun.position);
    sunScene.add(corona);
    
    // Rayons de lumi√®re (god rays effect)
    const rayCount = 12;
    const rays = [];
    for(let i = 0; i < rayCount; i++) {
      const rayGeom = new THREE.ConeGeometry(0.3, 8, 8, 1, true);
      const rayMat = new THREE.MeshBasicMaterial({
        color: 0xffee88,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const ray = new THREE.Mesh(rayGeom, rayMat);
      ray.position.copy(sun.position);
      const angle = (i / rayCount) * Math.PI * 2;
      ray.rotation.x = Math.cos(angle) * 0.3;
      ray.rotation.z = Math.sin(angle) * 0.3 + Math.PI;
      ray.userData.baseRotZ = ray.rotation.z;
      ray.userData.offset = i * 0.5;
      rays.push(ray);
      sunScene.add(ray);
    }
    
    // Lumi√®re directionnelle avec ombres
    const sunLight = new THREE.DirectionalLight(0xffeeaa, 2);
    sunLight.position.copy(sun.position);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 50;
    sunLight.shadow.camera.left = -10;
    sunLight.shadow.camera.right = 10;
    sunLight.shadow.camera.top = 10;
    sunLight.shadow.camera.bottom = -10;
    sunLight.shadow.bias = -0.0001;
    sunScene.add(sunLight);
    
    // Lens flare effect avec des cercles
    const flareGroup = new THREE.Group();
    const flareSizes = [0.8, 0.4, 0.2, 0.6, 0.3];
    const flareColors = [0xffffaa, 0xff8844, 0xffaa66, 0xffff88, 0xffcc44];
    const flarePositions = [0.2, 0.4, 0.6, 0.8, 1.0];
    
    flareSizes.forEach((size, i) => {
      const flareGeom = new THREE.RingGeometry(size * 0.8, size, 32);
      const flareMat = new THREE.MeshBasicMaterial({
        color: flareColors[i],
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const flare = new THREE.Mesh(flareGeom, flareMat);
      flare.position.lerpVectors(sun.position, new THREE.Vector3(0, 0, 6), flarePositions[i]);
      flare.lookAt(sunCamera.position);
      flareGroup.add(flare);
    });
    sunScene.add(flareGroup);
    
    // Particules solaires
    const particleCount = 200;
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSpeeds = [];
    
    for(let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const r = 1.5 + Math.random() * 0.5;
      particlePositions[i * 3] = sun.position.x + r * Math.sin(phi) * Math.cos(theta);
      particlePositions[i * 3 + 1] = sun.position.y + r * Math.sin(phi) * Math.sin(theta);
      particlePositions[i * 3 + 2] = sun.position.z + r * Math.cos(phi);
      particleSpeeds.push({ theta, phi, speed: 0.5 + Math.random() * 1.5, r });
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMat = new THREE.PointsMaterial({
      color: 0xffaa44,
      size: 0.15,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particleGeom, particleMat);
    sunScene.add(particles);
    
    sunCamera.position.z = 6;
    
    // Animation
    function animateSun() {
      requestAnimationFrame(animateSun);
      
      const time = Date.now() * 0.001;
      
      // Pulse du soleil
      const pulse = Math.sin(time * 2) * 0.05 + 1;
      sun.scale.set(pulse, pulse, pulse);
      
      // Animation de la couronne
      coronaMat.uniforms.time.value = time;
      corona.scale.set(pulse * 1.1, pulse * 1.1, pulse * 1.1);
      
      // Animation des rayons
      rays.forEach((ray, i) => {
        ray.rotation.z = ray.userData.baseRotZ + Math.sin(time * 2 + ray.userData.offset) * 0.1;
        ray.scale.y = 0.8 + Math.sin(time * 3 + ray.userData.offset) * 0.2;
        ray.material.opacity = 0.1 + Math.sin(time * 2 + ray.userData.offset) * 0.05;
      });
      
      // Animation des particules
      const positions = particles.geometry.attributes.position.array;
      for(let i = 0; i < particleCount; i++) {
        const s = particleSpeeds[i];
        s.r += s.speed * 0.02;
        if(s.r > 4) s.r = 1.5;
        positions[i * 3] = sun.position.x + s.r * Math.sin(s.phi) * Math.cos(s.theta + time * 0.5);
        positions[i * 3 + 1] = sun.position.y + s.r * Math.sin(s.phi) * Math.sin(s.theta + time * 0.5);
        positions[i * 3 + 2] = sun.position.z + s.r * Math.cos(s.phi);
      }
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Flares suivent la cam√©ra
      flareGroup.children.forEach(flare => flare.lookAt(sunCamera.position));
      
      sunRenderer.render(sunScene, sunCamera);
    }
    animateSun();
    
    window.addEventListener('resize', () => {
      sunCamera.aspect = window.innerWidth / window.innerHeight;
      sunCamera.updateProjectionMatrix();
      sunRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  }, 500);
})();
  </script>
<script>
   (function(){const audio=document.getElementById('bg-music');const overlay=document.getElementById('autoplay-overlay');audio.play().then(()=>{overlay.style.display='none';}).catch(()=>{});document.addEventListener('click',function firstClick(){audio.play().catch(()=>{});},{once:true});})();
  </script>
<script>
   (function() {
  // Attendre que Three.js et la sc√®ne soient pr√™ts
  setTimeout(() => {
    const container = document.getElementById('planet-container');
    
    // Cr√©er une sc√®ne pour le chien
    const dogScene = new THREE.Scene();
    const dogCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const dogRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    dogRenderer.setSize(window.innerWidth, window.innerHeight);
    dogRenderer.setClearColor(0x000000, 0);
    container.appendChild(dogRenderer.domElement);
    dogRenderer.domElement.style.position = 'absolute';
    dogRenderer.domElement.style.top = '0';
    dogRenderer.domElement.style.pointerEvents = 'none';
    
    // Lumi√®res
    const light = new THREE.PointLight(0xffffff, 1.5);
    light.position.set(10, 5, 10);
    dogScene.add(light);
    dogScene.add(new THREE.AmbientLight(0x333366, 0.5));
    
    // === CUTE DOG ===
    const dogPivot = new THREE.Object3D();
    dogScene.add(dogPivot);
    
    const dogMat = new THREE.MeshPhongMaterial({ color: 0xcc8844, emissive: 0x221100, specular: 0xffffff, shininess: 30 });
    const whiteMat = new THREE.MeshPhongMaterial({ color: 0xffeedd, emissive: 0x111111 });
    
    // Corps du chien
    const dogBody = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), dogMat);
    dogBody.scale.set(1.2, 0.9, 0.9);
    
    // T√™te
    const dogHead = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 16), dogMat);
    dogHead.position.set(0.35, 0.1, 0);
    
    // Museau
    const snout = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), whiteMat);
    snout.position.set(0.5, 0.05, 0);
    snout.scale.set(1.2, 0.8, 0.9);
    
    // Nez
    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0x222222 }));
    nose.position.set(0.6, 0.08, 0);
    
    // Oreilles tombantes
    const earGeom = new THREE.SphereGeometry(0.1, 8, 8);
    const earL = new THREE.Mesh(earGeom, dogMat);
    const earR = new THREE.Mesh(earGeom, dogMat);
    earL.scale.set(0.6, 1.2, 0.4);
    earR.scale.set(0.6, 1.2, 0.4);
    earL.position.set(0.25, 0.05, -0.15);
    earR.position.set(0.25, 0.05, 0.15);
    
    // Yeux excit√©s
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
    const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat);
    eyeL.position.set(0.45, 0.18, -0.1);
    eyeR.position.set(0.45, 0.18, 0.1);
    
    // Brillance des yeux
    const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const shineL = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), shineMat);
    const shineR = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), shineMat);
    shineL.position.set(0.48, 0.2, -0.11);
    shineR.position.set(0.48, 0.2, 0.09);
    
    // Queue qui remue
    const dogTail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.35, 8), dogMat);
    dogTail.position.set(-0.35, 0.15, 0);
    dogTail.rotation.z = -Math.PI / 4;
    
    // Pattes
    const legGeom = new THREE.CylinderGeometry(0.04, 0.05, 0.2, 8);
    const legFL = new THREE.Mesh(legGeom, dogMat);
    const legFR = new THREE.Mesh(legGeom, dogMat);
    const legBL = new THREE.Mesh(legGeom, dogMat);
    const legBR = new THREE.Mesh(legGeom, dogMat);
    legFL.position.set(0.15, -0.25, -0.12);
    legFR.position.set(0.15, -0.25, 0.12);
    legBL.position.set(-0.15, -0.25, -0.12);
    legBR.position.set(-0.15, -0.25, 0.12);
    
    // Langue qui pend (il court!)
    const tongue = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshPhongMaterial({ color: 0xff6688 }));
    tongue.scale.set(0.6, 1, 0.3);
    tongue.position.set(0.55, -0.05, 0.05);
    
    // Assembler le chien
    const dog = new THREE.Group();
    dog.add(dogBody, dogHead, snout, nose, earL, earR, eyeL, eyeR, shineL, shineR, dogTail, legFL, legFR, legBL, legBR, tongue);
    dog.position.x = 5.5;
    dog.scale.set(0.6, 0.6, 0.6);
    dogPivot.add(dog);
    
    // Tra√Æn√©e de poussi√®re
    const dustGeom = new THREE.BufferGeometry();
    const dustPos = [];
    for(let i = 0; i < 40; i++) dustPos.push(0, 0, 0);
    dustGeom.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
    const dust = new THREE.Points(dustGeom, new THREE.PointsMaterial({ color: 0xddaa77, size: 0.08, transparent: true, opacity: 0.6 }));
    dogScene.add(dust);
    const dustHistory = [];
    
    dogCamera.position.z = 6;
    
    // √âtat de la poursuite
    let dogAngle = Math.PI; // Commence √† l'oppos√© du chat
    let catAngle = 0;
    let dogSpeed = 0.018; // Vitesse de base du chien (rapide!)
    let catSpeed = 0.012; // Vitesse normale du chat
    let catEscapeSpeed = 0.04; // Vitesse de fuite du chat
    let isEscaping = false;
    let escapeTimer = 0;
    
    function animateDog() {
      requestAnimationFrame(animateDog);
      
      const time = Date.now() * 0.001;
      
      // Calculer la distance angulaire entre le chien et le chat
      let angleDiff = catAngle - dogAngle;
      // Normaliser entre -PI et PI
      while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
      while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
      
      const distance = Math.abs(angleDiff);
      
      // Le chien poursuit toujours le chat
      if(angleDiff > 0) {
        dogAngle += dogSpeed;
      } else {
        dogAngle -= dogSpeed;
      }
      
      // Si le chien est trop proche, le chat s'√©chappe!
      if(distance < 0.5 && !isEscaping) {
        isEscaping = true;
        escapeTimer = 60; // Frames d'√©chappement
      }
      
      if(isEscaping) {
        catAngle += catEscapeSpeed * (angleDiff > 0 ? 1 : -1);
        escapeTimer--;
        if(escapeTimer <= 0) {
          isEscaping = false;
        }
      } else {
        catAngle += catSpeed;
      }
      
      // Appliquer les positions
      dogPivot.rotation.y = dogAngle;
      dogPivot.rotation.x = Math.sin(time * 2) * 0.15;
      
      // Le chien regarde vers l'avant
      dog.rotation.y = -dogAngle + Math.PI / 2;
      
      // Animation de course du chien
      const runCycle = time * 15;
      legFL.rotation.x = Math.sin(runCycle) * 0.5;
      legFR.rotation.x = Math.sin(runCycle + Math.PI) * 0.5;
      legBL.rotation.x = Math.sin(runCycle + Math.PI) * 0.4;
      legBR.rotation.x = Math.sin(runCycle) * 0.4;
      
      // Queue qui remue fr√©n√©tiquement
      dogTail.rotation.x = Math.sin(time * 20) * 0.4;
      dogTail.rotation.z = -Math.PI / 4 + Math.sin(time * 15) * 0.2;
      
      // Oreilles qui flottent
      earL.rotation.x = Math.sin(time * 8) * 0.2;
      earR.rotation.x = Math.sin(time * 8 + 0.5) * 0.2;
      
      // Langue qui bouge
      tongue.position.y = -0.05 + Math.sin(time * 12) * 0.02;
      tongue.scale.y = 1 + Math.sin(time * 10) * 0.2;
      
      // Tra√Æn√©e de poussi√®re
      const dogWorldPos = new THREE.Vector3();
      dog.getWorldPosition(dogWorldPos);
      dustHistory.unshift(dogWorldPos.clone());
      if(dustHistory.length > 40) dustHistory.pop();
      const positions = dust.geometry.attributes.position.array;
      for(let i = 0; i < dustHistory.length; i++) {
        positions[i*3] = dustHistory[i].x + (Math.random()-0.5)*0.15;
        positions[i*3+1] = dustHistory[i].y - 0.2 + (Math.random()-0.5)*0.1;
        positions[i*3+2] = dustHistory[i].z + (Math.random()-0.5)*0.15;
      }
      dust.geometry.attributes.position.needsUpdate = true;
      
      // Exposer catAngle pour le chat existant
      window.chaseCatAngle = catAngle;
      window.isCatEscaping = isEscaping;
      
      dogRenderer.render(dogScene, dogCamera);
    }
    animateDog();
    
    window.addEventListener('resize', () => {
      dogCamera.aspect = window.innerWidth / window.innerHeight;
      dogCamera.updateProjectionMatrix();
      dogRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  }, 800);
})();
  </script>
<div class="content-section" id="section-animals" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none;">
<div id="animals-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
</div>
<div id="scoreboard" style="position: fixed; top: 80px; right: 30px; z-index: 100; background: linear-gradient(135deg, rgba(102, 126, 234, 0.8) 0%, rgba(118, 75, 162, 0.8) 100%); padding: 15px 25px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); backdrop-filter: blur(10px); font-family: system-ui, sans-serif;">
<div style="display: flex; align-items: center; gap: 15px;">
<span style="font-size: 30px;">
      üêï
     </span>
<span id="dog-score" style="font-size: 28px; font-weight: bold; color: #fff; text-shadow: 0 0 10px rgba(255,200,100,0.8);">
      0
     </span>
</div>
<div id="catch-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; opacity: 0; pointer-events: none; white-space: nowrap;">
     üéâ ATTRAP√â! üéâ
    </div>
</div>
</div>
<style>
   @keyframes scorePopup { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } } @keyframes scorePulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); color: #ffdd44; } }
  </style>
<script>
   (function() { setTimeout(() => { const container = document.getElementById('planet-container'); const dogScene = new THREE.Scene(); const dogCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); const dogRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); dogRenderer.setSize(window.innerWidth, window.innerHeight); dogRenderer.setClearColor(0x000000, 0); container.appendChild(dogRenderer.domElement); dogRenderer.domElement.style.position = 'absolute'; dogRenderer.domElement.style.top = '0'; dogRenderer.domElement.style.pointerEvents = 'none'; const light = new THREE.PointLight(0xffffff, 1.5); light.position.set(10, 5, 10); dogScene.add(light); dogScene.add(new THREE.AmbientLight(0x333366, 0.5)); const dogPivot = new THREE.Object3D(); dogScene.add(dogPivot); const dogMat = new THREE.MeshPhongMaterial({ color: 0xcc8844, emissive: 0x221100, specular: 0xffffff, shininess: 30 }); const whiteMat = new THREE.MeshPhongMaterial({ color: 0xffeedd, emissive: 0x111111 }); const dogBody = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), dogMat); dogBody.scale.set(1.2, 0.9, 0.9); const dogHead = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 16), dogMat); dogHead.position.set(0.35, 0.1, 0); const snout = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), whiteMat); snout.position.set(0.5, 0.05, 0); snout.scale.set(1.2, 0.8, 0.9); const nose = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0x222222 })); nose.position.set(0.6, 0.08, 0); const earGeom = new THREE.SphereGeometry(0.1, 8, 8); const earL = new THREE.Mesh(earGeom, dogMat); const earR = new THREE.Mesh(earGeom, dogMat); earL.scale.set(0.6, 1.2, 0.4); earR.scale.set(0.6, 1.2, 0.4); earL.position.set(0.25, 0.05, -0.15); earR.position.set(0.25, 0.05, 0.15); const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat); const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), eyeMat); eyeL.position.set(0.45, 0.18, -0.1); eyeR.position.set(0.45, 0.18, 0.1); const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); const shineL = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), shineMat); const shineR = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), shineMat); shineL.position.set(0.48, 0.2, -0.11); shineR.position.set(0.48, 0.2, 0.09); const dogTail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.35, 8), dogMat); dogTail.position.set(-0.35, 0.15, 0); dogTail.rotation.z = -Math.PI / 4; const legGeom = new THREE.CylinderGeometry(0.04, 0.05, 0.2, 8); const legFL = new THREE.Mesh(legGeom, dogMat); const legFR = new THREE.Mesh(legGeom, dogMat); const legBL = new THREE.Mesh(legGeom, dogMat); const legBR = new THREE.Mesh(legGeom, dogMat); legFL.position.set(0.15, -0.25, -0.12); legFR.position.set(0.15, -0.25, 0.12); legBL.position.set(-0.15, -0.25, -0.12); legBR.position.set(-0.15, -0.25, 0.12); const tongue = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), new THREE.MeshPhongMaterial({ color: 0xff6688 })); tongue.scale.set(0.6, 1, 0.3); tongue.position.set(0.55, -0.05, 0.05); const dog = new THREE.Group(); dog.add(dogBody, dogHead, snout, nose, earL, earR, eyeL, eyeR, shineL, shineR, dogTail, legFL, legFR, legBL, legBR, tongue); dog.position.x = 5.5; dog.scale.set(0.6, 0.6, 0.6); dogPivot.add(dog); const dustGeom = new THREE.BufferGeometry(); const dustPos = []; for(let i = 0; i < 40; i++) dustPos.push(0, 0, 0); dustGeom.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3)); const dust = new THREE.Points(dustGeom, new THREE.PointsMaterial({ color: 0xddaa77, size: 0.08, transparent: true, opacity: 0.6 })); dogScene.add(dust); const dustHistory = []; dogCamera.position.z = 6; let dogAngle = Math.PI; let catAngle = 0; let dogSpeed = 0.018; let catSpeed = 0.012; let catEscapeSpeed = 0.04; let isEscaping = false; let escapeTimer = 0; function animateDog() { requestAnimationFrame(animateDog); const time = Date.now() * 0.001; let angleDiff = catAngle - dogAngle; while(angleDiff > Math.PI) angleDiff -= Math.PI * 2; while(angleDiff < -Math.PI) angleDiff += Math.PI * 2; const distance = Math.abs(angleDiff); if(angleDiff > 0) { dogAngle += dogSpeed; } else { dogAngle -= dogSpeed; } if(distance < 0.25 && !isEscaping) { isEscaping = true; escapeTimer = 60; if(window.addDogPoint) window.addDogPoint(); } if(isEscaping) { catAngle += catEscapeSpeed * (angleDiff > 0 ? 1 : -1); escapeTimer--; if(escapeTimer <= 0) isEscaping = false; } else { catAngle += catSpeed; } dogPivot.rotation.y = dogAngle; dogPivot.rotation.x = Math.sin(time * 2) * 0.15; dog.rotation.y = -dogAngle + Math.PI / 2; const runCycle = time * 15; legFL.rotation.x = Math.sin(runCycle) * 0.5; legFR.rotation.x = Math.sin(runCycle + Math.PI) * 0.5; legBL.rotation.x = Math.sin(runCycle + Math.PI) * 0.4; legBR.rotation.x = Math.sin(runCycle) * 0.4; dogTail.rotation.x = Math.sin(time * 20) * 0.4; dogTail.rotation.z = -Math.PI / 4 + Math.sin(time * 15) * 0.2; earL.rotation.x = Math.sin(time * 8) * 0.2; earR.rotation.x = Math.sin(time * 8 + 0.5) * 0.2; tongue.position.y = -0.05 + Math.sin(time * 12) * 0.02; tongue.scale.y = 1 + Math.sin(time * 10) * 0.2; const dogWorldPos = new THREE.Vector3(); dog.getWorldPosition(dogWorldPos); dustHistory.unshift(dogWorldPos.clone()); if(dustHistory.length > 40) dustHistory.pop(); const positions = dust.geometry.attributes.position.array; for(let i = 0; i < dustHistory.length; i++) { positions[i*3] = dustHistory[i].x + (Math.random()-0.5)*0.15; positions[i*3+1] = dustHistory[i].y - 0.2 + (Math.random()-0.5)*0.1; positions[i*3+2] = dustHistory[i].z + (Math.random()-0.5)*0.15; } dust.geometry.attributes.position.needsUpdate = true; window.chaseCatAngle = catAngle; window.dogAngleForScore = dogAngle; window.isCatEscaping = isEscaping; dogRenderer.render(dogScene, dogCamera); } animateDog(); window.addEventListener('resize', () => { dogCamera.aspect = window.innerWidth / window.innerHeight; dogCamera.updateProjectionMatrix(); dogRenderer.setSize(window.innerWidth, window.innerHeight); }); }, 800); })();
  </script>
<script>
   (function() {
  // Couleurs de plan√®te possibles
  const planetColors = [
    { main: 0x4a90d9, emissive: 0x112244, atmos: 0x88ccff },
    { main: 0xd94a90, emissive: 0x441122, atmos: 0xff88cc },
    { main: 0x90d94a, emissive: 0x224411, atmos: 0xccff88 },
    { main: 0xd9904a, emissive: 0x442211, atmos: 0xffcc88 },
    { main: 0x904ad9, emissive: 0x221144, atmos: 0xcc88ff },
    { main: 0x4ad9d9, emissive: 0x114444, atmos: 0x88ffff },
    { main: 0xd9d94a, emissive: 0x444411, atmos: 0xffff88 },
    { main: 0xff6b6b, emissive: 0x331111, atmos: 0xffaaaa }
  ];
  let colorIndex = 0;
  let dogScore = 0;
  
  // Fonction pour changer la couleur de la plan√®te
  window.changePlanetColor = function() {
    colorIndex = (colorIndex + 1) % planetColors.length;
    const newColor = planetColors[colorIndex];
    
    // Trouver tous les canvas Three.js et envoyer un √©v√©nement
    window.newPlanetColor = newColor;
    window.dispatchEvent(new CustomEvent('planetColorChange', { detail: newColor }));
  };
  
  // Fonction appel√©e quand le chien attrape le chat
  window.addDogPoint = function() {
    dogScore++;
    const scoreEl = document.getElementById('dog-score');
    const msgEl = document.getElementById('catch-message');
    
    if(scoreEl) {
      scoreEl.textContent = dogScore;
      scoreEl.style.animation = 'scorePulse 0.5s ease';
      setTimeout(() => scoreEl.style.animation = '', 500);
    }
    
    if(msgEl) {
      msgEl.style.animation = 'scorePopup 1s ease forwards';
      setTimeout(() => msgEl.style.animation = '', 1000);
    }
    
    // Changer la couleur de la plan√®te!
    window.changePlanetColor();
  };
  
  // √âcouter l'√©v√©nement de changement de couleur dans les sc√®nes Three.js
  window.addEventListener('planetColorChange', (e) => {
    const color = e.detail;
    
    // Parcourir toutes les sc√®nes Three.js pour trouver la plan√®te
    const container = document.getElementById('planet-container');
    if(container && window.THREE) {
      // Cr√©er une animation de transition flash
      const flash = document.createElement('div');
      flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,rgba(255,255,255,0.8) 0%,transparent 70%);z-index:50;pointer-events:none;animation:planetFlash 0.5s ease-out forwards;';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 500);
    }
  });
})();
  </script>
<style>
   @keyframes planetFlash {
  0% { opacity: 1; transform: scale(0.5); }
  100% { opacity: 0; transform: scale(2); }
}
  </style>
<div class="content-section" id="section-games" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);">
<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding-top: 60px;">
<h2 style="color: white; font-size: 48px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(0, 198, 255, 0.8);">
     üéÆ Arcade Spatiale
    </h2>
<p style="color: rgba(255,255,255,0.7); font-size: 18px; margin-bottom: 40px;">
     Pilotez votre vaisseau et d√©truisez les ast√©ro√Ødes!
    </p>
<button id="start-game-btn" onclick="document.getElementById('game-overlay').style.display='block'; document.getElementById('play-game-btn').click();" style="padding: 20px 50px; font-size: 24px; font-weight: bold; background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%); border: none; color: white; border-radius: 30px; cursor: pointer; box-shadow: 0 6px 25px rgba(0, 198, 255, 0.5); transition: all 0.3s ease;">
     üöÄ LANCER LE JEU
    </button>
<div style="margin-top: 40px; color: rgba(255,255,255,0.5); font-size: 14px;">
<p>
      ‚¨ÜÔ∏è Avancer | ‚¨ÖÔ∏è‚û°Ô∏è Tourner | ESPACE Tirer | ESC Quitter
     </p>
</div>
</div>
</div>
<div id="game-overlay" style="display: none;">
<div id="game-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 200; display: none; background: rgba(0,0,0,0.9);">
<canvas id="game-canvas">
</canvas>
<div id="game-ui" style="position: absolute; top: 20px; left: 20px; color: white; font-family: 'Courier New', monospace; font-size: 18px; text-shadow: 0 0 10px #0ff;">
<div>
      SCORE:
      <span id="game-score">
       0
      </span>
</div>
<div>
      VIES:
      <span id="game-lives">
       ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è
      </span>
</div>
</div>
<div id="game-over" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; font-family: system-ui;">
<h2 style="font-size: 48px; color: #ff4444; text-shadow: 0 0 20px #ff0000;">
      GAME OVER
     </h2>
<p style="font-size: 24px;">
      Score final:
      <span id="final-score">
       0
      </span>
</p>
<button onclick="restartGame()" style="padding: 15px 30px; font-size: 20px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; color: white; border-radius: 10px; cursor: pointer; margin-top: 20px;">
      REJOUER
     </button>
</div>
<button id="close-game" onclick="closeGame(); document.getElementById('game-overlay').style.display='none';" style="position: absolute; top: 20px; right: 20px; background: rgba(255,100,100,0.8); border: none; color: white; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
     ‚úï FERMER
    </button>
</div>
</div>
<button id="play-game-btn" style="display: none;">
   üöÄ JOUER
  </button>
<script>
   (function() {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('game-container');
  const playBtn = document.getElementById('play-game-btn');
  
  let gameRunning = false;
  let score = 0;
  let lives = 3;
  let ship, bullets, asteroids, particles, stars;
  let keys = {};
  
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  
  function initGame() {
    resizeCanvas();
    score = 0;
    lives = 3;
    updateUI();
    
    ship = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      angle: -Math.PI / 2,
      vx: 0,
      vy: 0,
      radius: 15,
      thrust: false,
      invincible: 0
    };
    
    bullets = [];
    asteroids = [];
    particles = [];
    stars = [];
    
    // Cr√©er les √©toiles de fond
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 0.5,
        twinkle: Math.random() * Math.PI * 2
      });
    }
    
    // Cr√©er les ast√©ro√Ødes initiaux
    for (let i = 0; i < 5; i++) {
      spawnAsteroid();
    }
    
    document.getElementById('game-over').style.display = 'none';
  }
  
  function spawnAsteroid(x, y, size) {
    size = size || 3;
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 2;
    
    if (x === undefined) {
      const side = Math.floor(Math.random() * 4);
      if (side === 0) { x = 0; y = Math.random() * canvas.height; }
      else if (side === 1) { x = canvas.width; y = Math.random() * canvas.height; }
      else if (side === 2) { x = Math.random() * canvas.width; y = 0; }
      else { x = Math.random() * canvas.width; y = canvas.height; }
    }
    
    // Forme irr√©guli√®re
    const vertices = [];
    const numVertices = 8 + Math.floor(Math.random() * 5);
    for (let i = 0; i < numVertices; i++) {
      const a = (i / numVertices) * Math.PI * 2;
      const r = (size * 15) * (0.7 + Math.random() * 0.3);
      vertices.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
    }
    
    asteroids.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size,
      radius: size * 15,
      rotation: 0,
      rotSpeed: (Math.random() - 0.5) * 0.05,
      vertices,
      color: `hsl(${30 + Math.random() * 30}, 30%, ${40 + Math.random() * 20}%)`
    });
  }
  
  function shoot() {
    const speed = 10;
    bullets.push({
      x: ship.x + Math.cos(ship.angle) * 20,
      y: ship.y + Math.sin(ship.angle) * 20,
      vx: Math.cos(ship.angle) * speed + ship.vx * 0.5,
      vy: Math.sin(ship.angle) * speed + ship.vy * 0.5,
      life: 60
    });
  }
  
  function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 5 + 2;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 30 + Math.random() * 30,
        color,
        size: Math.random() * 4 + 2
      });
    }
  }
  
  function updateUI() {
    document.getElementById('game-score').textContent = score;
    document.getElementById('game-lives').textContent = '‚ù§Ô∏è'.repeat(Math.max(0, lives));
  }
  
  function update() {
    if (!gameRunning) return;
    
    // Contr√¥les du vaisseau
    if (keys['ArrowLeft'] || keys['KeyA']) ship.angle -= 0.08;
    if (keys['ArrowRight'] || keys['KeyD']) ship.angle += 0.08;
    if (keys['ArrowUp'] || keys['KeyW']) {
      ship.vx += Math.cos(ship.angle) * 0.15;
      ship.vy += Math.sin(ship.angle) * 0.15;
      ship.thrust = true;
      // Particules de propulsion
      if (Math.random() > 0.5) {
        particles.push({
          x: ship.x - Math.cos(ship.angle) * 15,
          y: ship.y - Math.sin(ship.angle) * 15,
          vx: -Math.cos(ship.angle) * 3 + (Math.random() - 0.5) * 2,
          vy: -Math.sin(ship.angle) * 3 + (Math.random() - 0.5) * 2,
          life: 20,
          color: '#ff6600',
          size: Math.random() * 3 + 2
        });
      }
    } else {
      ship.thrust = false;
    }
    
    // Friction
    ship.vx *= 0.99;
    ship.vy *= 0.99;
    
    // Limite de vitesse
    const maxSpeed = 8;
    const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    if (speed > maxSpeed) {
      ship.vx = (ship.vx / speed) * maxSpeed;
      ship.vy = (ship.vy / speed) * maxSpeed;
    }
    
    // Mouvement du vaisseau
    ship.x += ship.vx;
    ship.y += ship.vy;
    
    // Wrap around
    if (ship.x < 0) ship.x = canvas.width;
    if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    if (ship.y > canvas.height) ship.y = 0;
    
    if (ship.invincible > 0) ship.invincible--;
    
    // Mise √† jour des balles
    bullets = bullets.filter(b => {
      b.x += b.vx;
      b.y += b.vy;
      b.life--;
      
      // Wrap around
      if (b.x < 0) b.x = canvas.width;
      if (b.x > canvas.width) b.x = 0;
      if (b.y < 0) b.y = canvas.height;
      if (b.y > canvas.height) b.y = 0;
      
      return b.life > 0;
    });
    
    // Mise √† jour des ast√©ro√Ødes
    asteroids.forEach(a => {
      a.x += a.vx;
      a.y += a.vy;
      a.rotation += a.rotSpeed;
      
      // Wrap around
      if (a.x < -a.radius) a.x = canvas.width + a.radius;
      if (a.x > canvas.width + a.radius) a.x = -a.radius;
      if (a.y < -a.radius) a.y = canvas.height + a.radius;
      if (a.y > canvas.height + a.radius) a.y = -a.radius;
    });
    
    // Collision balles-ast√©ro√Ødes
    bullets.forEach((b, bi) => {
      asteroids.forEach((a, ai) => {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < a.radius) {
          bullets.splice(bi, 1);
          createExplosion(a.x, a.y, a.color, 15);
          
          score += (4 - a.size) * 100;
          updateUI();
          
          if (a.size > 1) {
            spawnAsteroid(a.x, a.y, a.size - 1);
            spawnAsteroid(a.x, a.y, a.size - 1);
          }
          
          asteroids.splice(ai, 1);
        }
      });
    });
    
    // Collision vaisseau-ast√©ro√Ødes
    if (ship.invincible <= 0) {
      asteroids.forEach(a => {
        const dx = ship.x - a.x;
        const dy = ship.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < a.radius + ship.radius) {
          lives--;
          updateUI();
          createExplosion(ship.x, ship.y, '#00ffff', 30);
          ship.invincible = 120;
          ship.x = canvas.width / 2;
          ship.y = canvas.height / 2;
          ship.vx = 0;
          ship.vy = 0;
          
          if (lives <= 0) {
            gameOver();
          }
        }
      });
    }
    
    // Mise √† jour des particules
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.life--;
      return p.life > 0;
    });
    
    // Spawn de nouveaux ast√©ro√Ødes
    if (asteroids.length < 3 + Math.floor(score / 1000)) {
      spawnAsteroid();
    }
  }
  
  function draw() {
    ctx.fillStyle = 'rgba(0, 0, 20, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // √âtoiles
    stars.forEach(s => {
      s.twinkle += 0.05;
      const alpha = 0.5 + Math.sin(s.twinkle) * 0.3;
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Particules
    particles.forEach(p => {
      const alpha = p.life / 60;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Ast√©ro√Ødes
    asteroids.forEach(a => {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.rotation);
      ctx.strokeStyle = a.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(a.vertices[0].x, a.vertices[0].y);
      a.vertices.forEach(v => ctx.lineTo(v.x, v.y));
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    });
    
    // Balles
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 10;
    bullets.forEach(b => {
      ctx.beginPath();
      ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;
    
    // Vaisseau
    if (ship.invincible <= 0 || Math.floor(ship.invincible / 5) % 2 === 0) {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);
      
      // Corps du vaisseau
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(20, 0);
      ctx.lineTo(-15, -12);
      ctx.lineTo(-10, 0);
      ctx.lineTo(-15, 12);
      ctx.closePath();
      ctx.stroke();
      
      // Flamme de propulsion
      if (ship.thrust) {
        ctx.strokeStyle = '#ff6600';
        ctx.shadowColor = '#ff6600';
        ctx.beginPath();
        ctx.moveTo(-10, -5);
        ctx.lineTo(-25 - Math.random() * 10, 0);
        ctx.lineTo(-10, 5);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    ctx.shadowBlur = 0;
  }
  
  function gameLoop() {
    if (gameRunning) {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
  }
  
  function gameOver() {
    gameRunning = false;
    document.getElementById('final-score').textContent = score;
    document.getElementById('game-over').style.display = 'block';
  }
  
  window.restartGame = function() {
    initGame();
    gameRunning = true;
    gameLoop();
  };
  
  window.closeGame = function() {
    gameRunning = false;
    container.style.display = 'none';
  };
  
  playBtn.addEventListener('click', () => {
    container.style.display = 'block';
    initGame();
    gameRunning = true;
    gameLoop();
  });
  
  document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'Space' && gameRunning) {
      shoot();
      e.preventDefault();
    }
    if (e.code === 'Escape' && container.style.display === 'block') {
      closeGame();
    }
  });
  
  document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });
  
  window.addEventListener('resize', resizeCanvas);
})();
  </script>
<div data-parent="animals" id="elephant-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; pointer-events: none; display: none;">
</div>
<script>
   (function() { setTimeout(() => { const container = document.getElementById('elephant-container'); const elephantScene = new THREE.Scene(); const elephantCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); const elephantRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); elephantRenderer.setSize(window.innerWidth, window.innerHeight); elephantRenderer.setClearColor(0x000000, 0); container.appendChild(elephantRenderer.domElement); const light = new THREE.PointLight(0xffffff, 1.5); light.position.set(5, 5, 10); elephantScene.add(light); elephantScene.add(new THREE.AmbientLight(0x6688aa, 0.6)); const elephantMat = new THREE.MeshPhongMaterial({ color: 0x888899, emissive: 0x222233, specular: 0xaaaaaa, shininess: 20 }); const pinkMat = new THREE.MeshPhongMaterial({ color: 0xffaaaa, emissive: 0x331111 }); const elephant = new THREE.Group(); const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), elephantMat); body.scale.set(1.2, 0.9, 0.9); elephant.add(body); const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), elephantMat); head.position.set(0.9, 0.3, 0); elephant.add(head); const trunkSegments = []; const trunkMat = elephantMat.clone(); for(let i = 0; i < 8; i++) { const seg = new THREE.Mesh(new THREE.CylinderGeometry(0.12 - i*0.01, 0.14 - i*0.01, 0.2, 16), trunkMat); seg.position.set(1.3 + i*0.15, 0.1 - i*0.08, 0); seg.rotation.z = Math.PI/2 + i*0.15; trunkSegments.push(seg); elephant.add(seg); } const earL = new THREE.Mesh(new THREE.CircleGeometry(0.4, 32), elephantMat); earL.position.set(0.6, 0.5, -0.4); earL.rotation.y = -0.5; elephant.add(earL); const earLInner = new THREE.Mesh(new THREE.CircleGeometry(0.25, 32), pinkMat); earLInner.position.set(0.61, 0.5, -0.39); earLInner.rotation.y = -0.5; elephant.add(earLInner); const earR = new THREE.Mesh(new THREE.CircleGeometry(0.4, 32), elephantMat); earR.position.set(0.6, 0.5, 0.4); earR.rotation.y = 0.5; elephant.add(earR); const earRInner = new THREE.Mesh(new THREE.CircleGeometry(0.25, 32), pinkMat); earRInner.position.set(0.61, 0.5, 0.39); earRInner.rotation.y = 0.5; elephant.add(earRInner); const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 }); const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat); eyeL.position.set(1.2, 0.5, -0.2); elephant.add(eyeL); const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), eyeMat); eyeR.position.set(1.2, 0.5, 0.2); elephant.add(eyeR); const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); const shineL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), shineMat); shineL.position.set(1.25, 0.53, -0.22); elephant.add(shineL); const shineR = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), shineMat); shineR.position.set(1.25, 0.53, 0.18); elephant.add(shineR); const legGeom = new THREE.CylinderGeometry(0.15, 0.18, 0.6, 16); const legFL = new THREE.Mesh(legGeom, elephantMat); legFL.position.set(0.4, -0.7, -0.35); elephant.add(legFL); const legFR = new THREE.Mesh(legGeom, elephantMat); legFR.position.set(0.4, -0.7, 0.35); elephant.add(legFR); const legBL = new THREE.Mesh(legGeom, elephantMat); legBL.position.set(-0.5, -0.7, -0.35); elephant.add(legBL); const legBR = new THREE.Mesh(legGeom, elephantMat); legBR.position.set(-0.5, -0.7, 0.35); elephant.add(legBR); const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.05, 0.5, 8), elephantMat); tail.position.set(-1.1, -0.2, 0); tail.rotation.z = Math.PI/3; elephant.add(tail); const tailTuft = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshPhongMaterial({color: 0x555566})); tailTuft.position.set(-1.3, -0.45, 0); elephant.add(tailTuft); elephant.position.set(0, 0, 0); elephant.scale.set(1.5, 1.5, 1.5); elephantScene.add(elephant); const waterParticles = []; const waterGeom = new THREE.SphereGeometry(0.05, 8, 8); const waterMat = new THREE.MeshPhongMaterial({ color: 0x44aaff, emissive: 0x113355, transparent: true, opacity: 0.8 }); function spawnWater() { const particle = new THREE.Mesh(waterGeom, waterMat.clone()); const trunkEnd = new THREE.Vector3(2.5, 0.8, 0); particle.position.copy(trunkEnd); const angle = Math.random() * 0.5 - 0.25; const upAngle = Math.random() * 0.3 + 0.3; particle.userData = { vx: Math.cos(angle) * 0.15, vy: Math.sin(upAngle) * 0.25 + 0.1, vz: Math.sin(angle) * 0.1, life: 80 + Math.random() * 40 }; waterParticles.push(particle); elephantScene.add(particle); } elephantCamera.position.z = 6; let time = 0; function animateElephant() { requestAnimationFrame(animateElephant); time += 0.016; elephant.rotation.y = Math.sin(time * 0.5) * 0.2; earL.rotation.x = Math.sin(time * 2) * 0.1; earR.rotation.x = Math.sin(time * 2 + 0.5) * 0.1; for(let i = 0; i < trunkSegments.length; i++) { trunkSegments[i].rotation.x = Math.sin(time * 3 + i * 0.3) * 0.2; trunkSegments[i].position.y = 0.1 - i*0.08 + Math.sin(time * 2 + i * 0.2) * 0.05; } tail.rotation.x = Math.sin(time * 4) * 0.3; if(Math.random() > 0.7) { spawnWater(); } for(let i = waterParticles.length - 1; i >= 0; i--) { const p = waterParticles[i]; p.position.x += p.userData.vx; p.position.y += p.userData.vy; p.position.z += p.userData.vz; p.userData.vy -= 0.008; p.userData.life--; p.material.opacity = Math.min(0.8, p.userData.life / 40); p.scale.setScalar(1 + (80 - p.userData.life) * 0.01); if(p.userData.life <= 0 || p.position.y < -3) { elephantScene.remove(p); waterParticles.splice(i, 1); } } elephantRenderer.render(elephantScene, elephantCamera); } animateElephant(); window.addEventListener('resize', () => { elephantCamera.aspect = window.innerWidth / window.innerHeight; elephantCamera.updateProjectionMatrix(); elephantRenderer.setSize(window.innerWidth, window.innerHeight); }); }, 1000); })();
  </script>
<script>
   function showSection(sectionName) {
  // Cacher toutes les sections
  document.querySelectorAll('.content-section').forEach(s => {
    s.style.display = 'none';
  });
  
  // Afficher la section demand√©e
  const section = document.getElementById('section-' + sectionName);
  if(section) {
    section.style.display = 'block';
  }
  
  // Mettre √† jour les boutons du menu
  document.querySelectorAll('.nav-btn').forEach(btn => {
    if(btn.dataset.section === sectionName) {
      btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      btn.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.5)';
      btn.classList.add('active');
    } else {
      btn.style.background = 'rgba(255,255,255,0.1)';
      btn.style.boxShadow = 'none';
      btn.classList.remove('active');
    }
  });
  
  // G√©rer l'√©l√©phant dans la section animaux
  const elephantContainer = document.getElementById('elephant-container');
  if(elephantContainer) {
    elephantContainer.style.display = sectionName === 'animals' ? 'block' : 'none';
  }
}

// Hover effects pour les boutons
document.querySelectorAll('.nav-btn').forEach(btn => {
  btn.addEventListener('mouseover', function() {
    if(!this.classList.contains('active')) {
      this.style.background = 'rgba(255,255,255,0.2)';
    }
  });
  btn.addEventListener('mouseout', function() {
    if(!this.classList.contains('active')) {
      this.style.background = 'rgba(255,255,255,0.1)';
    }
  });
});
  </script>
<script>
   (function() {
  const sections = ['space', 'animals', 'games'];
  let currentIndex = 0;
  let autoRotateInterval;
  
  function startAutoRotate() {
    autoRotateInterval = setInterval(() => {
      currentIndex = (currentIndex + 1) % sections.length;
      showSection(sections[currentIndex]);
    }, 30000);
  }
  
  // Synchroniser l'index quand l'utilisateur clique manuellement
  document.querySelectorAll('.nav-btn').forEach((btn, index) => {
    btn.addEventListener('click', () => {
      currentIndex = sections.indexOf(btn.dataset.section);
      // Reset le timer quand on clique manuellement
      clearInterval(autoRotateInterval);
      startAutoRotate();
    });
  });
  
  // D√©marrer la rotation automatique
  startAutoRotate();
  
  // Indicateur visuel du temps restant
  const timerBar = document.createElement('div');
  timerBar.id = 'section-timer';
  timerBar.style.cssText = 'position: fixed; top: 60px; left: 0; height: 3px; background: linear-gradient(90deg, #667eea, #764ba2, #00c6ff); z-index: 1001; animation: timerProgress 30s linear infinite;';
  document.body.appendChild(timerBar);
  
  const timerStyle = document.createElement('style');
  timerStyle.textContent = '@keyframes timerProgress { 0% { width: 0%; } 100% { width: 100%; } }';
  document.head.appendChild(timerStyle);
  
  // Reset l'animation de la barre quand on change de section
  const originalShowSection = window.showSection;
  window.showSection = function(sectionName) {
    originalShowSection(sectionName);
    const timer = document.getElementById('section-timer');
    if(timer) {
      timer.style.animation = 'none';
      timer.offsetHeight; // Force reflow
      timer.style.animation = 'timerProgress 30s linear infinite';
    }
  };
})();
  </script>
</body>
</html>
