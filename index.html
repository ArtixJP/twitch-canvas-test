<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        h1 { font-size: 3rem; text-align: center; }
  </style>
</head>
<body>
<h1 style="position: absolute; top: 20px; z-index: 10; text-shadow: 0 0 20px rgba(255, 200, 100, 0.8), 0 0 40px rgba(255, 150, 50, 0.5);">
   Hello World ‚òÄÔ∏è
  </h1>
<div id="planet-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Plan√®te
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a90d9,
    emissive: 0x112244,
    specular: 0x333333,
    shininess: 25
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Lune orbitante
  const moonPivot = new THREE.Object3D();
  scene.add(moonPivot);
  
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    emissive: 0x222222,
    specular: 0x444444,
    shininess: 10
  });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.position.x = 4;
  moonPivot.add(moon);
  
  const moonGlowGeom = new THREE.SphereGeometry(0.5, 32, 32);
  const moonGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffffee,
    transparent: true,
    opacity: 0.15
  });
  const moonGlow = new THREE.Mesh(moonGlowGeom, moonGlowMat);
  moonGlow.position.x = 4;
  moonPivot.add(moonGlow);

  // === CUTE KITTY ===
  const kittyPivot = new THREE.Object3D();
  scene.add(kittyPivot);
  
  const kittyMat = new THREE.MeshPhongMaterial({ color: 0xffaa88, emissive: 0x331111, specular: 0xffffff, shininess: 30 });
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), kittyMat);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), kittyMat);
  head.position.set(0.2, 0.15, 0);
  const earL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), kittyMat);
  const earR = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.15, 4), kittyMat);
  earL.position.set(0.25, 0.35, -0.08); earR.position.set(0.25, 0.35, 0.08);
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  eyeL.position.set(0.35, 0.2, -0.08); eyeR.position.set(0.35, 0.2, 0.08);
  const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const shineL = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), shineMat);
  const shineR = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), shineMat);
  shineL.position.set(0.37, 0.22, -0.09); shineR.position.set(0.37, 0.22, 0.07);
  const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.05, 0.4, 8), kittyMat);
  tail.position.set(-0.3, 0.1, 0); tail.rotation.z = Math.PI / 3;
  
  const kitty = new THREE.Group();
  kitty.add(body, head, earL, earR, eyeL, eyeR, shineL, shineR, tail);
  kitty.position.x = 5;
  kitty.scale.set(0.7, 0.7, 0.7);
  kittyPivot.add(kitty);
  
  // Tra√Æn√©e d'√©toiles sparkle
  const sparkleGeom = new THREE.BufferGeometry();
  const sparklePos = [];
  for(let i = 0; i < 30; i++) sparklePos.push(0, 0, 0);
  sparkleGeom.setAttribute('position', new THREE.Float32BufferAttribute(sparklePos, 3));
  const sparkles = new THREE.Points(sparkleGeom, new THREE.PointsMaterial({ color: 0xffff99, size: 0.1, transparent: true, opacity: 0.8 }));
  scene.add(sparkles);
  const sparkleHistory = [];

  // Anneau
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x9966cc, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumi√®res
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
  scene.add(stars);

  camera.position.z = 6;

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    ring.rotation.z += 0.001;
    atmosphere.rotation.y += 0.002;
    stars.rotation.y += 0.0002;
    moonPivot.rotation.y += 0.008;
    moonPivot.rotation.x = Math.sin(Date.now() * 0.0005) * 0.2;
    moon.rotation.y += 0.01;
    
    // Kitty orbit!
    kittyPivot.rotation.y += 0.012;
    kittyPivot.rotation.x = Math.sin(Date.now() * 0.001) * 0.3;
    kitty.rotation.y = -kittyPivot.rotation.y + Math.PI / 2;
    tail.rotation.x = Math.sin(Date.now() * 0.01) * 0.3;
    
    // Update sparkle trail
    const kittyWorldPos = new THREE.Vector3();
    kitty.getWorldPosition(kittyWorldPos);
    sparkleHistory.unshift(kittyWorldPos.clone());
    if(sparkleHistory.length > 30) sparkleHistory.pop();
    const positions = sparkles.geometry.attributes.position.array;
    for(let i = 0; i < sparkleHistory.length; i++) {
      positions[i*3] = sparkleHistory[i].x + (Math.random()-0.5)*0.1;
      positions[i*3+1] = sparkleHistory[i].y + (Math.random()-0.5)*0.1;
      positions[i*3+2] = sparkleHistory[i].z + (Math.random()-0.5)*0.1;
    }
    sparkles.geometry.attributes.position.needsUpdate = true;
    
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  // Attendre que Three.js soit charg√©
  const checkScene = setInterval(() => {
    const container = document.getElementById('planet-container');
    if (container && container.children.length > 0) {
      clearInterval(checkScene);
      addKittyToScene();
    }
  }, 100);

  function addKittyToScene() {
    // R√©cup√©rer la sc√®ne existante
    const scene = window.kittyScene || (function() {
      // Cr√©er une nouvelle sc√®ne pour le kitty qui utilise le m√™me renderer
      const container = document.getElementById('planet-container');
      const canvas = container.querySelector('canvas');
      
      // On va ajouter le kitty via un nouveau pivot dans le DOM
      const kittyPivot = new THREE.Object3D();
      kittyPivot.name = 'kittyOrbit';
      
      // Cr√©er le corps du chat
      const bodyGeom = new THREE.SphereGeometry(0.25, 16, 16);
      const kittyMat = new THREE.MeshPhongMaterial({
        color: 0xffaa88,
        emissive: 0x331111,
        specular: 0xffffff,
        shininess: 30
      });
      const body = new THREE.Mesh(bodyGeom, kittyMat);
      
      // T√™te du chat
      const headGeom = new THREE.SphereGeometry(0.2, 16, 16);
      const head = new THREE.Mesh(headGeom, kittyMat);
      head.position.set(0.2, 0.15, 0);
      
      // Oreilles
      const earGeom = new THREE.ConeGeometry(0.08, 0.15, 4);
      const earMat = new THREE.MeshPhongMaterial({ color: 0xffaa88, emissive: 0x331111 });
      const earL = new THREE.Mesh(earGeom, earMat);
      const earR = new THREE.Mesh(earGeom, earMat);
      earL.position.set(0.25, 0.35, -0.08);
      earR.position.set(0.25, 0.35, 0.08);
      earL.rotation.z = -0.2;
      earR.rotation.z = -0.2;
      
      // Yeux kawaii
      const eyeGeom = new THREE.SphereGeometry(0.04, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const eyeL = new THREE.Mesh(eyeGeom, eyeMat);
      const eyeR = new THREE.Mesh(eyeGeom, eyeMat);
      eyeL.position.set(0.35, 0.2, -0.08);
      eyeR.position.set(0.35, 0.2, 0.08);
      
      // Brillance des yeux
      const shineGeom = new THREE.SphereGeometry(0.015, 8, 8);
      const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const shineL = new THREE.Mesh(shineGeom, shineMat);
      const shineR = new THREE.Mesh(shineGeom, shineMat);
      shineL.position.set(0.37, 0.22, -0.09);
      shineR.position.set(0.37, 0.22, 0.07);
      
      // Queue
      const tailGeom = new THREE.CylinderGeometry(0.03, 0.05, 0.4, 8);
      const tail = new THREE.Mesh(tailGeom, kittyMat);
      tail.position.set(-0.3, 0.1, 0);
      tail.rotation.z = Math.PI / 3;
      
      // Assembler le chat
      const kitty = new THREE.Group();
      kitty.add(body, head, earL, earR, eyeL, eyeR, shineL, shineR, tail);
      kitty.position.x = 5.5;
      kitty.scale.set(0.8, 0.8, 0.8);
      
      kittyPivot.add(kitty);
      
      // Tra√Æn√©e d'√©toiles
      const trailGeom = new THREE.BufferGeometry();
      const trailPositions = [];
      for(let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 0.5;
        trailPositions.push(
          Math.cos(angle) * 5.5 - Math.random() * 0.3,
          Math.sin(i * 0.1) * 0.2,
          Math.sin(angle) * 5.5 - Math.random() * 0.3
        );
      }
      trailGeom.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
      const trail = new THREE.Points(trailGeom, new THREE.PointsMaterial({ 
        color: 0xffff88, 
        size: 0.08,
        transparent: true,
        opacity: 0.7
      }));
      kittyPivot.add(trail);
      
      // Ajouter √† la sc√®ne Three.js existante
      const renderer = container.querySelector('canvas').__three_renderer;
      if (renderer && renderer.info) {
        // Acc√®s direct impossible, on utilise une autre m√©thode
      }
      
      // Stocker pour l'animation
      window.kittyData = { pivot: kittyPivot, kitty: kitty, tail: tail, trail: trail };
      
      return kittyPivot;
    })();
  }
})();
  </script>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Plan√®te
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a90d9,
    emissive: 0x112244,
    specular: 0x333333,
    shininess: 25
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Lune orbitante
  const moonPivot = new THREE.Object3D();
  scene.add(moonPivot);
  
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    emissive: 0x222222,
    specular: 0x444444,
    shininess: 10
  });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.position.x = 4;
  moonPivot.add(moon);
  
  // Lueur de la lune
  const moonGlowGeom = new THREE.SphereGeometry(0.5, 32, 32);
  const moonGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffffee,
    transparent: true,
    opacity: 0.15
  });
  const moonGlow = new THREE.Mesh(moonGlowGeom, moonGlowMat);
  moonGlow.position.x = 4;
  moonPivot.add(moonGlow);

  // Anneau
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x9966cc,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumi√®res
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const stars = new THREE.Points(starsGeom, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 }));
  scene.add(stars);

  camera.position.z = 6;

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    ring.rotation.z += 0.001;
    atmosphere.rotation.y += 0.002;
    stars.rotation.y += 0.0002;
    
    // Orbite de la lune
    moonPivot.rotation.y += 0.008;
    moonPivot.rotation.x = Math.sin(Date.now() * 0.0005) * 0.2;
    moon.rotation.y += 0.01;
    
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<audio autoplay="" id="bg-music" loop="" preload="auto">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="music-toggle" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.5)';" onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.7)';" style="position: fixed; bottom: 30px; right: 30px; z-index: 100; width: 60px; height: 60px; border-radius: 50%; border: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-size: 24px; cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
   üéµ
  </button>
<script>
   (function() {
  const audio = document.getElementById('bg-music');
  const btn = document.getElementById('music-toggle');
  let isPlaying = true;
  
  // Autoplay peut √™tre bloqu√©, g√©rer √ßa
  audio.play().catch(() => {
    isPlaying = false;
    btn.innerHTML = '‚ñ∂Ô∏è';
  });
  
  btn.addEventListener('click', () => {
    if (isPlaying) {
      audio.pause();
      btn.innerHTML = '‚ñ∂Ô∏è';
      btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
    } else {
      audio.play();
      btn.innerHTML = 'üéµ';
      btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    }
    isPlaying = !isPlaying;
  });
})();
  </script>
<div id="autoplay-overlay" onclick="this.style.display='none'; document.getElementById('bg-music').play(); document.getElementById('music-toggle').innerHTML='üéµ';" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; backdrop-filter: blur(10px);">
<div style="font-size: 80px; animation: pulse 1.5s infinite;">
    üéµ
   </div>
<p style="color: white; font-size: 24px; margin-top: 20px; text-shadow: 0 0 10px rgba(100,200,255,0.8);">
    Cliquez pour entrer dans l'univers
   </p>
<style>
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
   </style>
</div>
<script>
   (function() {
  // Attendre que Three.js soit pr√™t
  setTimeout(() => {
    const container = document.getElementById('planet-container');
    const canvases = container.querySelectorAll('canvas');
    
    // Cr√©er une nouvelle sc√®ne pour le soleil
    const sunScene = new THREE.Scene();
    const sunCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const sunRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    sunRenderer.setSize(window.innerWidth, window.innerHeight);
    sunRenderer.setClearColor(0x000000, 0);
    sunRenderer.shadowMap.enabled = true;
    sunRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.insertBefore(sunRenderer.domElement, container.firstChild);
    sunRenderer.domElement.style.position = 'absolute';
    sunRenderer.domElement.style.pointerEvents = 'none';
    
    // Soleil principal
    const sunGeom = new THREE.SphereGeometry(1.5, 64, 64);
    const sunMat = new THREE.MeshBasicMaterial({
      color: 0xffdd44,
    });
    const sun = new THREE.Mesh(sunGeom, sunMat);
    sun.position.set(-15, 8, -10);
    sunScene.add(sun);
    
    // Couronne solaire (glow)
    const coronaGeom = new THREE.SphereGeometry(2.2, 64, 64);
    const coronaMat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        color1: { value: new THREE.Color(0xffaa00) },
        color2: { value: new THREE.Color(0xff4400) }
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          float pulse = sin(time * 3.0) * 0.1 + 0.9;
          vec3 color = mix(color1, color2, sin(time + vPosition.y * 2.0) * 0.5 + 0.5);
          gl_FragColor = vec4(color, intensity * pulse * 0.6);
        }
      `,
      transparent: true,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending
    });
    const corona = new THREE.Mesh(coronaGeom, coronaMat);
    corona.position.copy(sun.position);
    sunScene.add(corona);
    
    // Rayons de lumi√®re (god rays effect)
    const rayCount = 12;
    const rays = [];
    for(let i = 0; i < rayCount; i++) {
      const rayGeom = new THREE.ConeGeometry(0.3, 8, 8, 1, true);
      const rayMat = new THREE.MeshBasicMaterial({
        color: 0xffee88,
        transparent: true,
        opacity: 0.15,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const ray = new THREE.Mesh(rayGeom, rayMat);
      ray.position.copy(sun.position);
      const angle = (i / rayCount) * Math.PI * 2;
      ray.rotation.x = Math.cos(angle) * 0.3;
      ray.rotation.z = Math.sin(angle) * 0.3 + Math.PI;
      ray.userData.baseRotZ = ray.rotation.z;
      ray.userData.offset = i * 0.5;
      rays.push(ray);
      sunScene.add(ray);
    }
    
    // Lumi√®re directionnelle avec ombres
    const sunLight = new THREE.DirectionalLight(0xffeeaa, 2);
    sunLight.position.copy(sun.position);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 50;
    sunLight.shadow.camera.left = -10;
    sunLight.shadow.camera.right = 10;
    sunLight.shadow.camera.top = 10;
    sunLight.shadow.camera.bottom = -10;
    sunLight.shadow.bias = -0.0001;
    sunScene.add(sunLight);
    
    // Lens flare effect avec des cercles
    const flareGroup = new THREE.Group();
    const flareSizes = [0.8, 0.4, 0.2, 0.6, 0.3];
    const flareColors = [0xffffaa, 0xff8844, 0xffaa66, 0xffff88, 0xffcc44];
    const flarePositions = [0.2, 0.4, 0.6, 0.8, 1.0];
    
    flareSizes.forEach((size, i) => {
      const flareGeom = new THREE.RingGeometry(size * 0.8, size, 32);
      const flareMat = new THREE.MeshBasicMaterial({
        color: flareColors[i],
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      const flare = new THREE.Mesh(flareGeom, flareMat);
      flare.position.lerpVectors(sun.position, new THREE.Vector3(0, 0, 6), flarePositions[i]);
      flare.lookAt(sunCamera.position);
      flareGroup.add(flare);
    });
    sunScene.add(flareGroup);
    
    // Particules solaires
    const particleCount = 200;
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSpeeds = [];
    
    for(let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const r = 1.5 + Math.random() * 0.5;
      particlePositions[i * 3] = sun.position.x + r * Math.sin(phi) * Math.cos(theta);
      particlePositions[i * 3 + 1] = sun.position.y + r * Math.sin(phi) * Math.sin(theta);
      particlePositions[i * 3 + 2] = sun.position.z + r * Math.cos(phi);
      particleSpeeds.push({ theta, phi, speed: 0.5 + Math.random() * 1.5, r });
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    
    const particleMat = new THREE.PointsMaterial({
      color: 0xffaa44,
      size: 0.15,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particleGeom, particleMat);
    sunScene.add(particles);
    
    sunCamera.position.z = 6;
    
    // Animation
    function animateSun() {
      requestAnimationFrame(animateSun);
      
      const time = Date.now() * 0.001;
      
      // Pulse du soleil
      const pulse = Math.sin(time * 2) * 0.05 + 1;
      sun.scale.set(pulse, pulse, pulse);
      
      // Animation de la couronne
      coronaMat.uniforms.time.value = time;
      corona.scale.set(pulse * 1.1, pulse * 1.1, pulse * 1.1);
      
      // Animation des rayons
      rays.forEach((ray, i) => {
        ray.rotation.z = ray.userData.baseRotZ + Math.sin(time * 2 + ray.userData.offset) * 0.1;
        ray.scale.y = 0.8 + Math.sin(time * 3 + ray.userData.offset) * 0.2;
        ray.material.opacity = 0.1 + Math.sin(time * 2 + ray.userData.offset) * 0.05;
      });
      
      // Animation des particules
      const positions = particles.geometry.attributes.position.array;
      for(let i = 0; i < particleCount; i++) {
        const s = particleSpeeds[i];
        s.r += s.speed * 0.02;
        if(s.r > 4) s.r = 1.5;
        positions[i * 3] = sun.position.x + s.r * Math.sin(s.phi) * Math.cos(s.theta + time * 0.5);
        positions[i * 3 + 1] = sun.position.y + s.r * Math.sin(s.phi) * Math.sin(s.theta + time * 0.5);
        positions[i * 3 + 2] = sun.position.z + s.r * Math.cos(s.phi);
      }
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Flares suivent la cam√©ra
      flareGroup.children.forEach(flare => flare.lookAt(sunCamera.position));
      
      sunRenderer.render(sunScene, sunCamera);
    }
    animateSun();
    
    window.addEventListener('resize', () => {
      sunCamera.aspect = window.innerWidth / window.innerHeight;
      sunCamera.updateProjectionMatrix();
      sunRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  }, 500);
})();
  </script>
<script>
   (function(){const audio=document.getElementById('bg-music');const overlay=document.getElementById('autoplay-overlay');audio.play().then(()=>{overlay.style.display='none';}).catch(()=>{});document.addEventListener('click',function firstClick(){audio.play().catch(()=>{});},{once:true});})();
  </script>
</body>
</html>
