<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch Versus Code</title>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            flex-direction: column;
        }
        h1 { font-size: 3rem; text-align: center; }
        
        .planet-container {
          position: relative;
          width: 300px;
          height: 300px;
          margin-top: 50px;
        }
        
        .orbit-ring {
          position: absolute;
          width: 280px;
          height: 280px;
          border: 2px dashed rgba(255, 255, 255, 0.2);
          border-radius: 50%;
          top: 10px;
          left: 10px;
          animation: rotate 30s linear infinite;
        }
        
        .planet {
          position: absolute;
          width: 200px;
          height: 200px;
          top: 50px;
          left: 50px;
          border-radius: 50%;
          background: linear-gradient(135deg, #4a5899 0%, #2d3561 50%, #1a1f3a 100%);
          box-shadow: 
            inset -30px -30px 50px rgba(0, 0, 0, 0.5),
            inset 20px 20px 40px rgba(255, 255, 255, 0.1),
            0 0 60px rgba(74, 88, 153, 0.4);
          animation: float 6s ease-in-out infinite;
          overflow: hidden;
        }
        
        .planet-surface {
          position: absolute;
          width: 100%;
          height: 100%;
          border-radius: 50%;
          background: 
            radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2) 0%, transparent 50%),
            radial-gradient(circle at 70% 60%, rgba(100, 120, 180, 0.3) 0%, transparent 40%);
          animation: surfaceRotate 20s linear infinite;
        }
        
        .planet-glow {
          position: absolute;
          width: 220px;
          height: 220px;
          top: -10px;
          left: -10px;
          border-radius: 50%;
          background: radial-gradient(circle, rgba(138, 153, 230, 0.3) 0%, transparent 70%);
          animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes rotate {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes float {
          0%, 100% { transform: translateY(0px); }
          50% { transform: translateY(-20px); }
        }
        
        @keyframes surfaceRotate {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 0.6; }
          50% { opacity: 1; }
        }
    </style>
</head>
<body>
<h1 style="position: relative; z-index: 10;">Solar System</h1><style>
@keyframes orbitDog {
  from { transform: rotate(0deg) translateX(150px) rotate(0deg); }
  to { transform: rotate(360deg) translateX(150px) rotate(-360deg); }
}
.dog {
  animation: floatDog 2s ease-in-out infinite;
}
@keyframes floatDog {
  0%, 100% { transform: translateX(-50%) translateY(0px) scale(1) scaleX(-1); }
  50% { transform: translateX(-50%) translateY(-6px) scale(1.05) scaleX(-1); }
}
</style><style>
@keyframes orbitKitty {
  from { transform: rotate(0deg) translateX(150px) rotate(0deg); }
  to { transform: rotate(360deg) translateX(150px) rotate(-360deg); }
}
.kitty {
  animation: floatKitty 3s ease-in-out infinite;
}
@keyframes floatKitty {
  0%, 100% { transform: translateX(-50%) translateY(0px) scale(1); }
  50% { transform: translateX(-50%) translateY(-8px) scale(1.1); }
}
</style><audio autoplay="" loop="">
<source src="https://cdn.pixabay.com/audio/2022/03/10/audio_2c87ba15c0.mp3" type="audio/mpeg"/>
</audio>
<div style="position: fixed; bottom: 20px; right: 20px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 15px; backdrop-filter: blur(10px); display: flex; align-items: center; gap: 10px;">
<span style="font-size: 0.9rem;">üéµ Space Ambience</span>
<button onclick="toggleAudio()" style="background: rgba(74, 88, 153, 0.8); border: none; color: white; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">Pause</button>
</div><div style="position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; backdrop-filter: blur(10px); text-align: center; min-width: 150px;">
<div style="font-size: 0.8rem; opacity: 0.8; margin-bottom: 5px;">CHASE SCORE</div>
<div style="font-size: 2.5rem; font-weight: bold; color: #fdb813;">üêï <span id="dogScore">0</span></div>
<div style="font-size: 0.7rem; opacity: 0.6; margin-top: 5px;">catches</div>
</div>
<script>
function toggleAudio() {
  const audio = document.querySelector('[data-llm-id="e7"]');
  const button = document.querySelector('[data-llm-id="e9"]');
  if (audio.paused) {
    audio.play();
    button.textContent = 'Pause';
  } else {
    audio.pause();
    button.textContent = 'Play';
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<div id="sun-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none;"></div>
<script>
// Three.js Sun Scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('sun-canvas').appendChild(renderer.domElement);

// Sun creation
const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
const sunMaterial = new THREE.MeshBasicMaterial({
  color: 0xfdb813,
  emissive: 0xfdb813,
  emissiveIntensity: 1
});
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
sun.position.set(-8, 5, -10);
scene.add(sun);

// Sun glow/corona
const glowGeometry = new THREE.SphereGeometry(3.5, 64, 64);
const glowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    glowColor: { value: new THREE.Color(0xffaa00) },
    viewVector: { value: camera.position }
  },
  vertexShader: `
    uniform vec3 viewVector;
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      vec3 vNormel = normalize(normalMatrix * viewVector);
      intensity = pow(0.7 - dot(vNormal, vNormel), 3.0);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      vec3 glow = glowColor * intensity;
      gl_FragColor = vec4(glow, intensity * 0.8);
    }
  `,
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
sunGlow.position.copy(sun.position);
scene.add(sunGlow);

// Intense sun light
const sunLight = new THREE.PointLight(0xffffff, 2, 100);
sunLight.position.copy(sun.position);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
scene.add(sunLight);

// Ambient warm light
const ambientLight = new THREE.AmbientLight(0x332211, 0.3);
scene.add(ambientLight);

// Planet sphere to receive shadows
const planetGeometry = new THREE.SphereGeometry(2, 32, 32);
const planetMaterial = new THREE.MeshStandardMaterial({
  color: 0x4a5899,
  roughness: 0.7,
  metalness: 0.2
});
const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
planetMesh.position.set(0, -2, -5);
planetMesh.receiveShadow = true;
planetMesh.castShadow = true;
scene.add(planetMesh);

// Corona particles
const particlesGeometry = new THREE.BufferGeometry();
const particlesCount = 2000;
const posArray = new Float32Array(particlesCount * 3);
for(let i = 0; i < particlesCount * 3; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 3.5 + Math.random() * 2;
  const height = (Math.random() - 0.5) * 1;
  posArray[i * 3] = sun.position.x + Math.cos(angle) * radius;
  posArray[i * 3 + 1] = sun.position.y + height;
  posArray[i * 3 + 2] = sun.position.z + Math.sin(angle) * radius;
}
particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
const particlesMaterial = new THREE.PointsMaterial({
  size: 0.05,
  color: 0xffaa00,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending
});
const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
scene.add(particlesMesh);

camera.position.z = 5;

let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Rotate sun
  sun.rotation.y += 0.002;
  sunGlow.rotation.y += 0.002;
  
  // Pulsating sun
  const pulse = Math.sin(time * 2) * 0.1 + 1;
  sun.scale.set(pulse, pulse, pulse);
  sunLight.intensity = 2 + Math.sin(time * 2) * 0.3;
  
  // Rotate planet
  planetMesh.rotation.y += 0.005;
  
  // Rotate corona particles
  particlesMesh.rotation.y += 0.001;
  
  renderer.render(scene, camera);
}
animate();

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script><div class="planet-container" style="position: relative; z-index: 5;">
<div class="orbit-ring"></div>
<div class="planet" id="mainPlanet" style="box-shadow: inset -30px -30px 50px rgba(0, 0, 0, 0.5), inset 20px 20px 40px rgba(255, 255, 255, 0.1), 0 0 60px rgba(74, 88, 153, 0.4), -50px -30px 80px rgba(253, 184, 19, 0.3); transition: background 0.3s ease, box-shadow 0.3s ease;">
<div class="planet-surface"></div>
<div class="planet-glow"></div>
</div>
<div class="kitty-orbit" style="position: absolute; width: 100%; height: 100%; animation: orbitKitty 15s linear infinite;">
<div class="kitty" style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%); font-size: 3rem; filter: drop-shadow(0 0 10px rgba(255, 200, 150, 0.6));" title="Space Kitty!">üê±</div>
</div><div class="dog-orbit" style="position: absolute; width: 100%; height: 100%; animation: orbitDog 10s linear infinite;">
<div class="dog" style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%) scaleX(-1); font-size: 2.5rem; filter: drop-shadow(0 0 10px rgba(255, 150, 100, 0.6));" title="Space Dog Chaser!">üêï</div>
</div><script>
// Enhanced chase logic with scoring
const kittyOrbitEl = document.querySelector('[data-llm-id="e12"]');
const dogOrbitEl = document.querySelector('[data-llm-id="e14"]');
const kittyEl = document.querySelector('[data-llm-id="e13"]');
const dogEl = document.querySelector('[data-llm-id="e15"]');
const scoreDisplay = document.getElementById('dogScore');

let kittySpeedVal = 15;
let dogSpeedVal = 10;
let isEscapingNow = false;
let dogScore = 0;
let lastCatchTime = 0;

function updateOrbitAnimations() {
  kittyOrbitEl.style.animation = `orbitKitty ${kittySpeedVal}s linear infinite`;
  dogOrbitEl.style.animation = `orbitDog ${dogSpeedVal}s linear infinite`;
}

function getAngle(element) {
  const style = window.getComputedStyle(element);
  const matrix = style.transform;
  if (matrix === 'none') return 0;
  const values = matrix.split('(')[1].split(')')[0].split(',');
  const a = values[0];
  const b = values[1];
  return Math.atan2(b, a) * (180 / Math.PI);
}

function celebrateCatch() {
  // Visual celebration
  const scoreEl = document.getElementById('dogScore');
  scoreEl.style.transform = 'scale(1.5)';
  scoreEl.style.color = '#ff6b6b';
  setTimeout(() => {
    scoreEl.style.transform = 'scale(1)';
    scoreEl.style.color = '#fdb813';
  }, 300);
  
  // Dog celebrates
  dogEl.textContent = 'üéâ';
  setTimeout(() => {
    dogEl.textContent = 'üêï';
  }, 1000);
}

function checkProximity() {
  const now = Date.now();
  
  // Prevent multiple catches within 5 seconds
  if (now - lastCatchTime < 5000) return;
  
  const kittyAngleVal = getAngle(kittyOrbitEl);
  const dogAngleVal = getAngle(dogOrbitEl);
  
  const normKitty = ((kittyAngleVal % 360) + 360) % 360;
  const normDog = ((dogAngleVal % 360) + 360) % 360;
  
  let dist = Math.abs(normDog - normKitty);
  if (dist > 180) dist = 360 - dist;
  
  const dogIsBehind = (normDog < normKitty && normKitty - normDog < 180) || 
                      (normDog > normKitty && normDog - normKitty > 180);
  
  // CATCH! Dog is very close (within 25 degrees)
  if (dist < 25 && dogIsBehind && !isEscapingNow) {
    dogScore++;
    scoreDisplay.textContent = dogScore;
    lastCatchTime = now;
    celebrateCatch();
    
    // Cat escapes in panic
    isEscapingNow = true;
    kittySpeedVal = 4;
    updateOrbitAnimations();
    kittyEl.style.filter = 'drop-shadow(0 0 20px rgba(255, 100, 100, 0.9))';
    kittyEl.textContent = 'üòæ';
    
    setTimeout(() => {
      isEscapingNow = false;
      kittySpeedVal = 15;
      updateOrbitAnimations();
      kittyEl.style.filter = 'drop-shadow(0 0 10px rgba(255, 200, 150, 0.6))';
      kittyEl.textContent = 'üê±';
    }, 3000);
  }
  // Near miss - cat gets nervous
  else if (dist < 40 && dogIsBehind && !isEscapingNow) {
    kittyEl.textContent = 'üòø';
    setTimeout(() => {
      if (!isEscapingNow) kittyEl.textContent = 'üê±';
    }, 500);
  }
}

setInterval(checkProximity, 100);
updateOrbitAnimations();
</script>
<script>
// Chase logic
const kittyOrbit = document.querySelector('[data-llm-id="e12"]');
const dogOrbit = document.querySelector('[data-llm-id="e14"]');
const kitty = document.querySelector('[data-llm-id="e13"]');
const dog = document.querySelector('[data-llm-id="e15"]');

let kittySpeed = 15; // seconds per orbit
let dogSpeed = 10; // seconds per orbit (faster)
let isEscaping = false;

function updateAnimations() {
  kittyOrbit.style.animation = `orbitKitty ${kittySpeed}s linear infinite`;
  dogOrbit.style.animation = `orbitDog ${dogSpeed}s linear infinite`;
}

function getRotationAngle(element) {
  const style = window.getComputedStyle(element);
  const matrix = style.transform;
  if (matrix === 'none') return 0;
  const values = matrix.split('(')[1].split(')')[0].split(',');
  const a = values[0];
  const b = values[1];
  return Math.atan2(b, a) * (180 / Math.PI);
}

function checkDistance() {
  const kittyAngle = getRotationAngle(kittyOrbit);
  const dogAngle = getRotationAngle(dogOrbit);
  
  // Normalize angles to 0-360
  const normalizedKitty = ((kittyAngle % 360) + 360) % 360;
  const normalizedDog = ((dogAngle % 360) + 360) % 360;
  
  // Calculate angular distance
  let distance = Math.abs(normalizedDog - normalizedKitty);
  if (distance > 180) distance = 360 - distance;
  
  // If dog is within 40 degrees behind the cat
  const dogBehindCat = (normalizedDog < normalizedKitty && normalizedKitty - normalizedDog < 180) || 
                       (normalizedDog > normalizedKitty && normalizedDog - normalizedKitty > 180);
  
  if (distance < 40 && dogBehindCat && !isEscaping) {
    // Cat escapes!
    isEscaping = true;
    kittySpeed = 4; // Super fast!
    updateAnimations();
    kitty.style.filter = 'drop-shadow(0 0 20px rgba(255, 100, 100, 0.9))';
    kitty.textContent = 'üòæ';
    
    // Return to normal after 3 seconds
    setTimeout(() => {
      isEscaping = false;
      kittySpeed = 15;
      updateAnimations();
      kitty.style.filter = 'drop-shadow(0 0 10px rgba(255, 200, 150, 0.6))';
      kitty.textContent = 'üê±';
    }, 3000);
  }
}

// Check distance every 100ms
setInterval(checkDistance, 100);
updateAnimations();
</script></div><div id="game-container" style="position: relative; z-index: 10; margin-top: 50px; width: 600px; height: 400px; border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 20px; overflow: hidden; box-shadow: 0 0 40px rgba(138, 153, 230, 0.5);"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script><script>
let ship;
let asteroids = [];
let stars = [];
let score = 0;
let gameState = 'start';
let gameSpeed = 2;
let starPowerUp = null;
let invincible = false;
let invincibleTimer = 0;

function setup() {
  let canvas = createCanvas(600, 400);
  canvas.parent('game-container');
  ship = new Ship();
}

function draw() {
  background(10, 15, 35);
  
  // Draw starfield background
  if (frameCount % 3 === 0) {
    stars.push({x: width, y: random(height), speed: random(1, 3), size: random(1, 3)});
  }
  for (let i = stars.length - 1; i >= 0; i--) {
    fill(255, 255, 255, 200);
    noStroke();
    circle(stars[i].x, stars[i].y, stars[i].size);
    stars[i].x -= stars[i].speed;
    if (stars[i].x < 0) stars.splice(i, 1);
  }
  
  if (gameState === 'start') {
    textAlign(CENTER, CENTER);
    fill(255);
    textSize(48);
    text('üöÄ ASTEROID DODGER', width/2, height/2 - 60);
    textSize(20);
    text('Use ARROW KEYS to move', width/2, height/2);
    text('Collect ‚≠ê for invincibility!', width/2, height/2 + 30);
    textSize(24);
    fill(253, 184, 19);
    text('Press SPACE to start', width/2, height/2 + 80);
    
  } else if (gameState === 'playing') {
    // Spawn asteroids
    if (frameCount % 40 === 0) {
      asteroids.push(new Asteroid());
    }
    
    // Spawn star power-up occasionally
    if (frameCount % 300 === 0 && !starPowerUp) {
      starPowerUp = {x: width, y: random(50, height - 50), size: 25};
    }
    
    // Update and draw ship
    ship.update();
    ship.display();
    
    // Update and draw asteroids
    for (let i = asteroids.length - 1; i >= 0; i--) {
      asteroids[i].update();
      asteroids[i].display();
      
      if (!invincible && asteroids[i].hits(ship)) {
        gameState = 'gameover';
      }
      
      if (asteroids[i].offscreen()) {
        asteroids.splice(i, 1);
        score += 10;
        gameSpeed += 0.01;
      }
    }
    
    // Star power-up
    if (starPowerUp) {
      starPowerUp.x -= gameSpeed + 1;
      
      // Animated star
      push();
      translate(starPowerUp.x, starPowerUp.y);
      rotate(frameCount * 0.05);
      textSize(starPowerUp.size);
      text('‚≠ê', 0, 0);
      pop();
      
      // Check collection
      if (dist(ship.x, ship.y, starPowerUp.x, starPowerUp.y) < 30) {
        invincible = true;
        invincibleTimer = 180; // 3 seconds at 60fps
        starPowerUp = null;
        score += 50;
      }
      
      if (starPowerUp && starPowerUp.x < -50) {
        starPowerUp = null;
      }
    }
    
    // Handle invincibility
    if (invincible) {
      invincibleTimer--;
      if (invincibleTimer <= 0) {
        invincible = false;
      }
    }
    
    // Score display
    fill(255);
    textSize(24);
    textAlign(LEFT);
    text('Score: ' + score, 20, 30);
    
    // Invincibility indicator
    if (invincible) {
      fill(253, 184, 19);
      textSize(18);
      text('‚≠ê INVINCIBLE! ' + Math.ceil(invincibleTimer/60) + 's', 20, 60);
    }
    
  } else if (gameState === 'gameover') {
    textAlign(CENTER, CENTER);
    fill(255, 100, 100);
    textSize(48);
    text('GAME OVER!', width/2, height/2 - 40);
    fill(255);
    textSize(32);
    text('Final Score: ' + score, width/2, height/2 + 20);
    textSize(20);
    fill(253, 184, 19);
    text('Press SPACE to restart', width/2, height/2 + 70);
  }
}

function keyPressed() {
  if (key === ' ') {
    if (gameState === 'start' || gameState === 'gameover') {
      gameState = 'playing';
      asteroids = [];
      stars = [];
      score = 0;
      gameSpeed = 2;
      ship = new Ship();
      starPowerUp = null;
      invincible = false;
      invincibleTimer = 0;
    }
  }
}

class Ship {
  constructor() {
    this.x = 100;
    this.y = height / 2;
    this.size = 30;
    this.speed = 5;
  }
  
  update() {
    if (keyIsDown(UP_ARROW) && this.y > this.size) {
      this.y -= this.speed;
    }
    if (keyIsDown(DOWN_ARROW) && this.y < height - this.size) {
      this.y += this.speed;
    }
    if (keyIsDown(LEFT_ARROW) && this.x > this.size) {
      this.x -= this.speed;
    }
    if (keyIsDown(RIGHT_ARROW) && this.x < 200) {
      this.x += this.speed;
    }
  }
  
  display() {
    push();
    translate(this.x, this.y);
    
    if (invincible) {
      // Rainbow glow when invincible
      let hue = (frameCount * 5) % 360;
      drawingContext.shadowBlur = 20;
      drawingContext.shadowColor = `hsl(${hue}, 100%, 50%)`;
    }
    
    textSize(this.size);
    textAlign(CENTER, CENTER);
    text('üöÄ', 0, 0);
    
    // Engine flame
    if (frameCount % 2 === 0) {
      textSize(15);
      text('üí®', -20, 0);
    }
    
    pop();
  }
}

class Asteroid {
  constructor() {
    this.x = width;
    this.y = random(30, height - 30);
    this.size = random(30, 60);
    this.rotation = random(TWO_PI);
    this.rotSpeed = random(-0.05, 0.05);
    this.emoji = random(['‚òÑÔ∏è', 'üåë', 'ü™®']);
  }
  
  update() {
    this.x -= gameSpeed;
    this.rotation += this.rotSpeed;
  }
  
  display() {
    push();
    translate(this.x, this.y);
    rotate(this.rotation);
    textSize(this.size);
    textAlign(CENTER, CENTER);
    text(this.emoji, 0, 0);
    pop();
  }
  
  hits(ship) {
    let d = dist(this.x, this.y, ship.x, ship.y);
    return d < (this.size/2 + ship.size/2 - 10);
  }
  
  offscreen() {
    return this.x < -this.size;
  }
}
</script>
</body>
</html>