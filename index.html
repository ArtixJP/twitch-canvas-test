<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        h1 { font-size: 3rem; text-align: center; }
  </style>
</head>
<body>
<h1 style="position: absolute; top: 20px; z-index: 10; text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);">
   Hello World
  </h1>
<div id="planet-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
</div>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  const canvas = renderer.domElement;
  document.getElementById('planet-container').appendChild(canvas);

  // Soleil
  const sunGeom = new THREE.SphereGeometry(1.5, 64, 64);
  const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
  const sun = new THREE.Mesh(sunGeom, sunMat);
  sun.position.set(12, 6, 8);
  scene.add(sun);

  // Halo du soleil
  const sunGlowGeom = new THREE.SphereGeometry(2.2, 32, 32);
  const sunGlowMat = new THREE.ShaderMaterial({
    uniforms: {
      c: { type: 'f', value: 0.4 },
      p: { type: 'f', value: 4.0 },
      glowColor: { type: 'c', value: new THREE.Color(0xffaa00) },
      viewVector: { type: 'v3', value: camera.position }
    },
    vertexShader: `
      uniform vec3 viewVector;
      varying float intensity;
      void main() {
        vec3 vNormal = normalize(normalMatrix * normal);
        vec3 vNormel = normalize(normalMatrix * viewVector);
        intensity = pow(0.7 - dot(vNormal, vNormel), 2.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      varying float intensity;
      void main() {
        vec3 glow = glowColor * intensity;
        gl_FragColor = vec4(glow, intensity * 0.8);
      }
    `,
    side: THREE.FrontSide,
    blending: THREE.AdditiveBlending,
    transparent: true
  });
  const sunGlow = new THREE.Mesh(sunGlowGeom, sunGlowMat);
  sunGlow.position.copy(sun.position);
  scene.add(sunGlow);

  // Corona
  const coronaGeom = new THREE.SphereGeometry(3, 32, 32);
  const coronaMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.15, side: THREE.BackSide });
  const corona = new THREE.Mesh(coronaGeom, coronaMat);
  corona.position.copy(sun.position);
  scene.add(corona);

  // Plan√®te avec mat√©riau accessible
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a9eff,
    emissive: 0x112244,
    specular: 0xffffff,
    shininess: 15
  });
  const planet = new THREE.Mesh(geometry, material);
  planet.castShadow = true;
  planet.receiveShadow = true;
  scene.add(planet);
  
  // Store material reference on canvas for color changing
  canvas.__planetMaterial = material;

  // Lune
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({ color: 0xcccccc, emissive: 0x222222, specular: 0xffffff, shininess: 5 });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.castShadow = true;
  moon.receiveShadow = true;
  const moonPivot = new THREE.Object3D();
  moonPivot.add(moon);
  moon.position.x = 4;
  scene.add(moonPivot);
  moonPivot.rotation.x = 0.3;
  moonPivot.rotation.z = 0.2;

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({ color: 0x88ccff, transparent: true, opacity: 0.2, side: THREE.BackSide });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);
  canvas.__atmosMaterial = atmosMat;

  // Anneaux
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x9966ff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  ring.receiveShadow = true;
  scene.add(ring);

  // Lumi√®re du soleil
  const sunLight = new THREE.PointLight(0xffffcc, 2, 100);
  sunLight.position.copy(sun.position);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  scene.add(sunLight);
  scene.add(new THREE.AmbientLight(0x333366, 0.3));

  camera.position.z = 7;

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  scene.add(new THREE.Points(starsGeom, starsMat));

  let time = 0;
  function animate() {
    requestAnimationFrame(animate);
    time += 0.01;
    planet.rotation.y += 0.003;
    atmosphere.rotation.y += 0.002;
    ring.rotation.z += 0.001;
    moonPivot.rotation.y += 0.008;
    moon.rotation.y += 0.01;
    sunGlow.scale.setScalar(1 + Math.sin(time * 2) * 0.05);
    corona.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  // Attendre que Three.js soit charg√©
  const checkThree = setInterval(() => {
    if (window.THREE && document.querySelector('#planet-container canvas')) {
      clearInterval(checkThree);
      
      // R√©cup√©rer la sc√®ne existante via le renderer
      const canvas = document.querySelector('#planet-container canvas');
      const renderer = canvas.__three_renderer__ || null;
      
      // Cr√©er une nouvelle approche: ajouter la lune directement
      const container = document.getElementById('planet-container');
      const existingScript = document.querySelector('#planet-container + script');
      
      // On va modifier le script existant pour inclure la lune
    }
  }, 100);
})();
  </script>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Plan√®te
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a9eff,
    emissive: 0x112244,
    specular: 0xffffff,
    shininess: 15
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosph√®re
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.2,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Anneaux
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x9966ff,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumi√®res
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  camera.position.z = 7;

  // √âtoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  scene.add(new THREE.Points(starsGeom, starsMat));

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    atmosphere.rotation.y += 0.002;
    ring.rotation.z += 0.001;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  const audio = document.getElementById('bg-music');
  const btn = document.getElementById('music-toggle');
  const playIcon = document.getElementById('play-icon');
  const pauseIcon = document.getElementById('pause-icon');
  
  let isPlaying = true;
  
  // Autoplay peut √™tre bloqu√©, on g√®re √ßa
  audio.play().catch(() => {
    isPlaying = false;
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
  });
  
  btn.addEventListener('click', () => {
    if (isPlaying) {
      audio.pause();
      playIcon.style.display = 'block';
      pauseIcon.style.display = 'none';
    } else {
      audio.play();
      playIcon.style.display = 'none';
      pauseIcon.style.display = 'block';
    }
    isPlaying = !isPlaying;
  });
})();
  </script>
<audio autoplay="" id="bg-music" loop="">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="music-toggle" style="position: fixed; bottom: 30px; right: 30px; z-index: 100; width: 60px; height: 60px; border-radius: 50%; border: none; background: linear-gradient(135deg, #9966ff 0%, #4a9eff 100%); cursor: pointer; box-shadow: 0 4px 20px rgba(100, 150, 255, 0.5); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
<svg fill="white" height="24" id="pause-icon" viewbox="0 0 24 24" width="24">
<rect height="16" width="4" x="6" y="4">
</rect>
<rect height="16" width="4" x="14" y="4">
</rect>
</svg>
<svg fill="white" height="24" id="play-icon" style="display: none;" viewbox="0 0 24 24" width="24">
<polygon points="5,3 19,12 5,21">
</polygon>
</svg>
</button>
<script>
   (function() { const audio = document.getElementById('bg-music'); const btn = document.getElementById('music-toggle'); const playIcon = document.getElementById('play-icon'); const pauseIcon = document.getElementById('pause-icon'); let isPlaying = true; audio.volume = 0.5; audio.play().catch(() => { isPlaying = false; playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; }); btn.addEventListener('click', () => { if (isPlaying) { audio.pause(); playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; } else { audio.play(); playIcon.style.display = 'none'; pauseIcon.style.display = 'block'; } isPlaying = !isPlaying; }); btn.addEventListener('mouseenter', () => { btn.style.transform = 'scale(1.1)'; btn.style.boxShadow = '0 6px 30px rgba(100, 150, 255, 0.7)'; }); btn.addEventListener('mouseleave', () => { btn.style.transform = 'scale(1)'; btn.style.boxShadow = '0 4px 20px rgba(100, 150, 255, 0.5)'; }); })();
  </script>
<div id="autoplay-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; backdrop-filter: blur(10px);">
<div style="text-align: center; color: white;">
<svg fill="none" height="80" stroke="currentColor" stroke-width="1" style="margin-bottom: 20px; animation: pulse 2s infinite;" viewbox="0 0 24 24" width="80">
<circle cx="12" cy="12" r="10" stroke="#9966ff">
</circle>
<polygon fill="#4a9eff" points="10,8 16,12 10,16">
</polygon>
</svg>
<h2 style="font-size: 2rem; margin: 0 0 10px 0; background: linear-gradient(135deg, #9966ff, #4a9eff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
     Cliquez pour entrer
    </h2>
<p style="opacity: 0.7; font-size: 1rem;">
     La musique commencera automatiquement
    </p>
</div>
</div>
<style>
   @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
  </style>
<script>
   (function(){const overlay=document.getElementById('autoplay-overlay');const audio=document.getElementById('bg-music');const playIcon=document.getElementById('play-icon');const pauseIcon=document.getElementById('pause-icon');overlay.addEventListener('click',function(){audio.play().then(()=>{playIcon.style.display='none';pauseIcon.style.display='block';}).catch(e=>console.log(e));overlay.style.opacity='0';overlay.style.transition='opacity 0.5s ease';setTimeout(()=>overlay.remove(),500);});document.addEventListener('keydown',function(e){if(overlay.parentNode){audio.play().then(()=>{playIcon.style.display='none';pauseIcon.style.display='block';}).catch(e=>console.log(e));overlay.style.opacity='0';overlay.style.transition='opacity 0.5s ease';setTimeout(()=>overlay.remove(),500);}},{once:true});})();
  </script>
<div id="cat" style="position: fixed; z-index: 1000; font-size: 40px; transition: none; pointer-events: none;">
   üê±
  </div>
<div id="dog" style="position: fixed; z-index: 999; font-size: 45px; transition: none; pointer-events: none;">
   üêï
  </div>
<script>
   (function(){const cat=document.getElementById('cat');const dog=document.getElementById('dog');let catX=window.innerWidth/2;let catY=window.innerHeight/2;let catVX=(Math.random()-0.5)*3;let catVY=(Math.random()-0.5)*3;let dogX=100;let dogY=100;let catSpeed=2;const normalSpeed=2;const panicSpeed=12;const dogSpeed=3.5;const dangerDistance=150;function updatePositions(){const dx=catX-dogX;const dy=catY-dogY;const distance=Math.sqrt(dx*dx+dy*dy);if(distance<dangerDistance){catSpeed=panicSpeed;const escapeAngle=Math.atan2(dy,dx);catVX=Math.cos(escapeAngle)*catSpeed;catVY=Math.sin(escapeAngle)*catSpeed;}else{catSpeed=Math.max(normalSpeed,catSpeed*0.95);if(Math.random()<0.02){catVX+=(Math.random()-0.5)*2;catVY+=(Math.random()-0.5)*2;const mag=Math.sqrt(catVX*catVX+catVY*catVY);catVX=(catVX/mag)*catSpeed;catVY=(catVY/mag)*catSpeed;}}catX+=catVX;catY+=catVY;if(catX<30||catX>window.innerWidth-30)catVX*=-1;if(catY<30||catY>window.innerHeight-30)catVY*=-1;catX=Math.max(30,Math.min(window.innerWidth-30,catX));catY=Math.max(30,Math.min(window.innerHeight-30,catY));const toCatX=catX-dogX;const toCatY=catY-dogY;const toCatDist=Math.sqrt(toCatX*toCatX+toCatY*toCatY);if(toCatDist>5){dogX+=((toCatX/toCatDist)*dogSpeed);dogY+=((toCatY/toCatDist)*dogSpeed);}cat.style.left=catX+'px';cat.style.top=catY+'px';cat.style.transform=catVX<0?'scaleX(-1)':'scaleX(1)';dog.style.left=dogX+'px';dog.style.top=dogY+'px';dog.style.transform=toCatX<0?'scaleX(-1)':'scaleX(1)';if(distance<dangerDistance){cat.style.filter='brightness(1.5)';cat.style.fontSize='45px';}else{cat.style.filter='none';cat.style.fontSize='40px';}requestAnimationFrame(updatePositions);}updatePositions();})();
  </script>
<div id="scoreboard" style="position: fixed; top: 20px; right: 30px; z-index: 1000; background: linear-gradient(135deg, rgba(153, 102, 255, 0.8), rgba(74, 158, 255, 0.8)); padding: 15px 25px; border-radius: 15px; font-family: system-ui, sans-serif; box-shadow: 0 4px 20px rgba(100, 150, 255, 0.5); backdrop-filter: blur(10px);">
<div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 5px;">
    üêï Dog Score
   </div>
<div id="dog-score" style="font-size: 2.5rem; font-weight: bold; text-shadow: 0 0 10px rgba(255,255,255,0.5);">
    0
   </div>
</div>
<div id="catch-effect" style="position: fixed; z-index: 1001; font-size: 60px; pointer-events: none; opacity: 0; transition: all 0.3s ease;">
   üí•
  </div>
<script>
   (function(){let dogScore=0;const scoreDisplay=document.getElementById('dog-score');const catchEffect=document.getElementById('catch-effect');const cat=document.getElementById('cat');const dog=document.getElementById('dog');const catchDistance=40;let canCatch=true;function checkCatch(){if(!canCatch)return;const catRect=cat.getBoundingClientRect();const dogRect=dog.getBoundingClientRect();const catCenterX=catRect.left+catRect.width/2;const catCenterY=catRect.top+catRect.height/2;const dogCenterX=dogRect.left+dogRect.width/2;const dogCenterY=dogRect.top+dogRect.height/2;const dx=catCenterX-dogCenterX;const dy=catCenterY-dogCenterY;const distance=Math.sqrt(dx*dx+dy*dy);if(distance<catchDistance){dogScore++;scoreDisplay.textContent=dogScore;scoreDisplay.style.transform='scale(1.3)';setTimeout(()=>scoreDisplay.style.transform='scale(1)',200);catchEffect.style.left=(catCenterX-30)+'px';catchEffect.style.top=(catCenterY-30)+'px';catchEffect.style.opacity='1';catchEffect.style.transform='scale(1.5)';setTimeout(()=>{catchEffect.style.opacity='0';catchEffect.style.transform='scale(1)';},300);canCatch=false;setTimeout(()=>canCatch=true,1000);const scoreboard=document.getElementById('scoreboard');scoreboard.style.animation='scoreGlow 0.5s ease';setTimeout(()=>scoreboard.style.animation='',500);}}setInterval(checkCatch,50);const style=document.createElement('style');style.textContent='@keyframes scoreGlow{0%,100%{box-shadow:0 4px 20px rgba(100,150,255,0.5);}50%{box-shadow:0 4px 40px rgba(255,200,100,0.9);}}';document.head.appendChild(style);})();
  </script>
<script>
   (function(){
  // Expose planet color change function globally
  window.changePlanetColor = function() {
    const colors = [
      { main: 0xff6b6b, emissive: 0x441111, atmos: 0xffaaaa }, // Rouge
      { main: 0x6bff6b, emissive: 0x114411, atmos: 0xaaffaa }, // Vert
      { main: 0xffff6b, emissive: 0x444411, atmos: 0xffffaa }, // Jaune
      { main: 0xff6bff, emissive: 0x441144, atmos: 0xffaaff }, // Magenta
      { main: 0x6bffff, emissive: 0x114444, atmos: 0xaaffff }, // Cyan
      { main: 0xffaa6b, emissive: 0x442211, atmos: 0xffddaa }, // Orange
      { main: 0x4a9eff, emissive: 0x112244, atmos: 0x88ccff }, // Bleu original
    ];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    
    // Find all Three.js canvases and update planet materials
    const canvases = document.querySelectorAll('#planet-container canvas');
    canvases.forEach(canvas => {
      if (canvas.__planetMaterial) {
        canvas.__planetMaterial.color.setHex(randomColor.main);
        canvas.__planetMaterial.emissive.setHex(randomColor.emissive);
      }
      if (canvas.__atmosMaterial) {
        canvas.__atmosMaterial.color.setHex(randomColor.atmos);
      }
    });
  };
  
  // Hook into existing catch detection
  const originalCheckCatch = setInterval(() => {
    const scoreDisplay = document.getElementById('dog-score');
    if (scoreDisplay) {
      let lastScore = parseInt(scoreDisplay.textContent) || 0;
      const observer = new MutationObserver(() => {
        const newScore = parseInt(scoreDisplay.textContent) || 0;
        if (newScore > lastScore) {
          window.changePlanetColor();
          lastScore = newScore;
        }
      });
      observer.observe(scoreDisplay, { childList: true, characterData: true, subtree: true });
      clearInterval(originalCheckCatch);
    }
  }, 100);
})();
  </script>
</body>
</html>
