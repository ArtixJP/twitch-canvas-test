<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 3rem; text-align: center; margin-bottom: 2rem; }
        .planet-system {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .planet {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a90d9 0%, #1e5799 50%, #0d2f5c 100%);
            box-shadow: 
                inset -30px -30px 60px rgba(0,0,0,0.5),
                inset 10px 10px 40px rgba(255,255,255,0.2),
                0 0 60px rgba(74, 144, 217, 0.4);
            animation: float 4s ease-in-out infinite;
            position: relative;
            transition: background 0.5s ease, box-shadow 0.5s ease;
        }
        .planet.caught {
            animation: float 4s ease-in-out infinite, planetPulse 0.5s ease-out;
        }
        .planet::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 15%;
            width: 30%;
            height: 20%;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            filter: blur(5px);
        }
        .planet::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            width: 80%;
            height: 8%;
            background: rgba(30, 87, 153, 0.6);
            border-radius: 50%;
            transform: rotate(-5deg);
            transition: background 0.5s ease;
        }
        .moon-orbit {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            animation: orbit 6s linear infinite;
        }
        .moon {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e8e8e8 0%, #b8b8b8 50%, #888888 100%);
            box-shadow: 
                inset -8px -8px 16px rgba(0,0,0,0.4),
                inset 4px 4px 12px rgba(255,255,255,0.3),
                0 0 20px rgba(200, 200, 200, 0.3);
        }
        .moon::before {
            content: '';
            position: absolute;
            top: 25%;
            left: 20%;
            width: 8px;
            height: 8px;
            background: rgba(100,100,100,0.5);
            border-radius: 50%;
        }
        .moon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 55%;
            width: 12px;
            height: 12px;
            background: rgba(100,100,100,0.4);
            border-radius: 50%;
        }
        .kitty-orbit {
            position: absolute;
            width: 380px;
            height: 380px;
            border-radius: 50%;
        }
        .kitty {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            filter: drop-shadow(0 0 10px rgba(255, 182, 193, 0.6));
            animation: kitty-wiggle 0.5s ease-in-out infinite;
            transition: filter 0.3s;
        }
        .kitty.scared {
            filter: drop-shadow(0 0 20px rgba(255, 100, 100, 0.9));
        }
        .doggy-orbit {
            position: absolute;
            width: 380px;
            height: 380px;
            border-radius: 50%;
        }
        .doggy {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            filter: drop-shadow(0 0 10px rgba(255, 200, 100, 0.6));
            animation: doggy-bounce 0.3s ease-in-out infinite;
        }
        @keyframes doggy-bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }
        @keyframes orbit {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes orbit-reverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }
        @keyframes kitty-wiggle {
            0%, 100% { transform: translateX(-50%) rotate(-5deg); }
            50% { transform: translateX(-50%) rotate(5deg); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        @keyframes planetPulse {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-10px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
   #three-container canvas {
  position: fixed;
  top: 0;
  left: 0;
}
.planet-system, h1, #musicBtn {
  position: relative;
  z-index: 1;
}
   @keyframes catchPop {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    50% { transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(1); }
}
#dogScore {
    transition: transform 0.3s, color 0.3s;
    font-weight: bold;
}
   .elephant-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .elephant {
            font-size: 100px;
            animation: elephant-bounce 1s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(150, 150, 150, 0.5));
        }
        @keyframes elephant-bounce {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }
        .water-spray {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 150px;
            pointer-events: none;
        }
        .water-drop {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #87CEEB 0%, #4a90d9 100%);
            border-radius: 50%;
            animation: water-spray-anim 1.5s ease-out infinite;
            opacity: 0;
        }
        @keyframes water-spray-anim {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-120px) scale(1); }
        }
        .water-stream {
            position: absolute;
            bottom: 80px;
            left: 70%;
            width: 4px;
            height: 60px;
            background: linear-gradient(to top, transparent, #87CEEB, #4a90d9);
            border-radius: 2px;
            animation: stream-wave 0.5s ease-in-out infinite;
            transform-origin: bottom center;
        }
        @keyframes stream-wave {
            0%, 100% { transform: rotate(-15deg) scaleY(1); }
            50% { transform: rotate(15deg) scaleY(1.1); }
        }
  </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js">
</script>
</head>
<body>
<h1>
   Hello World
  </h1>
<div id="scoreBoard" style="font-size: 1.5rem; margin-bottom: 1rem; display: flex; gap: 2rem; background: rgba(255,255,255,0.1); padding: 15px 30px; border-radius: 15px; backdrop-filter: blur(10px);">
<span>
    üêï Dog:
    <span id="dogScore">
     0
    </span>
</span>
</div>
<div id="three-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;">
</div>
<div class="elephant-container">
<div class="water-spray" id="waterSpray">
</div>
<div class="water-stream">
</div>
<div class="elephant">
    üêò
   </div>
</div>
<script>
   // Create water drops
    const waterSpray = document.getElementById('waterSpray');
    function createWaterDrops() {
        for (let i = 0; i < 20; i++) {
            const drop = document.createElement('div');
            drop.className = 'water-drop';
            drop.style.left = (30 + Math.random() * 40) + '%';
            drop.style.animationDelay = (Math.random() * 1.5) + 's';
            drop.style.animationDuration = (1 + Math.random() * 0.5) + 's';
            waterSpray.appendChild(drop);
        }
    }
    createWaterDrops();
    
    // Continuous water splash effect
    setInterval(() => {
        const splash = document.createElement('div');
        splash.className = 'water-drop';
        splash.style.left = (35 + Math.random() * 30) + '%';
        splash.style.width = (6 + Math.random() * 6) + 'px';
        splash.style.height = splash.style.width;
        waterSpray.appendChild(splash);
        setTimeout(() => splash.remove(), 1500);
    }, 100);
  </script>
<div class="planet-system">
<div class="planet" id="planet">
</div>
<div class="moon-orbit">
<div class="moon">
</div>
</div>
<div class="kitty-orbit">
<div class="kitty">
     üê±
    </div>
</div>
<div class="doggy-orbit">
<div class="doggy">
     üêï
    </div>
</div>
</div>
<div class="stars" id="stars">
</div>
<script>
   const starsContainer = document.getElementById('stars');
    for(let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 2 + 's';
        star.style.width = Math.random() * 3 + 1 + 'px';
        star.style.height = star.style.width;
        starsContainer.appendChild(star);
    }
  </script>
<script>
   function toggleMusic() {
    const audio = document.getElementById('bgMusic');
    const icon = document.getElementById('musicIcon');
    const text = document.getElementById('musicText');
    if (audio.paused) {
      audio.play();
      icon.textContent = '‚è∏Ô∏è';
      text.textContent = 'Pause';
    } else {
      audio.pause();
      icon.textContent = '‚ñ∂Ô∏è';
      text.textContent = 'Play';
    }
  }
  
  // Try to play on load
  window.addEventListener('load', function() {
    const audio = document.getElementById('bgMusic');
    audio.volume = 0.5;
    audio.play().then(function() {
      document.getElementById('musicIcon').textContent = '‚è∏Ô∏è';
      document.getElementById('musicText').textContent = 'Pause';
    }).catch(function() {
      document.getElementById('musicIcon').textContent = '‚ñ∂Ô∏è';
      document.getElementById('musicText').textContent = 'Play';
      // Try to play on first user interaction
      document.addEventListener('click', function playOnInteraction() {
        audio.play().then(function() {
          document.getElementById('musicIcon').textContent = '‚è∏Ô∏è';
          document.getElementById('musicText').textContent = 'Pause';
        });
        document.removeEventListener('click', playOnInteraction);
      }, { once: true });
    });
  });
  </script>
<audio autoplay="" id="bgMusic" loop="">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="musicBtn" onclick="toggleMusic()" onmouseout="this.style.background='rgba(255,255,255,0.1)'" onmouseover="this.style.background='rgba(255,255,255,0.2)'" style="position: fixed; bottom: 20px; right: 20px; padding: 12px 20px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 25px; color: white; cursor: pointer; display: flex; align-items: center; gap: 8px; font-family: system-ui, sans-serif; backdrop-filter: blur(10px); transition: all 0.3s ease;">
<span id="musicIcon">
    ‚è∏Ô∏è
   </span>
<span id="musicText">
    Pause
   </span>
</button>
<script>
   // Three.js Sun with lighting effects
const container = document.getElementById('three-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

// Sun geometry
const sunGeometry = new THREE.SphereGeometry(2, 64, 64);
const sunMaterial = new THREE.MeshBasicMaterial({
  color: 0xffdd00,
});
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
sun.position.set(-8, 5, -5);
scene.add(sun);

// Sun glow effect
const glowGeometry = new THREE.SphereGeometry(2.5, 32, 32);
const glowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    c: { type: 'f', value: 0.5 },
    p: { type: 'f', value: 4.0 },
    glowColor: { type: 'c', value: new THREE.Color(0xffaa00) },
    viewVector: { type: 'v3', value: camera.position }
  },
  vertexShader: `
    uniform vec3 viewVector;
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      vec3 vNormel = normalize(normalMatrix * viewVector);
      intensity = pow(0.7 - dot(vNormal, vNormel), 2.0);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      vec3 glow = glowColor * intensity;
      gl_FragColor = vec4(glow, intensity * 0.8);
    }
  `,
  side: THREE.FrontSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
sunGlow.position.copy(sun.position);
scene.add(sunGlow);

// Outer glow
const outerGlowGeometry = new THREE.SphereGeometry(4, 32, 32);
const outerGlowMaterial = new THREE.ShaderMaterial({
  uniforms: {
    glowColor: { type: 'c', value: new THREE.Color(0xff6600) }
  },
  vertexShader: `
    varying float intensity;
    void main() {
      vec3 vNormal = normalize(normalMatrix * normal);
      intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 glowColor;
    varying float intensity;
    void main() {
      gl_FragColor = vec4(glowColor, intensity * 0.4);
    }
  `,
  side: THREE.BackSide,
  blending: THREE.AdditiveBlending,
  transparent: true
});
const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
outerGlow.position.copy(sun.position);
scene.add(outerGlow);

// Point light from sun
const sunLight = new THREE.PointLight(0xffdd88, 2, 100);
sunLight.position.copy(sun.position);
sunLight.castShadow = true;
scene.add(sunLight);

// Ambient light
const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
scene.add(ambientLight);

// Light rays particles
const rayCount = 200;
const rayGeometry = new THREE.BufferGeometry();
const rayPositions = new Float32Array(rayCount * 3);
const raySizes = new Float32Array(rayCount);
for(let i = 0; i < rayCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 2 + Math.random() * 6;
  rayPositions[i * 3] = sun.position.x + Math.cos(angle) * radius;
  rayPositions[i * 3 + 1] = sun.position.y + (Math.random() - 0.5) * 4;
  rayPositions[i * 3 + 2] = sun.position.z + Math.sin(angle) * radius;
  raySizes[i] = Math.random() * 0.1 + 0.05;
}
rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
rayGeometry.setAttribute('size', new THREE.BufferAttribute(raySizes, 1));
const rayMaterial = new THREE.PointsMaterial({
  color: 0xffcc44,
  size: 0.15,
  transparent: true,
  opacity: 0.6,
  blending: THREE.AdditiveBlending
});
const rays = new THREE.Points(rayGeometry, rayMaterial);
scene.add(rays);

camera.position.z = 15;

// Animation
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.01;
  
  // Pulsing sun
  const pulse = 1 + Math.sin(time * 2) * 0.05;
  sun.scale.set(pulse, pulse, pulse);
  sunGlow.scale.set(pulse * 1.2, pulse * 1.2, pulse * 1.2);
  
  // Rotate rays
  rays.rotation.x += 0.002;
  rays.rotation.y += 0.003;
  
  renderer.render(scene, camera);
}
animate();

// Handle resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
  </script>
<script>
   // Cat and Dog chase logic
const kittyOrbit = document.querySelector('.kitty-orbit');
const doggyOrbit = document.querySelector('.doggy-orbit');
const kitty = document.querySelector('.kitty');

let catAngle = 0;
let dogAngle = Math.PI; // Start opposite to cat
let catSpeed = 0.02; // Normal cat speed
let dogSpeed = 0.035; // Dog is faster
const normalCatSpeed = 0.02;
const scaredCatSpeed = 0.08; // Cat runs very fast when scared
const dangerDistance = 0.8; // Radians - how close before cat gets scared

function updateChase() {
    // Calculate angular distance between cat and dog
    let angleDiff = catAngle - dogAngle;
    // Normalize to -PI to PI
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    
    const distance = Math.abs(angleDiff);
    
    // If dog is close, cat gets scared and speeds up
    if (distance < dangerDistance) {
        catSpeed = scaredCatSpeed;
        kitty.classList.add('scared');
    } else {
        catSpeed = normalCatSpeed;
        kitty.classList.remove('scared');
    }
    
    // Cat moves (counter-clockwise)
    catAngle -= catSpeed;
    
    // Dog chases cat (moves toward cat's position)
    if (angleDiff > 0) {
        dogAngle += dogSpeed;
    } else {
        dogAngle -= dogSpeed;
    }
    
    // Keep angles in reasonable range
    if (catAngle < -Math.PI * 2) catAngle += Math.PI * 2;
    if (dogAngle > Math.PI * 2) dogAngle -= Math.PI * 2;
    if (dogAngle < -Math.PI * 2) dogAngle += Math.PI * 2;
    
    // Apply rotations
    kittyOrbit.style.transform = `rotate(${catAngle}rad)`;
    doggyOrbit.style.transform = `rotate(${dogAngle}rad)`;
    
    requestAnimationFrame(updateChase);
}

updateChase();
  </script>
<script>
   // Score system
let dogPoints = 0;
const dogScoreEl = document.getElementById('dogScore');
const catchDistance = 0.3; // Radians - how close to count as a catch
let catchCooldown = false;

function checkCatch() {
    if (catchCooldown) return;
    
    // Get current angles from the chase system
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const doggyOrbit = document.querySelector('.doggy-orbit');
    
    // Extract rotation values
    const catTransform = kittyOrbit.style.transform;
    const dogTransform = doggyOrbit.style.transform;
    
    const catMatch = catTransform.match(/rotate\(([\d.-]+)rad\)/);
    const dogMatch = dogTransform.match(/rotate\(([\d.-]+)rad\)/);
    
    if (catMatch && dogMatch) {
        const catAng = parseFloat(catMatch[1]);
        const dogAng = parseFloat(dogMatch[1]);
        
        let angleDiff = catAng - dogAng;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        const distance = Math.abs(angleDiff);
        
        if (distance < catchDistance) {
            // Dog caught the cat!
            dogPoints++;
            dogScoreEl.textContent = dogPoints;
            
            // Visual feedback
            dogScoreEl.style.transform = 'scale(1.5)';
            dogScoreEl.style.color = '#ffdd00';
            setTimeout(() => {
                dogScoreEl.style.transform = 'scale(1)';
                dogScoreEl.style.color = 'white';
            }, 300);
            
            // Show catch effect
            const catchEffect = document.createElement('div');
            catchEffect.textContent = '+1 üêï';
            catchEffect.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; color: #ffdd00; text-shadow: 0 0 20px #ff6600; animation: catchPop 1s ease-out forwards; z-index: 100;';
            document.body.appendChild(catchEffect);
            setTimeout(() => catchEffect.remove(), 1000);
            
            // Cooldown to prevent multiple catches
            catchCooldown = true;
            setTimeout(() => { catchCooldown = false; }, 2000);
        }
    }
    
    requestAnimationFrame(checkCatch);
}

checkCatch();
  </script>
<script>
   // Planet color change on catch
const planetColors = [
    { gradient: 'linear-gradient(135deg, #ff6b6b 0%, #c92a2a 50%, #5c0a0a 100%)', glow: 'rgba(255, 107, 107, 0.4)' },
    { gradient: 'linear-gradient(135deg, #51cf66 0%, #2f9e44 50%, #0d3d14 100%)', glow: 'rgba(81, 207, 102, 0.4)' },
    { gradient: 'linear-gradient(135deg, #ffd43b 0%, #fab005 50%, #5c4200 100%)', glow: 'rgba(255, 212, 59, 0.4)' },
    { gradient: 'linear-gradient(135deg, #cc5de8 0%, #9c36b5 50%, #3d0d4a 100%)', glow: 'rgba(204, 93, 232, 0.4)' },
    { gradient: 'linear-gradient(135deg, #ff922b 0%, #e8590c 50%, #5c2200 100%)', glow: 'rgba(255, 146, 43, 0.4)' },
    { gradient: 'linear-gradient(135deg, #22b8cf 0%, #1098ad 50%, #043d45 100%)', glow: 'rgba(34, 184, 207, 0.4)' },
    { gradient: 'linear-gradient(135deg, #f06595 0%, #d6336c 50%, #5c0d2a 100%)', glow: 'rgba(240, 101, 149, 0.4)' }
];
const originalColor = { gradient: 'linear-gradient(135deg, #4a90d9 0%, #1e5799 50%, #0d2f5c 100%)', glow: 'rgba(74, 144, 217, 0.4)' };

function changePlanetColor() {
    const planet = document.getElementById('planet');
    if (!planet) return;
    
    // Pick a random color
    const randomColor = planetColors[Math.floor(Math.random() * planetColors.length)];
    
    // Apply the new color
    planet.style.background = randomColor.gradient;
    planet.style.boxShadow = `inset -30px -30px 60px rgba(0,0,0,0.5), inset 10px 10px 40px rgba(255,255,255,0.2), 0 0 60px ${randomColor.glow}`;
    
    // Add pulse animation class
    planet.classList.add('caught');
    
    // Return to original color after 2 seconds
    setTimeout(() => {
        planet.style.background = originalColor.gradient;
        planet.style.boxShadow = `inset -30px -30px 60px rgba(0,0,0,0.5), inset 10px 10px 40px rgba(255,255,255,0.2), 0 0 60px ${originalColor.glow}`;
        planet.classList.remove('caught');
    }, 2000);
}

// Override the catch detection to include planet color change
const originalCheckCatch = checkCatch;
let catchCooldownPlanet = false;

function checkCatchWithPlanet() {
    if (catchCooldownPlanet) {
        requestAnimationFrame(checkCatchWithPlanet);
        return;
    }
    
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const doggyOrbit = document.querySelector('.doggy-orbit');
    
    const catTransform = kittyOrbit.style.transform;
    const dogTransform = doggyOrbit.style.transform;
    
    const catMatch = catTransform.match(/rotate\(([\d.-]+)rad\)/);
    const dogMatch = dogTransform.match(/rotate\(([\d.-]+)rad\)/);
    
    if (catMatch && dogMatch) {
        const catAng = parseFloat(catMatch[1]);
        const dogAng = parseFloat(dogMatch[1]);
        
        let angleDiff = catAng - dogAng;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        const distance = Math.abs(angleDiff);
        
        if (distance < 0.3) {
            // Change planet color!
            changePlanetColor();
            
            catchCooldownPlanet = true;
            setTimeout(() => { catchCooldownPlanet = false; }, 2000);
        }
    }
    
    requestAnimationFrame(checkCatchWithPlanet);
}

checkCatchWithPlanet();
  </script>
<div id="gameContainer" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; display: none;">
<canvas height="400" id="gameCanvas" style="border: 3px solid #4a90d9; border-radius: 10px; box-shadow: 0 0 30px rgba(74, 144, 217, 0.5);" width="600">
</canvas>
<div id="gameUI" style="position: absolute; top: 10px; left: 10px; color: white; font-family: system-ui; font-size: 18px;">
    Score:
    <span id="gameScore">
     0
    </span>
</div>
<div id="gameOver" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
<h2 style="font-size: 2rem; color: #ff6b6b; margin-bottom: 1rem;">
     GAME OVER
    </h2>
<p style="font-size: 1.5rem;">
     Final Score:
     <span id="finalScore">
      0
     </span>
</p>
<button onclick="restartGame()" style="margin-top: 1rem; padding: 10px 30px; font-size: 1rem; background: #4a90d9; border: none; border-radius: 20px; color: white; cursor: pointer;">
     Play Again
    </button>
</div>
</div>
<button id="playGameBtn" onclick="toggleGame()" style="position: fixed; bottom: 20px; left: 20px; padding: 12px 20px; background: linear-gradient(135deg, #4a90d9, #1e5799); border: none; border-radius: 25px; color: white; cursor: pointer; font-family: system-ui; font-size: 1rem; box-shadow: 0 0 20px rgba(74, 144, 217, 0.5); z-index: 999; display: flex; align-items: center; gap: 8px;">
   üéÆ
   <span>
    Play Space Game
   </span>
</button>
<script>
   let gameActive = false;
let gameLoop = null;
let canvas, ctx;
let ship = { x: 300, y: 350, width: 40, height: 30, speed: 6 };
let bullets = [];
let asteroids = [];
let particles = [];
let gameScore = 0;
let keys = {};
let gameRunning = false;

function toggleGame() {
    const container = document.getElementById('gameContainer');
    const btn = document.getElementById('playGameBtn');
    if (!gameActive) {
        container.style.display = 'block';
        btn.innerHTML = '‚ùå <span>Close Game</span>';
        gameActive = true;
        initGame();
    } else {
        container.style.display = 'none';
        btn.innerHTML = 'üéÆ <span>Play Space Game</span>';
        gameActive = false;
        if (gameLoop) cancelAnimationFrame(gameLoop);
        gameRunning = false;
    }
}

function initGame() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    ship = { x: 280, y: 350, width: 40, height: 30, speed: 6 };
    bullets = [];
    asteroids = [];
    particles = [];
    gameScore = 0;
    document.getElementById('gameScore').textContent = '0';
    document.getElementById('gameOver').style.display = 'none';
    gameRunning = true;
    
    document.addEventListener('keydown', (e) => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
    document.addEventListener('keyup', (e) => { keys[e.code] = false; });
    
    gameLoop = requestAnimationFrame(updateGame);
}

function restartGame() {
    initGame();
}

function spawnAsteroid() {
    const size = 20 + Math.random() * 40;
    asteroids.push({
        x: Math.random() * (canvas.width - size),
        y: -size,
        size: size,
        speed: 1 + Math.random() * 3,
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 0.1
    });
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1,
            color: color,
            size: 2 + Math.random() * 4
        });
    }
}

function updateGame() {
    if (!gameRunning) return;
    
    ctx.fillStyle = 'rgba(10, 10, 30, 0.9)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw stars
    for (let i = 0; i < 50; i++) {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.7})`;
        ctx.fillRect((i * 37) % canvas.width, (i * 53 + Date.now() * 0.02) % canvas.height, 2, 2);
    }
    
    // Ship controls
    if (keys['ArrowLeft'] && ship.x > 0) ship.x -= ship.speed;
    if (keys['ArrowRight'] && ship.x < canvas.width - ship.width) ship.x += ship.speed;
    if (keys['ArrowUp'] && ship.y > 0) ship.y -= ship.speed;
    if (keys['ArrowDown'] && ship.y < canvas.height - ship.height) ship.y += ship.speed;
    
    // Shooting
    if (keys['Space'] && (!ship.lastShot || Date.now() - ship.lastShot > 200)) {
        bullets.push({ x: ship.x + ship.width/2 - 3, y: ship.y, width: 6, height: 15 });
        ship.lastShot = Date.now();
    }
    
    // Draw ship
    ctx.fillStyle = '#4a90d9';
    ctx.beginPath();
    ctx.moveTo(ship.x + ship.width/2, ship.y);
    ctx.lineTo(ship.x, ship.y + ship.height);
    ctx.lineTo(ship.x + ship.width, ship.y + ship.height);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(ship.x + ship.width/2 - 5, ship.y + ship.height, 10, 8 + Math.random() * 5);
    
    // Update bullets
    bullets = bullets.filter(b => {
        b.y -= 10;
        ctx.fillStyle = '#ffdd00';
        ctx.fillRect(b.x, b.y, b.width, b.height);
        ctx.shadowColor = '#ffdd00';
        ctx.shadowBlur = 10;
        return b.y > -20;
    });
    ctx.shadowBlur = 0;
    
    // Spawn asteroids
    if (Math.random() < 0.02 + gameScore * 0.001) spawnAsteroid();
    
    // Update asteroids
    asteroids = asteroids.filter(a => {
        a.y += a.speed;
        a.rotation += a.rotSpeed;
        
        ctx.save();
        ctx.translate(a.x + a.size/2, a.y + a.size/2);
        ctx.rotate(a.rotation);
        ctx.fillStyle = '#888';
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const r = a.size/2 * (0.7 + Math.random() * 0.3);
            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Check bullet collision
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            if (b.x < a.x + a.size && b.x + b.width > a.x && b.y < a.y + a.size && b.y + b.height > a.y) {
                bullets.splice(i, 1);
                createExplosion(a.x + a.size/2, a.y + a.size/2, '#ff6b6b');
                gameScore += Math.floor(a.size);
                document.getElementById('gameScore').textContent = gameScore;
                return false;
            }
        }
        
        // Check ship collision
        if (a.x < ship.x + ship.width && a.x + a.size > ship.x && a.y < ship.y + ship.height && a.y + a.size > ship.y) {
            createExplosion(ship.x + ship.width/2, ship.y + ship.height/2, '#4a90d9');
            gameRunning = false;
            document.getElementById('finalScore').textContent = gameScore;
            document.getElementById('gameOver').style.display = 'block';
            return false;
        }
        
        return a.y < canvas.height + a.size;
    });
    
    // Update particles
    particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1;
        return p.life > 0;
    });
    
    if (gameRunning) gameLoop = requestAnimationFrame(updateGame);
}
  </script>
</body>
</html>
