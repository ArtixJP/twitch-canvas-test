<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
   Twitch Versus Code
  </title>
<style>
   body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        h1 { font-size: 3rem; text-align: center; }
  </style>
</head>
<body>
<h1 style="position: absolute; top: 20px; z-index: 10; text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);">
   Hello World
  </h1>
<div id="planet-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
</div>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Soleil
  const sunGeom = new THREE.SphereGeometry(1.5, 64, 64);
  const sunMat = new THREE.MeshBasicMaterial({
    color: 0xffdd44,
  });
  const sun = new THREE.Mesh(sunGeom, sunMat);
  sun.position.set(12, 6, 8);
  scene.add(sun);

  // Halo du soleil (glow effect)
  const sunGlowGeom = new THREE.SphereGeometry(2.2, 32, 32);
  const sunGlowMat = new THREE.ShaderMaterial({
    uniforms: {
      c: { type: 'f', value: 0.4 },
      p: { type: 'f', value: 4.0 },
      glowColor: { type: 'c', value: new THREE.Color(0xffaa00) },
      viewVector: { type: 'v3', value: camera.position }
    },
    vertexShader: `
      uniform vec3 viewVector;
      varying float intensity;
      void main() {
        vec3 vNormal = normalize(normalMatrix * normal);
        vec3 vNormel = normalize(normalMatrix * viewVector);
        intensity = pow(0.7 - dot(vNormal, vNormel), 2.0);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 glowColor;
      varying float intensity;
      void main() {
        vec3 glow = glowColor * intensity;
        gl_FragColor = vec4(glow, intensity * 0.8);
      }
    `,
    side: THREE.FrontSide,
    blending: THREE.AdditiveBlending,
    transparent: true
  });
  const sunGlow = new THREE.Mesh(sunGlowGeom, sunGlowMat);
  sunGlow.position.copy(sun.position);
  scene.add(sunGlow);

  // Corona/rayons du soleil
  const coronaGeom = new THREE.SphereGeometry(3, 32, 32);
  const coronaMat = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.15,
    side: THREE.BackSide
  });
  const corona = new THREE.Mesh(coronaGeom, coronaMat);
  corona.position.copy(sun.position);
  scene.add(corona);

  // Planète avec ombres
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a9eff,
    emissive: 0x112244,
    specular: 0xffffff,
    shininess: 15
  });
  const planet = new THREE.Mesh(geometry, material);
  planet.castShadow = true;
  planet.receiveShadow = true;
  scene.add(planet);

  // Lune qui orbite
  const moonGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const moonMat = new THREE.MeshPhongMaterial({
    color: 0xcccccc,
    emissive: 0x222222,
    specular: 0xffffff,
    shininess: 5
  });
  const moon = new THREE.Mesh(moonGeom, moonMat);
  moon.castShadow = true;
  moon.receiveShadow = true;
  
  const moonPivot = new THREE.Object3D();
  moonPivot.add(moon);
  moon.position.x = 4;
  scene.add(moonPivot);
  moonPivot.rotation.x = 0.3;
  moonPivot.rotation.z = 0.2;

  // Atmosphère
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.2,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Anneaux
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x9966ff,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  ring.receiveShadow = true;
  scene.add(ring);

  // Lumière du soleil (point light avec ombres)
  const sunLight = new THREE.PointLight(0xffffcc, 2, 100);
  sunLight.position.copy(sun.position);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 50;
  scene.add(sunLight);

  scene.add(new THREE.AmbientLight(0x333366, 0.3));

  camera.position.z = 7;

  // Étoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  scene.add(new THREE.Points(starsGeom, starsMat));

  let time = 0;
  function animate() {
    requestAnimationFrame(animate);
    time += 0.01;
    
    planet.rotation.y += 0.003;
    atmosphere.rotation.y += 0.002;
    ring.rotation.z += 0.001;
    moonPivot.rotation.y += 0.008;
    moon.rotation.y += 0.01;
    
    // Animation du halo solaire
    sunGlow.scale.setScalar(1 + Math.sin(time * 2) * 0.05);
    corona.scale.setScalar(1 + Math.sin(time * 3) * 0.1);
    
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  // Attendre que Three.js soit chargé
  const checkThree = setInterval(() => {
    if (window.THREE && document.querySelector('#planet-container canvas')) {
      clearInterval(checkThree);
      
      // Récupérer la scène existante via le renderer
      const canvas = document.querySelector('#planet-container canvas');
      const renderer = canvas.__three_renderer__ || null;
      
      // Créer une nouvelle approche: ajouter la lune directement
      const container = document.getElementById('planet-container');
      const existingScript = document.querySelector('#planet-container + script');
      
      // On va modifier le script existant pour inclure la lune
    }
  }, 100);
})();
  </script>
<script>
   (function() {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.getElementById('planet-container').appendChild(renderer.domElement);

  // Planète
  const geometry = new THREE.SphereGeometry(2, 64, 64);
  const material = new THREE.MeshPhongMaterial({
    color: 0x4a9eff,
    emissive: 0x112244,
    specular: 0xffffff,
    shininess: 15
  });
  const planet = new THREE.Mesh(geometry, material);
  scene.add(planet);

  // Atmosphère
  const atmosGeom = new THREE.SphereGeometry(2.15, 64, 64);
  const atmosMat = new THREE.MeshPhongMaterial({
    color: 0x88ccff,
    transparent: true,
    opacity: 0.2,
    side: THREE.BackSide
  });
  const atmosphere = new THREE.Mesh(atmosGeom, atmosMat);
  scene.add(atmosphere);

  // Anneaux
  const ringGeom = new THREE.RingGeometry(2.8, 4, 64);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x9966ff,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2.5;
  scene.add(ring);

  // Lumières
  const light = new THREE.PointLight(0xffffff, 1.5);
  light.position.set(10, 5, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x333366, 0.5));

  camera.position.z = 7;

  // Étoiles
  const starsGeom = new THREE.BufferGeometry();
  const starPositions = [];
  for(let i = 0; i < 2000; i++) {
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
    starPositions.push((Math.random() - 0.5) * 200);
  }
  starsGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
  const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
  scene.add(new THREE.Points(starsGeom, starsMat));

  function animate() {
    requestAnimationFrame(animate);
    planet.rotation.y += 0.003;
    atmosphere.rotation.y += 0.002;
    ring.rotation.z += 0.001;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
  </script>
<script>
   (function() {
  const audio = document.getElementById('bg-music');
  const btn = document.getElementById('music-toggle');
  const playIcon = document.getElementById('play-icon');
  const pauseIcon = document.getElementById('pause-icon');
  
  let isPlaying = true;
  
  // Autoplay peut être bloqué, on gère ça
  audio.play().catch(() => {
    isPlaying = false;
    playIcon.style.display = 'block';
    pauseIcon.style.display = 'none';
  });
  
  btn.addEventListener('click', () => {
    if (isPlaying) {
      audio.pause();
      playIcon.style.display = 'block';
      pauseIcon.style.display = 'none';
    } else {
      audio.play();
      playIcon.style.display = 'none';
      pauseIcon.style.display = 'block';
    }
    isPlaying = !isPlaying;
  });
})();
  </script>
<audio autoplay="" id="bg-music" loop="">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<button id="music-toggle" style="position: fixed; bottom: 30px; right: 30px; z-index: 100; width: 60px; height: 60px; border-radius: 50%; border: none; background: linear-gradient(135deg, #9966ff 0%, #4a9eff 100%); cursor: pointer; box-shadow: 0 4px 20px rgba(100, 150, 255, 0.5); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;">
<svg fill="white" height="24" id="pause-icon" viewbox="0 0 24 24" width="24">
<rect height="16" width="4" x="6" y="4">
</rect>
<rect height="16" width="4" x="14" y="4">
</rect>
</svg>
<svg fill="white" height="24" id="play-icon" style="display: none;" viewbox="0 0 24 24" width="24">
<polygon points="5,3 19,12 5,21">
</polygon>
</svg>
</button>
<script>
   (function() { const audio = document.getElementById('bg-music'); const btn = document.getElementById('music-toggle'); const playIcon = document.getElementById('play-icon'); const pauseIcon = document.getElementById('pause-icon'); let isPlaying = true; audio.volume = 0.5; audio.play().catch(() => { isPlaying = false; playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; }); btn.addEventListener('click', () => { if (isPlaying) { audio.pause(); playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; } else { audio.play(); playIcon.style.display = 'none'; pauseIcon.style.display = 'block'; } isPlaying = !isPlaying; }); btn.addEventListener('mouseenter', () => { btn.style.transform = 'scale(1.1)'; btn.style.boxShadow = '0 6px 30px rgba(100, 150, 255, 0.7)'; }); btn.addEventListener('mouseleave', () => { btn.style.transform = 'scale(1)'; btn.style.boxShadow = '0 4px 20px rgba(100, 150, 255, 0.5)'; }); })();
  </script>
<div id="autoplay-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; cursor: pointer; backdrop-filter: blur(10px);">
<div style="text-align: center; color: white;">
<svg fill="none" height="80" stroke="currentColor" stroke-width="1" style="margin-bottom: 20px; animation: pulse 2s infinite;" viewbox="0 0 24 24" width="80">
<circle cx="12" cy="12" r="10" stroke="#9966ff">
</circle>
<polygon fill="#4a9eff" points="10,8 16,12 10,16">
</polygon>
</svg>
<h2 style="font-size: 2rem; margin: 0 0 10px 0; background: linear-gradient(135deg, #9966ff, #4a9eff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
     Cliquez pour entrer
    </h2>
<p style="opacity: 0.7; font-size: 1rem;">
     La musique commencera automatiquement
    </p>
</div>
</div>
<style>
   @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
  </style>
<script>
   (function(){const overlay=document.getElementById('autoplay-overlay');const audio=document.getElementById('bg-music');const playIcon=document.getElementById('play-icon');const pauseIcon=document.getElementById('pause-icon');overlay.addEventListener('click',function(){audio.play().then(()=>{playIcon.style.display='none';pauseIcon.style.display='block';}).catch(e=>console.log(e));overlay.style.opacity='0';overlay.style.transition='opacity 0.5s ease';setTimeout(()=>overlay.remove(),500);});document.addEventListener('keydown',function(e){if(overlay.parentNode){audio.play().then(()=>{playIcon.style.display='none';pauseIcon.style.display='block';}).catch(e=>console.log(e));overlay.style.opacity='0';overlay.style.transition='opacity 0.5s ease';setTimeout(()=>overlay.remove(),500);}},{once:true});})();
  </script>
</body>
</html>
