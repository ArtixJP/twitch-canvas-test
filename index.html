<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch Versus Code</title>
<style>body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 3rem; text-align: center; margin-bottom: 1rem; }
        .score-display {
            font-size: 1.5rem;
            background: linear-gradient(135deg, rgba(255,200,100,0.3), rgba(255,150,50,0.2));
            padding: 10px 25px;
            border-radius: 20px;
            margin-bottom: 1rem;
            box-shadow: 0 0 20px rgba(255, 200, 100, 0.3);
            z-index: 10;
            position: relative;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .score-display.point-scored {
            transform: scale(1.2);
            box-shadow: 0 0 40px rgba(255, 200, 100, 0.8);
        }
        #dogScore {
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        .planet-system {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .planet {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a90d9 0%, #1e5799 50%, #0d2f5e 100%);
            box-shadow: 
                inset -30px -30px 60px rgba(0,0,0,0.5),
                inset 10px 10px 40px rgba(255,255,255,0.2),
                0 0 60px rgba(74, 144, 217, 0.4);
            animation: float 4s ease-in-out infinite;
            position: relative;
            transition: background 0.8s ease-out, box-shadow 0.8s ease-out;
        }
        .planet.color-change {
            animation: float 4s ease-in-out infinite, planet-pulse 0.3s ease-out;
        }
        @keyframes planet-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .planet::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 15%;
            width: 30%;
            height: 20%;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            filter: blur(5px);
        }
        .planet::after {
            content: '';
            position: absolute;
            top: 40%;
            left: 60%;
            width: 15%;
            height: 10%;
            background: rgba(30, 87, 153, 0.6);
            border-radius: 50%;
            filter: blur(3px);
        }
        .moon-orbit {
            position: absolute;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            animation: orbit 8s linear infinite;
        }
        .moon {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e8e8e8 0%, #b0b0b0 50%, #808080 100%);
            box-shadow: 
                inset -8px -8px 16px rgba(0,0,0,0.4),
                inset 4px 4px 10px rgba(255,255,255,0.3),
                0 0 20px rgba(200, 200, 200, 0.3);
        }
        .moon::before {
            content: '';
            position: absolute;
            top: 25%;
            left: 20%;
            width: 8px;
            height: 8px;
            background: rgba(100,100,100,0.5);
            border-radius: 50%;
        }
        .moon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 55%;
            width: 12px;
            height: 12px;
            background: rgba(100,100,100,0.4);
            border-radius: 50%;
        }
        .kitty-orbit {
            position: absolute;
            width: 350px;
            height: 350px;
            border-radius: 50%;
        }
        .kitty {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            filter: drop-shadow(0 0 10px rgba(255, 182, 193, 0.8));
            animation: kitty-wobble 0.5s ease-in-out infinite;
        }
        .dog-orbit {
            position: absolute;
            width: 320px;
            height: 320px;
            border-radius: 50%;
        }
        .dog {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            filter: drop-shadow(0 0 10px rgba(255, 200, 100, 0.8));
            animation: dog-wobble 0.3s ease-in-out infinite;
        }
        .dog.chasing {
            filter: drop-shadow(0 0 15px rgba(255, 100, 50, 1));
        }
        .kitty.escaping {
            filter: drop-shadow(0 0 20px rgba(255, 50, 50, 1));
        }
        .kitty.caught {
            animation: caught-spin 0.5s ease-out;
        }
        @keyframes caught-spin {
            0% { transform: translateX(-50%) rotate(0deg) scale(1); }
            50% { transform: translateX(-50%) rotate(180deg) scale(1.5); }
            100% { transform: translateX(-50%) rotate(360deg) scale(1); }
        }
        @keyframes orbit {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes orbit-reverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }
        @keyframes kitty-wobble {
            0%, 100% { transform: translateX(-50%) rotate(-10deg); }
            50% { transform: translateX(-50%) rotate(10deg); }
        }
        @keyframes dog-wobble {
            0%, 100% { transform: translateX(-50%) rotate(-15deg) scaleX(-1); }
            50% { transform: translateX(-50%) rotate(15deg) scaleX(-1); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .music-control {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
        }
        .music-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .music-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(99, 102, 241, 0.7);
        }
        .music-btn:active {
            transform: scale(0.95);
        }
        #three-container canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
        .planet-system {
            z-index: 1;
            position: relative;
        }
        h1 {
            z-index: 1;
            position: relative;
            text-shadow: 0 0 20px rgba(255, 221, 0, 0.5);
        }
@keyframes elephant-bounce {
  0%, 100% { transform: translateY(0) rotate(-5deg); }
  50% { transform: translateY(-10px) rotate(5deg); }
}
@keyframes water-drop {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-150px) scale(0.3); opacity: 0; }
}
@keyframes water-spray-left {
  0% { transform: translate(0, 0) scale(1); opacity: 1; }
  100% { transform: translate(-80px, -120px) scale(0.2); opacity: 0; }
}
@keyframes water-spray-right {
  0% { transform: translate(0, 0) scale(1); opacity: 1; }
  100% { transform: translate(80px, -120px) scale(0.2); opacity: 0; }
}
.water-droplet {
  position: absolute;
  font-size: 24px;
  animation-duration: 1.5s;
  animation-timing-function: ease-out;
  animation-iteration-count: infinite;
}
#elephant-container {
  filter: drop-shadow(0 0 20px rgba(100, 200, 255, 0.5));
}</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script></head>
<body>
<h1>Hello World</h1><div id="game-container" style="position: relative; z-index: 10; margin: 20px 0;"><div id="game-canvas" style="border-radius: 15px; overflow: hidden; box-shadow: 0 0 30px rgba(99, 102, 241, 0.5);"></div><div id="game-ui" style="display: flex; gap: 20px; justify-content: center; margin-top: 10px; font-size: 1.2rem;"><span style="background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,180,0,0.2)); padding: 8px 20px; border-radius: 15px;">‚≠ê Stars: <span id="starCount">0</span></span><span style="background: linear-gradient(135deg, rgba(255,100,100,0.3), rgba(200,50,50,0.2)); padding: 8px 20px; border-radius: 15px;">‚ù§Ô∏è Lives: <span id="livesCount">3</span></span><span style="background: linear-gradient(135deg, rgba(100,200,255,0.3), rgba(50,150,200,0.2)); padding: 8px 20px; border-radius: 15px;">üèÜ High: <span id="highScore">0</span></span></div><p style="text-align: center; margin-top: 10px; opacity: 0.7; font-size: 0.9rem;">üöÄ Move mouse to control spaceship | Collect ‚≠ê | Avoid üåë</p></div><div class="score-display" id="scoreDisplay">üêï Dog Score: <span id="dogScore">0</span></div>
<div id="three-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none;"></div><div id="elephant-container" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; pointer-events: none;"><div id="elephant" style="font-size: 100px; animation: elephant-bounce 1s ease-in-out infinite;">üêò</div><div id="water-spray" style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%);"></div></div><div class="planet-system"><div class="planet"></div><div class="moon-orbit"><div class="moon"></div></div><div class="kitty-orbit"><div class="kitty">üê±</div></div><div class="dog-orbit"><div class="dog">üêï</div></div></div><div class="stars" id="stars"></div><script>
    const starsContainer = document.getElementById('stars');
    for(let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 2 + 's';
        star.style.width = (Math.random() * 2 + 1) + 'px';
        star.style.height = star.style.width;
        starsContainer.appendChild(star);
    }
</script><audio autoplay="" id="bgMusic" loop="">
<source src="https://nu.vgmtreasurechest.com/soundtracks/professor-layton-and-the-unwound-future-hd-android-ios-mobile-gamerip-2020/bhjayocv/08.%20More%20London%20Streets.mp3" type="audio/mpeg"/>
</audio>
<div class="music-control">
<button class="music-btn" id="musicToggle" title="Play/Pause Music">‚è∏Ô∏è</button>
</div>
<script>
    const audio = document.getElementById('bgMusic');
    const toggleBtn = document.getElementById('musicToggle');
    let isPlaying = false;
    
    toggleBtn.addEventListener('click', function() {
        if (isPlaying) {
            audio.pause();
            toggleBtn.textContent = '‚ñ∂Ô∏è';
            isPlaying = false;
        } else {
            audio.play();
            toggleBtn.textContent = '‚è∏Ô∏è';
            isPlaying = true;
        }
    });
    
    audio.addEventListener('ended', function() {
        toggleBtn.textContent = '‚ñ∂Ô∏è';
        isPlaying = false;
    });
</script><script>
    // Set initial state to playing since autoplay is enabled
    document.addEventListener('DOMContentLoaded', function() {
        const audio = document.getElementById('bgMusic');
        const toggleBtn = document.getElementById('musicToggle');
        
        // Try to play on load (may be blocked by browser)
        audio.play().then(() => {
            toggleBtn.textContent = '‚è∏Ô∏è';
            window.isPlaying = true;
        }).catch(() => {
            toggleBtn.textContent = '‚ñ∂Ô∏è';
            window.isPlaying = false;
        });
    });
</script><script>
(function() {
    const container = document.getElementById('three-container');
    
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);
    
    // Sun geometry
    const sunGeometry = new THREE.SphereGeometry(0.8, 64, 64);
    
    // Sun material with glow effect
    const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xffdd00,
    });
    
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.position.set(-3, 2, 0);
    scene.add(sun);
    
    // Sun glow layers
    const glowGeometry = new THREE.SphereGeometry(0.85, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffaa00,
        transparent: true,
        opacity: 0.4
    });
    const glow1 = new THREE.Mesh(glowGeometry, glowMaterial);
    sun.add(glow1);
    
    const glow2Geometry = new THREE.SphereGeometry(1.0, 32, 32);
    const glow2Material = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.2
    });
    const glow2 = new THREE.Mesh(glow2Geometry, glow2Material);
    sun.add(glow2);
    
    const glow3Geometry = new THREE.SphereGeometry(1.3, 32, 32);
    const glow3Material = new THREE.MeshBasicMaterial({
        color: 0xff4400,
        transparent: true,
        opacity: 0.1
    });
    const glow3 = new THREE.Mesh(glow3Geometry, glow3Material);
    sun.add(glow3);
    
    // Point light from sun
    const sunLight = new THREE.PointLight(0xffdd88, 2, 100);
    sunLight.position.copy(sun.position);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 1024;
    sunLight.shadow.mapSize.height = 1024;
    scene.add(sunLight);
    
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x222244, 0.3);
    scene.add(ambientLight);
    
    // Corona/rays effect using sprites
    const rayCount = 12;
    const rays = [];
    for(let i = 0; i < rayCount; i++) {
        const rayGeometry = new THREE.PlaneGeometry(0.1, 2);
        const rayMaterial = new THREE.MeshBasicMaterial({
            color: 0xffee88,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const ray = new THREE.Mesh(rayGeometry, rayMaterial);
        ray.rotation.z = (i / rayCount) * Math.PI * 2;
        ray.position.set(0, 0, -0.1);
        sun.add(ray);
        rays.push(ray);
    }
    
    // Animation
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;
        
        // Pulsing sun
        const pulse = 1 + Math.sin(time * 2) * 0.05;
        sun.scale.set(pulse, pulse, pulse);
        
        // Rotating glow
        glow1.rotation.y += 0.01;
        glow2.rotation.y -= 0.008;
        glow3.rotation.x += 0.005;
        
        // Animate rays
        rays.forEach((ray, i) => {
            ray.material.opacity = 0.2 + Math.sin(time * 3 + i) * 0.15;
            ray.scale.y = 1 + Math.sin(time * 2 + i * 0.5) * 0.3;
        });
        
        // Subtle sun movement
        sun.position.y = 2 + Math.sin(time * 0.5) * 0.2;
        sunLight.position.copy(sun.position);
        
        renderer.render(scene, camera);
    }
    animate();
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
})();
</script><script>
(function() {
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const dogOrbit = document.querySelector('.dog-orbit');
    const kitty = document.querySelector('.kitty');
    const dog = document.querySelector('.dog');
    
    let catAngle = 0;
    let dogAngle = Math.PI; // Start opposite to cat
    
    const catRadius = 175;
    const dogRadius = 160;
    
    const normalCatSpeed = 0.015;
    const escapeCatSpeed = 0.08;
    const dogSpeed = 0.025;
    
    let currentCatSpeed = normalCatSpeed;
    let isEscaping = false;
    
    function getPosition(angle, radius) {
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius
        };
    }
    
    function getDistance(angle1, angle2) {
        let diff = Math.abs(angle1 - angle2);
        if (diff > Math.PI) diff = 2 * Math.PI - diff;
        return diff;
    }
    
    function animate() {
        // Move cat (counter-clockwise)
        catAngle -= currentCatSpeed;
        
        // Dog always chases cat (moves toward cat's angle)
        let angleDiff = catAngle - dogAngle;
        
        // Normalize to [-PI, PI]
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        // Dog moves toward cat
        if (angleDiff > 0) {
            dogAngle += dogSpeed;
        } else {
            dogAngle -= dogSpeed;
        }
        
        // Check distance
        const distance = getDistance(catAngle, dogAngle);
        const closeThreshold = 0.5; // radians
        const safeThreshold = 1.5;
        
        if (distance < closeThreshold && !isEscaping) {
            isEscaping = true;
            currentCatSpeed = escapeCatSpeed;
            kitty.classList.add('escaping');
            dog.classList.add('chasing');
        } else if (distance > safeThreshold && isEscaping) {
            isEscaping = false;
            currentCatSpeed = normalCatSpeed;
            kitty.classList.remove('escaping');
            dog.classList.remove('chasing');
        }
        
        // Apply rotations to orbits
        const catDeg = (catAngle * 180 / Math.PI);
        const dogDeg = (dogAngle * 180 / Math.PI);
        
        kittyOrbit.style.transform = `rotate(${catDeg}deg)`;
        dogOrbit.style.transform = `rotate(${dogDeg}deg)`;
        
        // Counter-rotate the emojis so they stay upright
        kitty.style.transform = `translateX(-50%) rotate(${-catDeg}deg)`;
        dog.style.transform = `translateX(-50%) rotate(${-dogDeg}deg) scaleX(-1)`;
        
        requestAnimationFrame(animate);
    }
    
    animate();
})();
</script><script>
(function() {
    // Remove old chase script and replace with scoring version
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const dogOrbit = document.querySelector('.dog-orbit');
    const kitty = document.querySelector('.kitty');
    const dog = document.querySelector('.dog');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const dogScoreEl = document.getElementById('dogScore');
    
    let catAngle = 0;
    let dogAngle = Math.PI;
    let dogScore = 0;
    let canScore = true;
    
    const catRadius = 175;
    const dogRadius = 160;
    
    const normalCatSpeed = 0.015;
    const escapeCatSpeed = 0.08;
    const dogSpeed = 0.025;
    
    let currentCatSpeed = normalCatSpeed;
    let isEscaping = false;
    
    function getDistance(angle1, angle2) {
        let diff = Math.abs(angle1 - angle2);
        if (diff > Math.PI) diff = 2 * Math.PI - diff;
        return diff;
    }
    
    function scorePoint() {
        if (!canScore) return;
        canScore = false;
        dogScore++;
        dogScoreEl.textContent = dogScore;
        
        // Visual feedback
        scoreDisplay.classList.add('point-scored');
        kitty.classList.add('caught');
        
        setTimeout(() => {
            scoreDisplay.classList.remove('point-scored');
            kitty.classList.remove('caught');
        }, 500);
        
        // Teleport cat to opposite side
        catAngle = dogAngle + Math.PI;
        
        // Allow scoring again after cooldown
        setTimeout(() => {
            canScore = true;
        }, 1000);
    }
    
    function animateChase() {
        catAngle -= currentCatSpeed;
        
        let angleDiff = catAngle - dogAngle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        if (angleDiff > 0) {
            dogAngle += dogSpeed;
        } else {
            dogAngle -= dogSpeed;
        }
        
        const distance = getDistance(catAngle, dogAngle);
        const catchThreshold = 0.2;
        const closeThreshold = 0.5;
        const safeThreshold = 1.5;
        
        // Check for catch!
        if (distance < catchThreshold && canScore) {
            scorePoint();
        }
        
        if (distance < closeThreshold && !isEscaping) {
            isEscaping = true;
            currentCatSpeed = escapeCatSpeed;
            kitty.classList.add('escaping');
            dog.classList.add('chasing');
        } else if (distance > safeThreshold && isEscaping) {
            isEscaping = false;
            currentCatSpeed = normalCatSpeed;
            kitty.classList.remove('escaping');
            dog.classList.remove('chasing');
        }
        
        const catDeg = (catAngle * 180 / Math.PI);
        const dogDeg = (dogAngle * 180 / Math.PI);
        
        kittyOrbit.style.transform = `rotate(${catDeg}deg)`;
        dogOrbit.style.transform = `rotate(${dogDeg}deg)`;
        
        kitty.style.transform = `translateX(-50%) rotate(${-catDeg}deg)`;
        dog.style.transform = `translateX(-50%) rotate(${-dogDeg}deg) scaleX(-1)`;
        
        requestAnimationFrame(animateChase);
    }
    
    animateChase();
})();
</script><script>
(function() {
    const kittyOrbit = document.querySelector('.kitty-orbit');
    const dogOrbit = document.querySelector('.dog-orbit');
    const kitty = document.querySelector('.kitty');
    const dog = document.querySelector('.dog');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const dogScoreEl = document.getElementById('dogScore');
    
    let catAngle = 0;
    let dogAngle = Math.PI;
    let dogScore = 0;
    let canScore = true;
    
    const catRadius = 175;
    const dogRadius = 160;
    
    const normalCatSpeed = 0.015;
    const escapeCatSpeed = 0.08;
    const dogSpeed = 0.025;
    
    let currentCatSpeed = normalCatSpeed;
    let isEscaping = false;
    
    function getDistance(angle1, angle2) {
        let diff = Math.abs(angle1 - angle2);
        if (diff > Math.PI) diff = 2 * Math.PI - diff;
        return diff;
    }
    
    function scorePoint() {
        if (!canScore) return;
        canScore = false;
        dogScore++;
        dogScoreEl.textContent = dogScore;
        
        // Visual feedback
        scoreDisplay.classList.add('point-scored');
        kitty.classList.add('caught');
        
        // Change planet color!
        if (window.changePlanetColor) {
            window.changePlanetColor();
        }
        
        setTimeout(() => {
            scoreDisplay.classList.remove('point-scored');
            kitty.classList.remove('caught');
        }, 500);
        
        // Teleport cat to opposite side
        catAngle = dogAngle + Math.PI;
        
        // Allow scoring again after cooldown
        setTimeout(() => {
            canScore = true;
        }, 1000);
    }
    
    function animateChase() {
        catAngle -= currentCatSpeed;
        
        let angleDiff = catAngle - dogAngle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        
        if (angleDiff > 0) {
            dogAngle += dogSpeed;
        } else {
            dogAngle -= dogSpeed;
        }
        
        const distance = getDistance(catAngle, dogAngle);
        const catchThreshold = 0.2;
        const closeThreshold = 0.5;
        const safeThreshold = 1.5;
        
        // Check for catch!
        if (distance < catchThreshold && canScore) {
            scorePoint();
        }
        
        if (distance < closeThreshold && !isEscaping) {
            isEscaping = true;
            currentCatSpeed = escapeCatSpeed;
            kitty.classList.add('escaping');
            dog.classList.add('chasing');
        } else if (distance > safeThreshold && isEscaping) {
            isEscaping = false;
            currentCatSpeed = normalCatSpeed;
            kitty.classList.remove('escaping');
            dog.classList.remove('chasing');
        }
        
        const catDeg = (catAngle * 180 / Math.PI);
        const dogDeg = (dogAngle * 180 / Math.PI);
        
        kittyOrbit.style.transform = `rotate(${catDeg}deg)`;
        dogOrbit.style.transform = `rotate(${dogDeg}deg)`;
        
        kitty.style.transform = `translateX(-50%) rotate(${-catDeg}deg)`;
        dog.style.transform = `translateX(-50%) rotate(${-dogDeg}deg) scaleX(-1)`;
        
        requestAnimationFrame(animateChase);
    }
    
    animateChase();
})();
</script><script>
(function() {
    let stars = [];
    let asteroids = [];
    let particles = [];
    let ship = { x: 200, y: 350, size: 30 };
    let score = 0;
    let lives = 3;
    let highScore = parseInt(localStorage.getItem('spaceHighScore')) || 0;
    let gameOver = false;
    let canvasWidth = 400;
    let canvasHeight = 400;
    let difficulty = 1;
    
    document.getElementById('highScore').textContent = highScore;
    
    const sketch = (p) => {
        p.setup = function() {
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('game-canvas');
            p.textAlign(p.CENTER, p.CENTER);
            spawnStar();
        };
        
        p.draw = function() {
            // Space background
            p.background(10, 15, 30);
            
            // Draw background stars
            p.fill(255, 255, 255, 100);
            p.noStroke();
            for(let i = 0; i < 50; i++) {
                let x = (i * 73 + p.frameCount * 0.1) % canvasWidth;
                let y = (i * 137) % canvasHeight;
                let size = (i % 3) + 1;
                p.ellipse(x, y, size, size);
            }
            
            if (gameOver) {
                drawGameOver(p);
                return;
            }
            
            // Update ship position (smooth follow)
            let targetX = p.constrain(p.mouseX, 20, canvasWidth - 20);
            let targetY = p.constrain(p.mouseY, 20, canvasHeight - 20);
            ship.x = p.lerp(ship.x, targetX, 0.15);
            ship.y = p.lerp(ship.y, targetY, 0.15);
            
            // Spawn logic
            if (p.frameCount % 60 === 0) spawnStar();
            if (p.frameCount % Math.max(40 - difficulty * 5, 15) === 0) spawnAsteroid();
            
            // Update and draw stars
            for (let i = stars.length - 1; i >= 0; i--) {
                let s = stars[i];
                s.y += s.speed;
                s.angle += 0.05;
                
                // Draw star glow
                p.fill(255, 215, 0, 50);
                p.ellipse(s.x, s.y, s.size * 2, s.size * 2);
                
                // Draw star
                p.push();
                p.translate(s.x, s.y);
                p.rotate(s.angle);
                p.fill(255, 215, 0);
                drawStar(p, 0, 0, s.size/2, s.size, 5);
                p.pop();
                
                // Check collision with ship
                if (p.dist(s.x, s.y, ship.x, ship.y) < ship.size/2 + s.size/2) {
                    score++;
                    document.getElementById('starCount').textContent = score;
                    createParticles(s.x, s.y, [255, 215, 0]);
                    stars.splice(i, 1);
                    difficulty = Math.floor(score / 10) + 1;
                    continue;
                }
                
                if (s.y > canvasHeight + 20) stars.splice(i, 1);
            }
            
            // Update and draw asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                let a = asteroids[i];
                a.y += a.speed;
                a.angle += a.rotSpeed;
                
                // Draw asteroid
                p.push();
                p.translate(a.x, a.y);
                p.rotate(a.angle);
                p.fill(80, 70, 60);
                p.stroke(50, 45, 40);
                p.strokeWeight(2);
                p.beginShape();
                for(let j = 0; j < 8; j++) {
                    let angle = j * p.TWO_PI / 8;
                    let r = a.size/2 + a.bumps[j];
                    p.vertex(p.cos(angle) * r, p.sin(angle) * r);
                }
                p.endShape(p.CLOSE);
                // Crater
                p.fill(60, 55, 50);
                p.noStroke();
                p.ellipse(a.size/6, -a.size/6, a.size/3, a.size/3);
                p.pop();
                
                // Check collision with ship
                if (p.dist(a.x, a.y, ship.x, ship.y) < ship.size/2 + a.size/2 - 5) {
                    lives--;
                    document.getElementById('livesCount').textContent = lives;
                    createParticles(ship.x, ship.y, [255, 100, 100]);
                    asteroids.splice(i, 1);
                    if (lives <= 0) {
                        gameOver = true;
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('spaceHighScore', highScore);
                            document.getElementById('highScore').textContent = highScore;
                        }
                    }
                    continue;
                }
                
                if (a.y > canvasHeight + 30) asteroids.splice(i, 1);
            }
            
            // Draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let part = particles[i];
                part.x += part.vx;
                part.y += part.vy;
                part.life -= 3;
                p.fill(part.color[0], part.color[1], part.color[2], part.life);
                p.noStroke();
                p.ellipse(part.x, part.y, part.size, part.size);
                if (part.life <= 0) particles.splice(i, 1);
            }
            
            // Draw spaceship
            drawSpaceship(p, ship.x, ship.y);
            
            // Draw engine particles
            if (p.frameCount % 2 === 0) {
                particles.push({
                    x: ship.x + p.random(-5, 5),
                    y: ship.y + 15,
                    vx: p.random(-0.5, 0.5),
                    vy: p.random(1, 3),
                    size: p.random(3, 6),
                    life: 150,
                    color: [255, p.random(100, 200), 50]
                });
            }
        };
        
        p.mousePressed = function() {
            if (gameOver && p.mouseX > 0 && p.mouseX < canvasWidth && p.mouseY > 0 && p.mouseY < canvasHeight) {
                resetGame();
            }
        };
        
        function drawSpaceship(p, x, y) {
            p.push();
            p.translate(x, y);
            
            // Engine glow
            p.fill(255, 150, 50, 100);
            p.noStroke();
            p.ellipse(0, 12, 15, 20);
            
            // Body
            p.fill(100, 150, 255);
            p.stroke(70, 120, 220);
            p.strokeWeight(2);
            p.beginShape();
            p.vertex(0, -15);
            p.vertex(12, 10);
            p.vertex(0, 5);
            p.vertex(-12, 10);
            p.endShape(p.CLOSE);
            
            // Cockpit
            p.fill(200, 230, 255);
            p.noStroke();
            p.ellipse(0, -3, 8, 10);
            
            // Wings
            p.fill(80, 130, 200);
            p.triangle(-12, 10, -18, 15, -8, 5);
            p.triangle(12, 10, 18, 15, 8, 5);
            
            p.pop();
        }
        
        function drawStar(p, x, y, radius1, radius2, npoints) {
            let angle = p.TWO_PI / npoints;
            let halfAngle = angle / 2.0;
            p.beginShape();
            for (let a = -p.PI/2; a < p.TWO_PI - p.PI/2; a += angle) {
                let sx = x + p.cos(a) * radius2;
                let sy = y + p.sin(a) * radius2;
                p.vertex(sx, sy);
                sx = x + p.cos(a + halfAngle) * radius1;
                sy = y + p.sin(a + halfAngle) * radius1;
                p.vertex(sx, sy);
            }
            p.endShape(p.CLOSE);
        }
        
        function drawGameOver(p) {
            p.fill(0, 0, 0, 150);
            p.rect(0, 0, canvasWidth, canvasHeight);
            
            p.fill(255);
            p.textSize(32);
            p.text('GAME OVER', canvasWidth/2, canvasHeight/2 - 40);
            
            p.textSize(20);
            p.fill(255, 215, 0);
            p.text('Stars: ' + score, canvasWidth/2, canvasHeight/2);
            
            if (score >= highScore && score > 0) {
                p.fill(100, 255, 100);
                p.text('NEW HIGH SCORE!', canvasWidth/2, canvasHeight/2 + 30);
            }
            
            p.fill(200);
            p.textSize(16);
            p.text('Click to play again', canvasWidth/2, canvasHeight/2 + 70);
        }
        
        function spawnStar() {
            stars.push({
                x: p.random(30, canvasWidth - 30),
                y: -20,
                size: p.random(15, 25),
                speed: p.random(1.5, 3),
                angle: 0
            });
        }
        
        function spawnAsteroid() {
            let bumps = [];
            for(let i = 0; i < 8; i++) bumps.push(p.random(-5, 5));
            asteroids.push({
                x: p.random(30, canvasWidth - 30),
                y: -30,
                size: p.random(25, 40),
                speed: p.random(2, 4 + difficulty * 0.5),
                angle: 0,
                rotSpeed: p.random(-0.05, 0.05),
                bumps: bumps
            });
        }
        
        function createParticles(x, y, color) {
            for(let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: p.random(-3, 3),
                    vy: p.random(-3, 3),
                    size: p.random(3, 8),
                    life: 255,
                    color: color
                });
            }
        }
        
        function resetGame() {
            stars = [];
            asteroids = [];
            particles = [];
            score = 0;
            lives = 3;
            difficulty = 1;
            gameOver = false;
            ship.x = canvasWidth / 2;
            ship.y = canvasHeight - 50;
            document.getElementById('starCount').textContent = 0;
            document.getElementById('livesCount').textContent = 3;
        }
    };
    
    new p5(sketch);
})();
</script><script>
(function() {
  const sprayContainer = document.getElementById('water-spray');
  const droplets = ['üíß', 'üí¶', 'üåä'];
  
  function createWaterSpray() {
    for(let i = 0; i < 5; i++) {
      setTimeout(() => {
        const drop = document.createElement('span');
        drop.className = 'water-droplet';
        drop.textContent = droplets[Math.floor(Math.random() * droplets.length)];
        drop.style.left = (Math.random() * 60 - 30) + 'px';
        
        const animType = Math.random();
        if(animType < 0.33) {
          drop.style.animation = 'water-drop 1.5s ease-out infinite';
        } else if(animType < 0.66) {
          drop.style.animation = 'water-spray-left 1.5s ease-out infinite';
        } else {
          drop.style.animation = 'water-spray-right 1.5s ease-out infinite';
        }
        
        drop.style.animationDelay = (Math.random() * 0.5) + 's';
        sprayContainer.appendChild(drop);
        
        setTimeout(() => {
          if(sprayContainer.children.length > 20) {
            sprayContainer.removeChild(sprayContainer.firstChild);
          }
        }, 2000);
      }, i * 200);
    }
  }
  
  createWaterSpray();
  setInterval(createWaterSpray, 1500);
})();
</script></body>
</html>