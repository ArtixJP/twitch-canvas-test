<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Minecraft 3D Simulation</title>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            overflow: hidden;
            background: #1a1a2e;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            color: #4CAF50;
            text-shadow: 4px 4px 0 #2E7D32, -2px -2px 0 #81C784;
            z-index: 100;
            letter-spacing: 4px;
            pointer-events: none;
        }
        .warning {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #FF5722;
            font-size: 1.2rem;
            animation: warningPulse 0.5s ease-in-out infinite;
            text-shadow: 2px 2px 0 #000;
            z-index: 100;
            pointer-events: none;
        }
        @keyframes warningPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
<div id="canvas-container"></div>
<h1 class="title">MINECRAFT 3D SIMULATION</h1>
<p class="warning">‚ö†Ô∏è SPACE CROISSANT INCOMING! ‚ö†Ô∏è</p>
<p class="controls">üñ±Ô∏è Drag to rotate | üîÑ Auto-rotating world | üêï Dog &amp; üê± Cat roaming!</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 12, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xFFD700, 1);
        sunLight.position.set(10, 20, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Texture loader for pixelated look
        function createPixelTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    ctx.fillStyle = Math.random() > 0.5 ? color1 : color2;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Materials
        const grassTopMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#4CAF50', '#66BB6A')
        });
        const grassSideMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#8D6E63', '#6D4C41')
        });
        const dirtMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#8D6E63', '#5D4037')
        });
        const stoneMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#9E9E9E', '#757575')
        });
        const woodMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#5D4037', '#4E342E')
        });
        const leavesMaterial = new THREE.MeshLambertMaterial({ 
            map: createPixelTexture('#2E7D32', '#388E3C'),
            transparent: true,
            opacity: 0.9
        });

        // Create grass block with different top
        function createGrassBlock(x, y, z) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                grassSideMaterial, grassSideMaterial,
                grassTopMaterial, dirtMaterial,
                grassSideMaterial, grassSideMaterial
            ];
            const block = new THREE.Mesh(geometry, materials);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            return block;
        }

        function createBlock(x, y, z, material) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            return block;
        }

        // Generate terrain
        const worldSize = 16;
        for (let x = -worldSize/2; x < worldSize/2; x++) {
            for (let z = -worldSize/2; z < worldSize/2; z++) {
                // Grass top layer
                scene.add(createGrassBlock(x, 0, z));
                // Dirt layers
                for (let y = -1; y > -3; y--) {
                    scene.add(createBlock(x, y, z, dirtMaterial));
                }
                // Stone base
                scene.add(createBlock(x, -3, z, stoneMaterial));
            }
        }

        // Create trees
        function createTree(x, z) {
            // Trunk
            for (let y = 1; y <= 4; y++) {
                scene.add(createBlock(x, y, z, woodMaterial));
            }
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 4; ly <= 6; ly++) {
                        if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - 5) < 4) {
                            scene.add(createBlock(x + lx, ly, z + lz, leavesMaterial));
                        }
                    }
                }
            }
        }

        createTree(-4, -4);
        createTree(5, 3);
        createTree(-2, 5);

        // Sun
        const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(20, 25, -20);
        scene.add(sun);

        // Clouds
        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            
            for (let i = 0; i < 5; i++) {
                const cloudPart = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1, 2),
                    cloudMaterial
                );
                cloudPart.position.set(i * 1.5 - 3, Math.random() * 0.5, Math.random() * 2 - 1);
                cloudGroup.add(cloudPart);
            }
            cloudGroup.position.set(x, y, z);
            return cloudGroup;
        }

        const clouds = [];
        for (let i = 0; i < 5; i++) {
            const cloud = createCloud(
                Math.random() * 40 - 20,
                15 + Math.random() * 5,
                Math.random() * 40 - 20
            );
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Flying hamburger (represented as a bouncing cube)
        const hamburgerGroup = new THREE.Group();
        const bunTop = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.5, 1.5),
            new THREE.MeshLambertMaterial({ color: 0xD4A574 })
        );
        bunTop.position.y = 0.5;
        const patty = new THREE.Mesh(
            new THREE.BoxGeometry(1.3, 0.3, 1.3),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        const bunBottom = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.4, 1.5),
            new THREE.MeshLambertMaterial({ color: 0xD4A574 })
        );
        bunBottom.position.y = -0.35;
        hamburgerGroup.add(bunTop, patty, bunBottom);
        hamburgerGroup.position.set(0, 10, 0);
        scene.add(hamburgerGroup);

        // Space Croissant
        const croissantGroup = new THREE.Group();
        const croissantBody = new THREE.Mesh(
            new THREE.TorusGeometry(1, 0.4, 8, 16, Math.PI),
            new THREE.MeshLambertMaterial({ color: 0xE6B87D })
        );
        croissantGroup.add(croissantBody);
        croissantGroup.position.set(-15, 20, -15);
        scene.add(croissantGroup);

        // Dog (simple blocky representation)
        const dogGroup = new THREE.Group();
        const dogBody = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 1, 2),
            new THREE.MeshLambertMaterial({ color: 0xD2691E })
        );
        const dogHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.MeshLambertMaterial({ color: 0xD2691E })
        );
        dogHead.position.set(0, 0.3, 1.2);
        // Dog tail
        const dogTail = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.2, 0.6),
            new THREE.MeshLambertMaterial({ color: 0xD2691E })
        );
        dogTail.position.set(0, 0.3, -1.2);
        dogGroup.add(dogBody, dogHead, dogTail);
        dogGroup.position.set(-5, 1.5, 0);
        scene.add(dogGroup);

        // Minecraft Cat
        const catGroup = new THREE.Group();
        const catBody = new THREE.Mesh(
            new THREE.BoxGeometry(1, 0.8, 1.8),
            new THREE.MeshLambertMaterial({ color: 0xFF8C00 })
        );
        const catHead = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.7, 0.7),
            new THREE.MeshLambertMaterial({ color: 0xFF8C00 })
        );
        catHead.position.set(0, 0.2, 1);
        // Cat ears
        const catEarLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.3, 0.1),
            new THREE.MeshLambertMaterial({ color: 0xFF8C00 })
        );
        catEarLeft.position.set(-0.2, 0.6, 1);
        const catEarRight = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.3, 0.1),
            new THREE.MeshLambertMaterial({ color: 0xFF8C00 })
        );
        catEarRight.position.set(0.2, 0.6, 1);
        // Cat tail (long and curved up)
        const catTail = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 1),
            new THREE.MeshLambertMaterial({ color: 0xFF8C00 })
        );
        catTail.position.set(0, 0.3, -1.2);
        catTail.rotation.x = -0.5;
        // Cat stripes
        const stripe1 = new THREE.Mesh(
            new THREE.BoxGeometry(1.02, 0.1, 0.2),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        stripe1.position.set(0, 0.35, 0.3);
        const stripe2 = new THREE.Mesh(
            new THREE.BoxGeometry(1.02, 0.1, 0.2),
            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
        );
        stripe2.position.set(0, 0.35, -0.3);
        catGroup.add(catBody, catHead, catEarLeft, catEarRight, catTail, stripe1, stripe2);
        catGroup.position.set(4, 1.4, 2);
        scene.add(catGroup);

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = true;

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
            setTimeout(() => autoRotate = true, 3000);
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                camera.lookAt(0, 0, 0);
            }
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Auto-rotate camera
            if (autoRotate) {
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.002);
                camera.lookAt(0, 0, 0);
            }

            // Animate hamburger
            hamburgerGroup.position.x = Math.sin(time) * 8;
            hamburgerGroup.position.y = 8 + Math.sin(time * 2) * 2;
            hamburgerGroup.position.z = Math.cos(time) * 8;
            hamburgerGroup.rotation.y += 0.02;

            // Animate croissant
            croissantGroup.position.x = Math.sin(time * 0.5) * 15;
            croissantGroup.position.z = Math.cos(time * 0.5) * 15;
            croissantGroup.rotation.x += 0.03;
            croissantGroup.rotation.z += 0.02;

            // Animate dog
            dogGroup.position.x = Math.sin(time * 0.8) * 6;
            dogGroup.rotation.y = Math.sin(time * 0.8) > 0 ? 0 : Math.PI;
            // Wag dog tail
            if (dogGroup.children[2]) {
                dogGroup.children[2].rotation.y = Math.sin(time * 8) * 0.5;
            }

            // Animate cat - follows a different path
            catGroup.position.x = Math.cos(time * 0.6) * 5;
            catGroup.position.z = Math.sin(time * 0.6) * 5;
            catGroup.rotation.y = -time * 0.6 + Math.PI/2;
            // Cat tail sway
            if (catGroup.children[4]) {
                catGroup.children[4].rotation.z = Math.sin(time * 3) * 0.3;
            }

            // Animate clouds
            clouds.forEach((cloud, i) => {
                cloud.position.x += 0.02;
                if (cloud.position.x > 25) cloud.position.x = -25;
            });

            // Sun pulse
            sun.scale.setScalar(1 + Math.sin(time * 2) * 0.1);

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>