<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>üçÑ Mario Minecraft Builder üß±</title>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4a90c2 50%, #2d5a87 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 1.5rem; text-align: center; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100; text-shadow: 2px 2px 4px black; }
        #game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; outline: none; }
        #controls { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 0.9rem; z-index: 100; }
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; z-index: 100; }
        .slot { width: 50px; height: 50px; border: 3px solid #555; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer; }
        .slot.active { border-color: white; }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<h1>üçÑ Mario Minecraft Builder üß±‚õèÔ∏è üé¨</h1>
<div id="movie-info" style="position:absolute;top:50px;right:20px;background:rgba(0,0,0,0.7);padding:10px;border-radius:8px;z-index:100;font-size:0.8rem;">üé¨ Look up! Mario Movie playing in the sky!</div>
<canvas id="game" tabindex="0"></canvas>
<div id="controls">ZQSD/WASD: Move | Space: Jump | Shift: Down<br/>Mouse: Look | Left Click: Build/Deconstruct<br/>1-4: Select Block<br/><span id="debug" style="color:#0f0;">Click game to start! (iframe-friendly)</span></div>
<div id="hotbar">
<div class="slot active" data-block="grass">üîã</div>
<div class="slot" data-block="dirt">üî∑</div>
<div class="slot" data-block="stone">‚öôÔ∏è</div>
<div class="slot" data-block="wood">üî∂</div>
<div class="slot" data-block="question">‚ùì</div>
<div class="slot" data-block="brick">üß±</div>
</div>
<script>
    const canvas = document.getElementById('game');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    // Sky clouds
    const clouds = [];
    for(let i = 0; i < 10; i++) {
        const cloudGeo = new THREE.SphereGeometry(2 + Math.random() * 2, 8, 8);
        const cloudMat = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        cloud.position.set((Math.random()-0.5)*60, 15 + Math.random()*10, (Math.random()-0.5)*60);
        cloud.scale.set(1.5, 0.6, 1);
        scene.add(cloud);
        clouds.push(cloud);
    }
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({canvas});
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const blocks = {};
    const blockColors = {grass: 0x00ffaa, dirt: 0x4466aa, stone: 0x8899aa, wood: 0xffaa33, question: 0xffcc00, brick: 0xcc6633};
    let selectedBlock = 'grass';
    let placeMode = true;
    
    function addBlock(x,y,z,type='grass') {
        const key = `${x},${y},${z}`;
        if(blocks[key]) return;
        const geo = new THREE.BoxGeometry(1,1,1);
        const mat = new THREE.MeshLambertMaterial({color: blockColors[type]});
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(x,y,z);
        cube.userData = {type, key};
        scene.add(cube);
        blocks[key] = cube;
    }
    
    for(let x=-10;x<10;x++) for(let z=-10;z<10;z++) {
        addBlock(x, 0, z, 'grass');
        addBlock(x, -1, z, 'dirt');
        if(Math.random()>0.95) addBlock(x,1,z,'wood');
        if(Math.random()>0.97) addBlock(x,3,z,'question');
    }
    
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x2a2a4a));
    
    // Trees like Minecraft
    const trees = [];
    for(let i = 0; i < 8; i++) {
        const trunkGeo = new THREE.BoxGeometry(0.5, 3, 0.5);
        const trunkMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set((Math.random()-0.5)*18, 2.5, (Math.random()-0.5)*18);
        scene.add(trunk);
        const leavesGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
        const leavesMat = new THREE.MeshLambertMaterial({color: 0x228B22});
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.copy(trunk.position);
        leaves.position.y += 2.5;
        scene.add(leaves);
        trees.push({trunk, leaves});
    }
    
    // Mario coins floating in space
    const coins = [];
    for(let i = 0; i < 20; i++) {
        const coinGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
        const coinMat = new THREE.MeshLambertMaterial({color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.3});
        const coin = new THREE.Mesh(coinGeo, coinMat);
        coin.position.set((Math.random()-0.5)*30, Math.random()*8+2, (Math.random()-0.5)*30);
        coin.rotation.x = Math.PI/2;
        coin.userData.baseY = coin.position.y;
        scene.add(coin);
        coins.push(coin);
    }
    
    // Piranha plant pipe
    const pipeGeo = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
    const pipeMat = new THREE.MeshLambertMaterial({color: 0x00aa00});
    const pipe = new THREE.Mesh(pipeGeo, pipeMat);
    pipe.position.set(5, 1, -5);
    scene.add(pipe);
    const pipeRim = new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.15, 8, 16), pipeMat);
    pipeRim.position.set(5, 2, -5);
    pipeRim.rotation.x = Math.PI/2;
    scene.add(pipeRim);
    
    // Piranha plant
    const plantHead = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshLambertMaterial({color: 0xff0000}));
    plantHead.position.set(5, 2.5, -5);
    scene.add(plantHead);
    const plantSpots = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({color: 0xffffff}));
    plantSpots.position.set(5.2, 2.6, -4.7);
    scene.add(plantSpots);
    
    // Sunlight
    const sunLight = new THREE.PointLight(0xffffaa, 0.8, 100);
    sunLight.position.set(30, 30, 30);
    scene.add(sunLight);
    
    camera.position.set(0, 5, 10);
    let yaw = 0, pitch = 0;
    const keys = {};
    const vel = {x:0, y:0, z:0};
    
    canvas.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
    canvas.addEventListener('keyup', e => { keys[e.code] = false; e.preventDefault(); });
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    
    canvas.addEventListener('click', () => { canvas.focus(); canvas.requestPointerLock(); document.getElementById('debug').textContent = 'Controls active!'; });
    canvas.focus();
    document.addEventListener('mousemove', e => {
        if(document.pointerLockElement === canvas) {
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }
    });
    
    canvas.addEventListener('mousedown', e => {
        e.preventDefault();
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({x:0,y:0}, camera);
        const hits = raycaster.intersectObjects(Object.values(blocks));
        if(hits.length > 0) {
            const hit = hits[0];
            if(placeMode) {
                const norm = hit.face.normal;
                const pos = hit.object.position;
                addBlock(pos.x+norm.x, pos.y+norm.y, pos.z+norm.z, selectedBlock);
            } else {
                scene.remove(hit.object);
                delete blocks[hit.object.userData.key];
            }
        }
        placeMode = !placeMode;
    });
    
    document.querySelectorAll('.slot').forEach((s,i) => {
        s.addEventListener('click', () => {
            document.querySelectorAll('.slot').forEach(x => x.classList.remove('active'));
            s.classList.add('active');
            selectedBlock = s.dataset.block;
        });
    });
    document.addEventListener('keydown', e => {
        if(e.key >= '1' && e.key <= '4') {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(x => x.classList.remove('active'));
            slots[e.key-1].classList.add('active');
            selectedBlock = slots[e.key-1].dataset.block;
        }
    });
    
    // Floating Movie Theater in the sky
    const theaterGroup = new THREE.Group();
    const screenGeo = new THREE.PlaneGeometry(8, 5);
    const screenCanvas = document.createElement('canvas');
    screenCanvas.width = 512;
    screenCanvas.height = 320;
    const screenCtx = screenCanvas.getContext('2d');
    const screenTexture = new THREE.CanvasTexture(screenCanvas);
    const screenMat = new THREE.MeshBasicMaterial({map: screenTexture, side: THREE.DoubleSide});
    const screen = new THREE.Mesh(screenGeo, screenMat);
    theaterGroup.add(screen);
    
    // Theater frame
    const frameGeo = new THREE.BoxGeometry(9, 6, 0.3);
    const frameMat = new THREE.MeshLambertMaterial({color: 0x8B0000});
    const frame = new THREE.Mesh(frameGeo, frameMat);
    frame.position.z = -0.2;
    theaterGroup.add(frame);
    
    theaterGroup.position.set(0, 25, -20);
    scene.add(theaterGroup);
    
    let movieFrame = 0;
    function updateMovie() {
        movieFrame++;
        screenCtx.fillStyle = '#1a1a2e';
        screenCtx.fillRect(0, 0, 512, 320);
        
        // Draw Mario
        const marioX = 150 + Math.sin(movieFrame * 0.05) * 30;
        const marioY = 200 + Math.abs(Math.sin(movieFrame * 0.1)) * -50;
        screenCtx.fillStyle = '#ff0000';
        screenCtx.fillRect(marioX, marioY, 40, 50);
        screenCtx.fillStyle = '#ffcc99';
        screenCtx.fillRect(marioX + 10, marioY - 15, 20, 20);
        screenCtx.fillStyle = '#ff0000';
        screenCtx.fillRect(marioX + 5, marioY - 25, 30, 12);
        
        // Draw Bowser
        const bowserX = 320 + Math.cos(movieFrame * 0.03) * 20;
        screenCtx.fillStyle = '#228B22';
        screenCtx.fillRect(bowserX, 160, 60, 70);
        screenCtx.fillStyle = '#ffcc00';
        screenCtx.fillRect(bowserX + 10, 145, 40, 25);
        screenCtx.fillStyle = '#ff4500';
        for(let i = 0; i < 5; i++) {
            screenCtx.fillRect(bowserX + 5 + i*10, 130, 8, 15);
        }
        
        // Fireball from Mario
        if(movieFrame % 60 < 30) {
            const fireX = marioX + 50 + (movieFrame % 60) * 5;
            screenCtx.fillStyle = '#ff6600';
            screenCtx.beginPath();
            screenCtx.arc(fireX, marioY + 20, 10, 0, Math.PI * 2);
            screenCtx.fill();
        }
        
        // Title
        screenCtx.fillStyle = '#ffd700';
        screenCtx.font = 'bold 24px Arial';
        screenCtx.fillText('MARIO vs BOWSER', 150, 40);
        
        screenTexture.needsUpdate = true;
    }
    
    // Snake creature
    const snakeSegments = [];
    const snakeLength = 8;
    const snakeSpeed = 0.05;
    let snakeAngle = 0;
    let snakeX = 5, snakeZ = 5;
    
    function animate() {
        requestAnimationFrame(animate);
        const speed = 0.15;
        const dir = new THREE.Vector3();
        if(keys['KeyZ'] || keys['KeyW']) dir.z -= 1;
        if(keys['KeyS']) dir.z += 1;
        if(keys['KeyQ'] || keys['KeyA']) dir.x -= 1;
        if(keys['KeyD']) dir.x += 1;
        dir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        camera.position.x += dir.x * speed;
        camera.position.z += dir.z * speed;
        if(keys['Space']) camera.position.y += speed;
        if(keys['ShiftLeft']) camera.position.y -= speed;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        updateSnake();
        // Animate grandma sign
        signGroup.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
        signGroup.position.y = 3 + Math.sin(Date.now() * 0.002) * 0.2;
        // Animate clouds drifting
        clouds.forEach((c, i) => {
            c.position.x += 0.01;
            if(c.position.x > 30) c.position.x = -30;
        });
        // Animate Mario coins
        coins.forEach((coin, i) => {
            coin.rotation.z += 0.05;
            coin.position.y = coin.userData.baseY + Math.sin(Date.now() * 0.003 + i) * 0.3;
        });
        // Animate piranha plant
        plantHead.position.y = 2.5 + Math.sin(Date.now() * 0.002) * 0.8;
        // Update Mario movie
        updateMovie();
        theaterGroup.rotation.y = Math.sin(Date.now() * 0.0005) * 0.1;
        renderer.render(scene, camera);
    }
    
    for(let i = 0; i < snakeLength; i++) {
        const geo = new THREE.BoxGeometry(0.6, 0.4, 0.6);
        const mat = new THREE.MeshLambertMaterial({color: i === 0 ? 0x00ff00 : 0x228B22});
        const segment = new THREE.Mesh(geo, mat);
        segment.position.set(snakeX - i * 0.5, 1.2, snakeZ);
        scene.add(segment);
        snakeSegments.push(segment);
    }
    
    // Grandma sign in-game!
    const signGroup = new THREE.Group();
    const signGeo = new THREE.BoxGeometry(4, 1.5, 0.2);
    const signMat = new THREE.MeshLambertMaterial({color: 0xff69b4});
    const signBoard = new THREE.Mesh(signGeo, signMat);
    signGroup.add(signBoard);
    const poleGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
    const poleMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.y = -1.5;
    signGroup.add(pole);
    signGroup.position.set(-5, 3, -5);
    scene.add(signGroup);
    
    // Create canvas texture for sign text
    const signCanvas = document.createElement('canvas');
    signCanvas.width = 512;
    signCanvas.height = 192;
    const ctx = signCanvas.getContext('2d');
    ctx.fillStyle = '#ff69b4';
    ctx.fillRect(0, 0, 512, 192);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üëµ Hello Grandma! üíï', 256, 80);
    ctx.fillText('We love you!', 256, 130);
    const signTexture = new THREE.CanvasTexture(signCanvas);
    const signFaceMat = new THREE.MeshBasicMaterial({map: signTexture});
    const signFace = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.4), signFaceMat);
    signFace.position.z = 0.11;
    signGroup.add(signFace);
    
    // Snake eyes
    const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({color: 0xff0000});
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    snakeSegments[0].add(leftEye);
    snakeSegments[0].add(rightEye);
    leftEye.position.set(-0.2, 0.15, -0.25);
    rightEye.position.set(0.2, 0.15, -0.25);
    
    animate();
    
    function updateSnake() {
        snakeAngle += 0.02 + Math.sin(Date.now() * 0.001) * 0.01;
        snakeX += Math.cos(snakeAngle) * snakeSpeed;
        snakeZ += Math.sin(snakeAngle) * snakeSpeed;
        
        // Keep snake in bounds
        if(snakeX > 8) snakeAngle = Math.PI - snakeAngle;
        if(snakeX < -8) snakeAngle = Math.PI - snakeAngle;
        if(snakeZ > 8) snakeAngle = -snakeAngle;
        if(snakeZ < -8) snakeAngle = -snakeAngle;
        
        // Move head
        snakeSegments[0].position.x = snakeX;
        snakeSegments[0].position.z = snakeZ;
        snakeSegments[0].position.y = 1.2 + Math.sin(Date.now() * 0.005) * 0.1;
        snakeSegments[0].rotation.y = -snakeAngle + Math.PI/2;
        
        // Follow segments
        for(let i = 1; i < snakeSegments.length; i++) {
            const prev = snakeSegments[i-1].position;
            const curr = snakeSegments[i].position;
            curr.lerp(prev, 0.3);
            curr.y = 1.2 + Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
            snakeSegments[i].lookAt(prev);
        }
    }
    
    
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>