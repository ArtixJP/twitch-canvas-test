<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>VoxelCraft - Minecraft-like Game</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
        overflow: hidden;
        background: #87CEEB;
        font-family: 'Segoe UI', system-ui, sans-serif;
    }
    #game-container {
        width: 100vw;
        height: 100vh;
        position: relative;
    }
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 100;
    }
    #crosshair::before, #crosshair::after {
        content: '';
        position: absolute;
        background: white;
        mix-blend-mode: difference;
    }
    #crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
        top: 0;
    }
    #crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
        left: 0;
    }
    #ui {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 5px;
        z-index: 100;
    }
    .block-slot {
        width: 50px;
        height: 50px;
        background: rgba(0,0,0,0.5);
        border: 3px solid #555;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
    }
    .block-slot.selected {
        border-color: white;
        transform: scale(1.1);
    }
    .block-slot span {
        font-size: 24px;
    }
    #instructions {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.85);
        color: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        z-index: 200;
        max-width: 400px;
    }
    #instructions h1 {
        font-size: 2rem;
        margin-bottom: 20px;
        color: #4ade80;
    }
    #instructions p {
        margin: 10px 0;
        line-height: 1.6;
    }
    #instructions button {
        margin-top: 20px;
        padding: 15px 40px;
        font-size: 1.2rem;
        background: linear-gradient(45deg, #4ade80, #22c55e);
        border: none;
        border-radius: 10px;
        color: white;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.2s;
    }
    #instructions button:hover {
        transform: scale(1.05);
    }
    #info {
        position: fixed;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 14px;
        text-shadow: 1px 1px 2px black;
        z-index: 100;
    }
    #peach-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        text-align: center;
        animation: peachFloat 2s ease-in-out infinite;
    }
    #peach {
        font-size: 80px;
        filter: drop-shadow(0 4px 8px rgba(255,105,180,0.5));
    }
    #peach-name {
        color: #FFB6C1;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px #FF69B4;
        margin-top: 5px;
    }
    @keyframes peachFloat {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-15px); }
    }
</style>
</head>
<body>
<div id="game-container"></div>
<div id="crosshair"></div>
<div id="ui">
<div class="block-slot selected" data-block="0"><span>üü´</span></div>
<div class="block-slot" data-block="1"><span>üåø</span></div>
<div class="block-slot" data-block="2"><span>ü™®</span></div>
<div class="block-slot" data-block="3"><span>ü™µ</span></div>
<div class="block-slot" data-block="4"><span>üçÉ</span></div>
<div class="block-slot" data-block="5"><span>üíé</span></div>
</div>
<div id="instructions">
<h1>üéÆ VoxelCraft üë∏</h1>
<p><strong>WASD</strong> - Move around</p>
<p><strong>SPACE</strong> - Jump</p>
<p><strong>Mouse</strong> - Look around</p>
<p><strong>Left Click</strong> - Destroy block</p>
<p><strong>Right Click</strong> - Place block</p>
<p><strong>1-6</strong> - Select block type</p>
<button id="start-btn">Click to Play!</button>
</div>
<div id="info">FPS: <span id="fps">0</span></div>
<div id="peach-container">
<div id="peach">üë∏</div>
<div id="peach-name">Princess Peach</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.1/dist/simplex-noise.min.js"></script>
<script>
// VoxelCraft - A Minecraft-like game
const CHUNK_SIZE = 16;
const WORLD_HEIGHT = 32;
const RENDER_DISTANCE = 3;

// Block types with colors
const BLOCK_TYPES = [
    { name: 'dirt', color: 0x964B00 },
    { name: 'grass', color: 0x4CAF50 },
    { name: 'stone', color: 0x9E9E9E },
    { name: 'wood', color: 0x8D6E63 },
    { name: 'leaves', color: 0x81C784 },
    { name: 'diamond', color: 0x4FC3F7 }
];

let scene, camera, renderer;
let world = {};
let player = { x: 8, y: 20, z: 8, vx: 0, vy: 0, vz: 0, onGround: false };
let keys = {};
let selectedBlock = 0;
let isLocked = false;
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

// Simple noise function
function noise2D(x, z) {
    const X = Math.floor(x) & 255;
    const Z = Math.floor(z) & 255;
    const xf = x - Math.floor(x);
    const zf = z - Math.floor(z);
    
    const hash = (n) => {
        n = Math.sin(n) * 43758.5453123;
        return n - Math.floor(n);
    };
    
    const a = hash(X + Z * 57);
    const b = hash(X + 1 + Z * 57);
    const c = hash(X + (Z + 1) * 57);
    const d = hash(X + 1 + (Z + 1) * 57);
    
    const u = xf * xf * (3 - 2 * xf);
    const v = zf * zf * (3 - 2 * zf);
    
    return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(player.x, player.y, player.z);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    generateWorld();
    setupControls();
    animate();
}

function generateWorld() {
    for (let cx = -RENDER_DISTANCE; cx <= RENDER_DISTANCE; cx++) {
        for (let cz = -RENDER_DISTANCE; cz <= RENDER_DISTANCE; cz++) {
            generateChunk(cx, cz);
        }
    }
}

function generateChunk(cx, cz) {
    const chunkKey = `${cx},${cz}`;
    if (world[chunkKey]) return;
    
    world[chunkKey] = { blocks: {}, mesh: null };
    const chunk = world[chunkKey];
    
    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
            const worldX = cx * CHUNK_SIZE + x;
            const worldZ = cz * CHUNK_SIZE + z;
            
            const height = Math.floor(
                8 + 
                noise2D(worldX * 0.05, worldZ * 0.05) * 8 +
                noise2D(worldX * 0.1, worldZ * 0.1) * 4
            );
            
            for (let y = 0; y <= height; y++) {
                let blockType = 0; // dirt
                if (y === height) blockType = 1; // grass on top
                else if (y < height - 3) blockType = 2; // stone deep down
                
                // Random diamond ore
                if (y < 5 && Math.random() < 0.01) blockType = 5;
                
                chunk.blocks[`${x},${y},${z}`] = blockType;
            }
            
            // Generate trees
            if (Math.random() < 0.02 && height > 5) {
                for (let ty = 1; ty <= 5; ty++) {
                    chunk.blocks[`${x},${height + ty},${z}`] = 3; // wood
                }
                // Leaves
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        for (let ly = 4; ly <= 6; ly++) {
                            if (Math.abs(lx) + Math.abs(lz) < 4) {
                                const key = `${x + lx},${height + ly},${z + lz}`;
                                if (!chunk.blocks[key]) {
                                    chunk.blocks[key] = 4; // leaves
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    buildChunkMesh(cx, cz);
}

function buildChunkMesh(cx, cz) {
    const chunkKey = `${cx},${cz}`;
    const chunk = world[chunkKey];
    if (!chunk) return;
    
    if (chunk.mesh) {
        scene.remove(chunk.mesh);
        chunk.mesh.geometry.dispose();
    }
    
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const normals = [];
    
    const addFace = (x, y, z, face, color) => {
        const c = new THREE.Color(color);
        const faceData = {
            top: { verts: [[0,1,0],[1,1,0],[1,1,1],[0,1,1]], normal: [0,1,0] },
            bottom: { verts: [[0,0,1],[1,0,1],[1,0,0],[0,0,0]], normal: [0,-1,0] },
            front: { verts: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]], normal: [0,0,1] },
            back: { verts: [[1,0,0],[1,1,0],[0,1,0],[0,0,0]], normal: [0,0,-1] },
            right: { verts: [[1,0,1],[1,1,1],[1,1,0],[1,0,0]], normal: [1,0,0] },
            left: { verts: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]], normal: [-1,0,0] }
        };
        
        const f = faceData[face];
        const indices = [0, 1, 2, 0, 2, 3];
        
        for (const i of indices) {
            positions.push(x + f.verts[i][0], y + f.verts[i][1], z + f.verts[i][2]);
            colors.push(c.r, c.g, c.b);
            normals.push(...f.normal);
        }
    };
    
    for (const [key, blockType] of Object.entries(chunk.blocks)) {
        const [x, y, z] = key.split(',').map(Number);
        const worldX = cx * CHUNK_SIZE + x;
        const worldZ = cz * CHUNK_SIZE + z;
        const color = BLOCK_TYPES[blockType].color;
        
        // Check each face
        if (!getBlock(worldX, y + 1, worldZ)) addFace(worldX, y, worldZ, 'top', color);
        if (!getBlock(worldX, y - 1, worldZ)) addFace(worldX, y, worldZ, 'bottom', color);
        if (!getBlock(worldX, y, worldZ + 1)) addFace(worldX, y, worldZ, 'front', color);
        if (!getBlock(worldX, y, worldZ - 1)) addFace(worldX, y, worldZ, 'back', color);
        if (!getBlock(worldX + 1, y, worldZ)) addFace(worldX, y, worldZ, 'right', color);
        if (!getBlock(worldX - 1, y, worldZ)) addFace(worldX, y, worldZ, 'left', color);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
    
    const material = new THREE.MeshBasicMaterial({ vertexColors: true });
    chunk.mesh = new THREE.Mesh(geometry, material);
    scene.add(chunk.mesh);
}

function getBlock(x, y, z) {
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const chunk = world[`${cx},${cz}`];
    if (!chunk) return null;
    
    const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    
    return chunk.blocks[`${lx},${y},${lz}`];
}

function setBlock(x, y, z, type) {
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const chunk = world[`${cx},${cz}`];
    if (!chunk) return;
    
    const lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    
    if (type === null) {
        delete chunk.blocks[`${lx},${y},${lz}`];
    } else {
        chunk.blocks[`${lx},${y},${lz}`] = type;
    }
    
    buildChunkMesh(cx, cz);
    // Rebuild adjacent chunks if on edge
    if (lx === 0) buildChunkMesh(cx - 1, cz);
    if (lx === CHUNK_SIZE - 1) buildChunkMesh(cx + 1, cz);
    if (lz === 0) buildChunkMesh(cx, cz - 1);
    if (lz === CHUNK_SIZE - 1) buildChunkMesh(cx, cz + 1);
}

function setupControls() {
    document.addEventListener('keydown', (e) => keys[e.code] = true);
    document.addEventListener('keyup', (e) => keys[e.code] = false);
    
    document.addEventListener('mousemove', (e) => {
        if (!isLocked) return;
        camera.rotation.y -= e.movementX * 0.002;
        camera.rotation.x -= e.movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
    });
    
    document.addEventListener('click', (e) => {
        if (!isLocked) return;
        if (e.button === 0) raycastAction('break');
    });
    
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (isLocked) raycastAction('place');
    });
    
    document.querySelectorAll('.block-slot').forEach((slot, i) => {
        slot.addEventListener('click', () => selectBlock(i));
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key >= '1' && e.key <= '6') selectBlock(parseInt(e.key) - 1);
    });
    
    document.getElementById('start-btn').addEventListener('click', startGame);
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function selectBlock(index) {
    selectedBlock = index;
    document.querySelectorAll('.block-slot').forEach((slot, i) => {
        slot.classList.toggle('selected', i === index);
    });
}

function startGame() {
    document.getElementById('instructions').style.display = 'none';
    renderer.domElement.requestPointerLock();
    isLocked = true;
    
    document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === renderer.domElement;
        if (!isLocked) {
            document.getElementById('instructions').style.display = 'block';
        }
    });
}

function raycastAction(action) {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    
    const dir = raycaster.ray.direction;
    const pos = camera.position.clone();
    
    for (let t = 0; t < 6; t += 0.1) {
        const x = Math.floor(pos.x + dir.x * t);
        const y = Math.floor(pos.y + dir.y * t);
        const z = Math.floor(pos.z + dir.z * t);
        
        if (getBlock(x, y, z) !== undefined && getBlock(x, y, z) !== null) {
            if (action === 'break') {
                setBlock(x, y, z, null);
            } else if (action === 'place') {
                const px = Math.floor(pos.x + dir.x * (t - 0.1));
                const py = Math.floor(pos.y + dir.y * (t - 0.1));
                const pz = Math.floor(pos.z + dir.z * (t - 0.1));
                if (getBlock(px, py, pz) === undefined || getBlock(px, py, pz) === null) {
                    setBlock(px, py, pz, selectedBlock);
                }
            }
            break;
        }
    }
}

function checkCollision(x, y, z) {
    const margin = 0.3;
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            for (let dz = -1; dz <= 1; dz++) {
                const bx = Math.floor(x + dx * margin);
                const by = Math.floor(y + dy * margin);
                const bz = Math.floor(z + dz * margin);
                if (getBlock(bx, by, bz) !== undefined && getBlock(bx, by, bz) !== null) {
                    return true;
                }
            }
        }
    }
    return false;
}

function animate() {
    requestAnimationFrame(animate);
    
    const now = performance.now();
    const delta = (now - lastTime) / 1000;
    lastTime = now;
    
    frameCount++;
    if (frameCount % 30 === 0) {
        fps = Math.round(1 / delta);
        document.getElementById('fps').textContent = fps;
    }
    
    if (isLocked) {
        // Movement
        const speed = 5;
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        
        let moveX = 0, moveZ = 0;
        if (keys['KeyW']) { moveX += forward.x; moveZ += forward.z; }
        if (keys['KeyS']) { moveX -= forward.x; moveZ -= forward.z; }
        if (keys['KeyA']) { moveX -= right.x; moveZ -= right.z; }
        if (keys['KeyD']) { moveX += right.x; moveZ += right.z; }
        
        const newX = player.x + moveX * speed * delta;
        const newZ = player.z + moveZ * speed * delta;
        
        if (!checkCollision(newX, player.y, player.z)) player.x = newX;
        if (!checkCollision(player.x, player.y, newZ)) player.z = newZ;
        
        // Gravity
        player.vy -= 20 * delta;
        const newY = player.y + player.vy * delta;
        
        if (checkCollision(player.x, newY - 1.5, player.z)) {
            player.vy = 0;
            player.onGround = true;
        } else {
            player.y = newY;
            player.onGround = false;
        }
        
        // Jump
        if (keys['Space'] && player.onGround) {
            player.vy = 8;
            player.onGround = false;
        }
        
        camera.position.set(player.x, player.y, player.z);
    }
    
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>