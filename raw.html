<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Playable Minecraft</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
        font-family: 'Courier New', monospace; 
        overflow: hidden;
        background: #1a1a2e;
    }
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
    }
    .title {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2rem;
        color: #4CAF50;
        text-shadow: 4px 4px 0 #2E7D32, -2px -2px 0 #81C784;
        z-index: 100;
        letter-spacing: 4px;
        pointer-events: none;
    }
    .controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-size: 0.9rem;
        text-shadow: 1px 1px 2px #000;
        z-index: 100;
        text-align: center;
        pointer-events: none;
        background: rgba(0,0,0,0.5);
        padding: 10px 20px;
        border-radius: 10px;
    }
    .crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        z-index: 200;
        pointer-events: none;
    }
    .crosshair::before, .crosshair::after {
        content: '';
        position: absolute;
        background: white;
        mix-blend-mode: difference;
    }
    .crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
        top: 0;
    }
    .crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
        left: 0;
    }
    .hotbar {
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 4px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        padding: 8px;
        border-radius: 8px;
    }
    .hotbar-slot {
        width: 50px;
        height: 50px;
        background: rgba(139,139,139,0.5);
        border: 3px solid #555;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
    }
    .hotbar-slot.selected {
        border-color: #fff;
        background: rgba(255,255,255,0.3);
    }
    .start-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        color: white;
    }
    .start-btn {
        padding: 20px 60px;
        font-size: 24px;
        background: #4CAF50;
        border: none;
        color: white;
        cursor: pointer;
        font-family: 'Courier New', monospace;
        margin-top: 20px;
        transition: transform 0.2s;
    }
    .start-btn:hover {
        transform: scale(1.1);
        background: #66BB6A;
    }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div class="crosshair"></div>
<h1 class="title">PLAYABLE MINECRAFT</h1>
<div class="hotbar">
<div class="hotbar-slot selected" data-block="grass">üü©</div>
<div class="hotbar-slot" data-block="dirt">üü´</div>
<div class="hotbar-slot" data-block="stone">‚¨ú</div>
<div class="hotbar-slot" data-block="wood">ü™µ</div>
<div class="hotbar-slot" data-block="leaves">üåø</div>
<div class="hotbar-slot" data-block="burger">üçî</div>
</div>
<p class="controls">WASD: Move | SPACE: Jump | MOUSE: Look | LEFT CLICK: Break | RIGHT CLICK: Place | 1-5: Select Block</p>
<div class="start-screen" id="startScreen">
<h1 style="font-size: 3rem; color: #4CAF50; text-shadow: 4px 4px 0 #2E7D32;">MINECRAFT</h1>
<p style="margin-top: 10px; font-size: 1.2rem;">Click to play!</p>
<button class="start-btn" id="startBtn">PLAY</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    let isPlaying = false;
    let selectedBlock = 'grass';
    const blocks = [];
    const blockMap = new Map();
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 30, 100);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Player physics
    const player = {
        velocity: new THREE.Vector3(),
        onGround: false,
        height: 1.8,
        speed: 0.15,
        jumpForce: 0.25
    };

    // Controls
    const keys = {};
    let yaw = 0;
    let pitch = 0;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xFFD700, 1);
    sunLight.position.set(10, 20, 10);
    sunLight.castShadow = true;
    scene.add(sunLight);

    // Texture creator
    function createPixelTexture(color1, color2) {
        const canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        const ctx = canvas.getContext('2d');
        for (let x = 0; x < 16; x++) {
            for (let y = 0; y < 16; y++) {
                ctx.fillStyle = Math.random() > 0.5 ? color1 : color2;
                ctx.fillRect(x, y, 1, 1);
            }
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        return texture;
    }

    // Materials
    const materials = {
        grass: [
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#6D4C41') }),
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#6D4C41') }),
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#4CAF50', '#66BB6A') }),
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#5D4037') }),
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#6D4C41') }),
            new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#6D4C41') })
        ],
        dirt: new THREE.MeshLambertMaterial({ map: createPixelTexture('#8D6E63', '#5D4037') }),
        stone: new THREE.MeshLambertMaterial({ map: createPixelTexture('#9E9E9E', '#757575') }),
        wood: new THREE.MeshLambertMaterial({ map: createPixelTexture('#5D4037', '#4E342E') }),
        leaves: new THREE.MeshLambertMaterial({ map: createPixelTexture('#2E7D32', '#388E3C'), transparent: true, opacity: 0.9 }),
        burger: new THREE.MeshLambertMaterial({ map: createPixelTexture('#D4A574', '#8B4513') })
    };

    function getBlockKey(x, y, z) {
        return `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
    }

    function createBlock(x, y, z, type) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const mat = type === 'grass' ? materials.grass : materials[type];
        const block = new THREE.Mesh(geometry, mat);
        block.position.set(Math.round(x), Math.round(y), Math.round(z));
        block.castShadow = true;
        block.receiveShadow = true;
        block.userData.type = type;
        scene.add(block);
        blocks.push(block);
        blockMap.set(getBlockKey(x, y, z), block);
        return block;
    }

    function removeBlock(block) {
        const key = getBlockKey(block.position.x, block.position.y, block.position.z);
        blockMap.delete(key);
        const index = blocks.indexOf(block);
        if (index > -1) blocks.splice(index, 1);
        scene.remove(block);
    }

    // Generate terrain
    const worldSize = 20;
    for (let x = -worldSize/2; x < worldSize/2; x++) {
        for (let z = -worldSize/2; z < worldSize/2; z++) {
            createBlock(x, 0, z, 'grass');
            for (let y = -1; y > -3; y--) {
                createBlock(x, y, z, 'dirt');
            }
            createBlock(x, -3, z, 'stone');
        }
    }

    // Trees
    function createTree(x, z) {
        for (let y = 1; y <= 4; y++) createBlock(x, y, z, 'wood');
        for (let lx = -2; lx <= 2; lx++) {
            for (let lz = -2; lz <= 2; lz++) {
                for (let ly = 4; ly <= 6; ly++) {
                    if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly - 5) < 4) {
                        createBlock(x + lx, ly, z + lz, 'leaves');
                    }
                }
            }
        }
    }
    createTree(-4, -4);
    createTree(5, 3);
    createTree(-2, 5);

    // Giant floating cheeseburger!
    const burgerGroup = new THREE.Group();
    
    // Bottom bun
    const bunGeom = new THREE.CylinderGeometry(1.5, 1.8, 0.5, 32);
    const bunMat = new THREE.MeshLambertMaterial({ color: 0xD4A574 });
    const bottomBun = new THREE.Mesh(bunGeom, bunMat);
    bottomBun.position.y = 0;
    burgerGroup.add(bottomBun);
    
    // Patty
    const pattyGeom = new THREE.CylinderGeometry(1.4, 1.4, 0.4, 32);
    const pattyMat = new THREE.MeshLambertMaterial({ color: 0x4A2C2A });
    const patty = new THREE.Mesh(pattyGeom, pattyMat);
    patty.position.y = 0.45;
    burgerGroup.add(patty);
    
    // Cheese
    const cheeseGeom = new THREE.BoxGeometry(2.2, 0.1, 2.2);
    const cheeseMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
    const cheese = new THREE.Mesh(cheeseGeom, cheeseMat);
    cheese.position.y = 0.7;
    cheese.rotation.y = Math.PI / 4;
    burgerGroup.add(cheese);
    
    // Lettuce
    const lettuceGeom = new THREE.CylinderGeometry(1.6, 1.6, 0.15, 32);
    const lettuceMat = new THREE.MeshLambertMaterial({ color: 0x66BB6A });
    const lettuce = new THREE.Mesh(lettuceGeom, lettuceMat);
    lettuce.position.y = 0.85;
    burgerGroup.add(lettuce);
    
    // Top bun
    const topBunGeom = new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
    const topBun = new THREE.Mesh(topBunGeom, bunMat);
    topBun.position.y = 1;
    burgerGroup.add(topBun);
    
    // Sesame seeds
    const seedGeom = new THREE.SphereGeometry(0.08, 8, 8);
    const seedMat = new THREE.MeshLambertMaterial({ color: 0xFFF8DC });
    for (let i = 0; i < 12; i++) {
        const seed = new THREE.Mesh(seedGeom, seedMat);
        const angle = (i / 12) * Math.PI * 2;
        const radius = 0.8 + Math.random() * 0.5;
        seed.position.set(Math.cos(angle) * radius, 1.3 + Math.random() * 0.2, Math.sin(angle) * radius);
        burgerGroup.add(seed);
    }
    
    burgerGroup.position.set(8, 6, -5);
    scene.add(burgerGroup);
    
    // Animate the burger
    function animateBurger() {
        burgerGroup.rotation.y += 0.01;
        burgerGroup.position.y = 6 + Math.sin(Date.now() * 0.002) * 0.5;
    }

    // Sun
    const sun = new THREE.Mesh(
        new THREE.SphereGeometry(2, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xFFD700 })
    );
    sun.position.set(20, 25, -20);
    scene.add(sun);

    // Raycaster for block interaction
    const raycaster = new THREE.Raycaster();
    raycaster.far = 6;

    // Start game
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('startScreen').style.display = 'none';
        renderer.domElement.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
        isPlaying = document.pointerLockElement === renderer.domElement;
    });

    // Mouse look
    document.addEventListener('mousemove', (e) => {
        if (!isPlaying) return;
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if (e.code >= 'Digit1' && e.code <= 'Digit6') {
            const idx = parseInt(e.code.replace('Digit', '')) - 1;
            document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
                slot.classList.toggle('selected', i === idx);
                if (i === idx) selectedBlock = slot.dataset.block;
            });
        }
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    // Mouse click for blocks
    document.addEventListener('mousedown', (e) => {
        if (!isPlaying) return;
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(blocks);
        
        if (e.button === 0 && intersects.length > 0) {
            // Break block
            removeBlock(intersects[0].object);
        } else if (e.button === 2 && intersects.length > 0) {
            // Place block
            const hit = intersects[0];
            const normal = hit.face.normal;
            const pos = hit.object.position.clone().add(normal);
            if (!blockMap.has(getBlockKey(pos.x, pos.y, pos.z))) {
                createBlock(pos.x, pos.y, pos.z, selectedBlock);
            }
        }
    });

    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Hotbar clicks
    document.querySelectorAll('.hotbar-slot').forEach(slot => {
        slot.addEventListener('click', () => {
            document.querySelectorAll('.hotbar-slot').forEach(s => s.classList.remove('selected'));
            slot.classList.add('selected');
            selectedBlock = slot.dataset.block;
        });
    });

    // Collision detection
    function checkCollision(pos) {
        const checkPoints = [
            [0.3, 0, 0.3], [-0.3, 0, 0.3], [0.3, 0, -0.3], [-0.3, 0, -0.3],
            [0.3, -1, 0.3], [-0.3, -1, 0.3], [0.3, -1, -0.3], [-0.3, -1, -0.3]
        ];
        for (const [dx, dy, dz] of checkPoints) {
            const key = getBlockKey(pos.x + dx, pos.y + dy, pos.z + dz);
            if (blockMap.has(key)) return true;
        }
        return false;
    }

    function checkGround(pos) {
        const key = getBlockKey(pos.x, pos.y - 1.6, pos.z);
        return blockMap.has(key);
    }

    // Game loop
    function animate() {
        requestAnimationFrame(animate);

        if (isPlaying) {
            // Camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            // Movement
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0)));
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0)));

            const moveDir = new THREE.Vector3();
            if (keys['KeyW']) moveDir.add(forward);
            if (keys['KeyS']) moveDir.sub(forward);
            if (keys['KeyD']) moveDir.add(right);
            if (keys['KeyA']) moveDir.sub(right);
            moveDir.normalize().multiplyScalar(player.speed);

            // Apply horizontal movement with collision
            const newPosX = camera.position.clone();
            newPosX.x += moveDir.x;
            if (!checkCollision(newPosX)) camera.position.x = newPosX.x;

            const newPosZ = camera.position.clone();
            newPosZ.z += moveDir.z;
            if (!checkCollision(newPosZ)) camera.position.z = newPosZ.z;

            // Gravity and jumping
            player.onGround = checkGround(camera.position);
            
            if (keys['Space'] && player.onGround) {
                player.velocity.y = player.jumpForce;
            }

            if (!player.onGround) {
                player.velocity.y -= 0.015; // Gravity
            } else {
                player.velocity.y = Math.max(0, player.velocity.y);
            }

            const newPosY = camera.position.clone();
            newPosY.y += player.velocity.y;
            if (newPosY.y > 1.5 || !checkCollision(newPosY)) {
                camera.position.y += player.velocity.y;
            } else {
                player.velocity.y = 0;
            }

            // Prevent falling below world
            if (camera.position.y < -10) {
                camera.position.set(0, 5, 5);
                player.velocity.set(0, 0, 0);
            }
        }

        if (typeof animateBurger === 'function') animateBurger();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>