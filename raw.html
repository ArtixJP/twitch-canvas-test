<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>‚ú® Minecraft World + Pokemon Battle ‚ú®</title>
<style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
        min-height: 100vh;
        background: #87CEEB;
        font-family: 'Segoe UI', system-ui, sans-serif;
        color: #fff;
        overflow: hidden;
    }
    
    #gameContainer {
        width: 100vw;
        height: 100vh;
        position: relative;
    }
    
    #instructions {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        max-width: 250px;
    }
    
    #instructions h3 {
        color: #4facfe;
        margin-bottom: 10px;
    }
    
    #instructions p {
        margin: 5px 0;
        color: #ccc;
    }
    
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 100;
    }
    
    #crosshair::before, #crosshair::after {
        content: '';
        position: absolute;
        background: white;
        box-shadow: 0 0 3px black;
    }
    
    #crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
    }
    
    #crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
    }
    
    .stats {
        position: fixed;
        bottom: 10px;
        left: 10px;
        display: flex;
        gap: 1rem;
        z-index: 100;
    }
    
    .stat {
        background: rgba(0,0,0,0.7);
        padding: 10px 15px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.2);
    }
    
    .stat-value {
        font-size: 1.2rem;
        color: #4facfe;
        font-weight: bold;
    }
    
    .stat-label {
        font-size: 0.7rem;
        color: #888;
    }
    
    #blockSelector {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 5px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 10px;
        z-index: 100;
    }
    
    .block-option {
        width: 40px;
        height: 40px;
        border: 2px solid #555;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .block-option.selected {
        border-color: #fff;
        transform: scale(1.1);
    }
    
    .block-option:hover {
        border-color: #aaa;
    }
</style>
</head>
<body>
<div id="gameContainer"></div>
<div id="crosshair"></div>
<div id="instructions">
<h3>üéÆ Minecraft + Pokemon!</h3>
<p>üñ±Ô∏è Click to lock mouse</p>
<p>‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è or WASD - Move</p>
<p>Mouse - Look around</p>
<p>Space - Jump</p>
<p>M - Place block</p>
<p>Left Click - Break block</p>
<p>1-5 - Select block type</p>
<p>üêæ Pokemon roam freely!</p>
</div>
<div class="stats">
<div class="stat">
<div class="stat-value" id="clicks">0</div>
<div class="stat-label">Blocks Placed</div>
</div>
<div class="stat">
<div class="stat-value" id="shapes">0</div>
<div class="stat-label">Blocks Broken</div>
</div>
</div>
<div id="blockSelector">
<div class="block-option selected" data-block="0" style="background: #8B4513;"></div>
<div class="block-option" data-block="1" style="background: #228B22;"></div>
<div class="block-option" data-block="2" style="background: #808080;"></div>
<div class="block-option" data-block="3" style="background: #FFD700;"></div>
<div class="block-option" data-block="4" style="background: #4169E1;"></div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Stats
    let blocksPlaced = 0;
    
    // Pokemon storage
    const pokemons = [];
    const pokemonTypes = [
        { name: 'Pikachu', color: 0xFFD700, size: 1.5, speed: 3 },
        { name: 'Bulbasaur', color: 0x228B22, size: 1.8, speed: 2 },
        { name: 'Charmander', color: 0xFF4500, size: 1.6, speed: 2.5 },
        { name: 'Squirtle', color: 0x1E90FF, size: 1.5, speed: 2 },
        { name: 'Eevee', color: 0xD2691E, size: 1.4, speed: 3.5 },
        { name: 'Jigglypuff', color: 0xFFB6C1, size: 1.3, speed: 1.5 }
    ];
    let blocksBroken = 0;
    const clicksEl = document.getElementById('clicks');
    const shapesEl = document.getElementById('shapes');
    
    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 20);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('gameContainer').appendChild(renderer.domElement);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    scene.add(sunLight);
    
    // Block types
    const blockColors = [0x8B4513, 0x228B22, 0x808080, 0xFFD700, 0x4169E1];
    let selectedBlock = 0;
    
    // World blocks storage
    const blocks = new Map();
    const blockSize = 2;
    
    function getBlockKey(x, y, z) {
        return `${Math.floor(x/blockSize)},${Math.floor(y/blockSize)},${Math.floor(z/blockSize)}`;
    }
    
    function createBlock(x, y, z, colorIndex = 0) {
        const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const material = new THREE.MeshLambertMaterial({ 
            color: blockColors[colorIndex],
            flatShading: true
        });
        const block = new THREE.Mesh(geometry, material);
        block.position.set(
            Math.floor(x/blockSize) * blockSize + blockSize/2,
            Math.floor(y/blockSize) * blockSize + blockSize/2,
            Math.floor(z/blockSize) * blockSize + blockSize/2
        );
        block.castShadow = true;
        block.receiveShadow = true;
        return block;
    }
    
    // Generate terrain
    for (let x = -20; x < 20; x++) {
        for (let z = -20; z < 20; z++) {
            const height = Math.floor(Math.sin(x * 0.1) * 2 + Math.cos(z * 0.1) * 2);
            for (let y = -2; y <= height; y++) {
                const colorIndex = y === height ? 1 : (y < height - 2 ? 2 : 0);
                const block = createBlock(x * blockSize, y * blockSize, z * blockSize, colorIndex);
                scene.add(block);
                blocks.set(getBlockKey(x * blockSize, y * blockSize, z * blockSize), block);
            }
        }
    }
    
    // Create Pokemon
    function createPokemon(type, x, z) {
        const pokemon = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.SphereGeometry(type.size * 0.5, 8, 8);
        const bodyMat = new THREE.MeshLambertMaterial({ color: type.color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        pokemon.add(body);
        
        // Head
        const headGeo = new THREE.SphereGeometry(type.size * 0.35, 8, 8);
        const head = new THREE.Mesh(headGeo, bodyMat);
        head.position.y = type.size * 0.5;
        head.castShadow = true;
        pokemon.add(head);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(type.size * 0.1, 6, 6);
        const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-type.size * 0.15, type.size * 0.55, type.size * 0.25);
        pokemon.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(type.size * 0.15, type.size * 0.55, type.size * 0.25);
        pokemon.add(rightEye);
        
        // Ears/features based on type
        if (type.name === 'Pikachu') {
            const earGeo = new THREE.ConeGeometry(type.size * 0.15, type.size * 0.5, 4);
            const earMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const leftEar = new THREE.Mesh(earGeo, earMat);
            leftEar.position.set(-type.size * 0.2, type.size * 0.9, 0);
            leftEar.rotation.z = 0.3;
            pokemon.add(leftEar);
            const rightEar = new THREE.Mesh(earGeo, earMat);
            rightEar.position.set(type.size * 0.2, type.size * 0.9, 0);
            rightEar.rotation.z = -0.3;
            pokemon.add(rightEar);
        }
        
        pokemon.position.set(x, 5, z);
        pokemon.userData = {
            type: type,
            targetX: x,
            targetZ: z,
            moveTimer: Math.random() * 3
        };
        
        scene.add(pokemon);
        pokemons.push(pokemon);
        return pokemon;
    }
    
    // Spawn initial Pokemon
    for (let i = 0; i < 15; i++) {
        const type = pokemonTypes[Math.floor(Math.random() * pokemonTypes.length)];
        const x = (Math.random() - 0.5) * 60;
        const z = (Math.random() - 0.5) * 60;
        createPokemon(type, x, z);
    }
    
    // Player controls
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = true;
    let isLocked = false;
    
    // Euler for camera rotation
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    
    // Pointer lock
    renderer.domElement.addEventListener('click', () => {
        if (!isLocked) {
            renderer.domElement.requestPointerLock();
        }
    });
    
    document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === renderer.domElement;
    });
    
    // Mouse movement
    document.addEventListener('mousemove', (e) => {
        if (!isLocked) return;
        
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= e.movementX * 0.002;
        euler.x -= e.movementY * 0.002;
        euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
        camera.quaternion.setFromEuler(euler);
    });
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
            case 'Space':
                if (canJump) {
                    velocity.y = 15;
                    canJump = false;
                }
                break;
            case 'KeyM': placeBlock(); break;
            case 'Digit1': selectBlock(0); break;
            case 'Digit2': selectBlock(1); break;
            case 'Digit3': selectBlock(2); break;
            case 'Digit4': selectBlock(3); break;
            case 'Digit5': selectBlock(4); break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
    });
    
    // Block selection UI
    document.querySelectorAll('.block-option').forEach(el => {
        el.addEventListener('click', () => {
            selectBlock(parseInt(el.dataset.block));
        });
    });
    
    function selectBlock(index) {
        selectedBlock = index;
        document.querySelectorAll('.block-option').forEach((el, i) => {
            el.classList.toggle('selected', i === index);
        });
    }
    
    // Raycaster for block interaction
    const raycaster = new THREE.Raycaster();
    raycaster.far = 20;
    
    function placeBlock() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children);
        
        if (intersects.length > 0) {
            const hit = intersects[0];
            const normal = hit.face.normal;
            const pos = hit.point.clone().add(normal.multiplyScalar(blockSize/2));
            
            const key = getBlockKey(pos.x, pos.y, pos.z);
            if (!blocks.has(key)) {
                const block = createBlock(pos.x, pos.y, pos.z, selectedBlock);
                scene.add(block);
                blocks.set(key, block);
                blocksPlaced++;
                clicksEl.textContent = blocksPlaced;
            }
        }
    }
    
    // Left click to break
    document.addEventListener('mousedown', (e) => {
        if (!isLocked || e.button !== 0) return;
        
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children);
        
        if (intersects.length > 0) {
            const block = intersects[0].object;
            const key = getBlockKey(block.position.x, block.position.y, block.position.z);
            if (blocks.has(key)) {
                scene.remove(block);
                blocks.delete(key);
                blocksBroken++;
                shapesEl.textContent = blocksBroken;
            }
        }
    });
    
    // Animation loop
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        
        // Movement
        velocity.x *= 0.9;
        velocity.z *= 0.9;
        velocity.y -= 30 * delta; // Gravity
        
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();
        
        if (moveForward || moveBackward) velocity.z -= direction.z * 50 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 50 * delta;
        
        // Apply movement in camera direction
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        
        camera.position.addScaledVector(forward, -velocity.z * delta);
        camera.position.addScaledVector(right, -velocity.x * delta);
        camera.position.y += velocity.y * delta;
        
        // Ground collision
        if (camera.position.y < 5) {
            camera.position.y = 5;
            velocity.y = 0;
            canJump = true;
        }
        
        // Update Pokemon
        pokemons.forEach(pokemon => {
            const data = pokemon.userData;
            data.moveTimer -= delta;
            
            if (data.moveTimer <= 0) {
                data.targetX = pokemon.position.x + (Math.random() - 0.5) * 20;
                data.targetZ = pokemon.position.z + (Math.random() - 0.5) * 20;
                data.targetX = Math.max(-35, Math.min(35, data.targetX));
                data.targetZ = Math.max(-35, Math.min(35, data.targetZ));
                data.moveTimer = 2 + Math.random() * 3;
            }
            
            const dx = data.targetX - pokemon.position.x;
            const dz = data.targetZ - pokemon.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist > 0.5) {
                pokemon.position.x += (dx / dist) * data.type.speed * delta;
                pokemon.position.z += (dz / dist) * data.type.speed * delta;
                pokemon.rotation.y = Math.atan2(dx, dz);
            }
            
            // Bouncy animation
            pokemon.position.y = 5 + Math.sin(Date.now() * 0.005 + pokemon.id) * 0.3;
            
            // Slight rotation animation
            pokemon.children[0].rotation.z = Math.sin(Date.now() * 0.003) * 0.1;
        });
        
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
</script>
</body>
</html>