<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch Minecraft World Builder</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        body { 
            font-family: 'Courier New', monospace; 
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #87CEEB;
            color: white;
        }
        h1 { 
            font-size: 2rem; 
            text-align: center; 
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            margin: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            image-rendering: pixelated;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #object-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.9rem;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border: 3px solid #555;
            image-rendering: pixelated;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 0.8rem;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border: 3px solid #555;
        }
        .mc-button {
            background: linear-gradient(180deg, #7a7a7a 0%, #4a4a4a 50%, #3a3a3a 100%);
            border: 3px solid #1a1a1a;
            border-top-color: #8a8a8a;
            border-left-color: #8a8a8a;
            color: #FFFF55;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #3F3F00;
            cursor: pointer;
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            image-rendering: pixelated;
            transition: transform 0.1s;
        }
        .mc-button:hover {
            background: linear-gradient(180deg, #9a9a9a 0%, #6a6a6a 50%, #5a5a5a 100%);
            transform: translateX(-50%) scale(1.05);
        }
        .mc-button:active {
            transform: translateX(-50%) scale(0.95);
            border-top-color: #3a3a3a;
            border-left-color: #3a3a3a;
            border-bottom-color: #8a8a8a;
            border-right-color: #8a8a8a;
        }
        .minecraft-text {
            color: #FFFF55;
            text-shadow: 2px 2px 0 #3F3F00;
        }
    </style>
</head>
<body>
<div id="game-container">
<h1>‚õèÔ∏è MINECRAFT OCEAN WORLD ‚õèÔ∏è</h1>
<div id="object-count"><span class="minecraft-text">Blocks: 0 | Mobs: 0</span></div>
<button class="mc-button" id="spawn-btn" onclick="spawnRandomBlock()">‚õèÔ∏è SPAWN BLOCK ‚õèÔ∏è</button>
<button class="mc-button" id="yellow-btn" onclick="spawnGoldBlock()" style="top: 110px; background: linear-gradient(180deg, #FFD700 0%, #DAA520 50%, #B8860B 100%); border-color: #8B6914; border-top-color: #FFE55C; border-left-color: #FFE55C; color: #000; text-shadow: 1px 1px 0 #FFE55C;">üåü GOLD BLOCK üåü</button>
<div id="controls">üñ±Ô∏è Drag to rotate | Scroll to zoom</div>
<div id="mario-badge" style="position: absolute; top: 150px; right: 10px; background: rgba(100,100,100,0.5); border: 2px solid #666; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #AAA; font-weight: bold; text-decoration: line-through;">ü™¶ R.I.P. MARIO ü™¶</div>
<div id="bowser-badge" style="position: absolute; top: 190px; right: 10px; background: rgba(255,100,0,0.4); border: 2px solid #FF6600; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFD700; font-weight: bold; animation: bowserRoar 0.5s infinite;">üî• BOWSER WINS! üî•</div>
<style>
@keyframes bowserRoar {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}
</style>
<div id="test-badge" style="position: absolute; top: 100px; right: 10px; background: rgba(0,255,0,0.2); border: 2px dashed #00FF00; padding: 5px 10px; font-size: 0.7rem; z-index: 100; animation: testPulse 1s infinite;">üß™ TEST SIGNAL RECEIVED</div>
<div id="test-echo" style="position: absolute; top: 130px; right: 10px; background: rgba(0,255,255,0.15); border: 1px dotted #00FFFF; padding: 3px 8px; font-size: 0.6rem; z-index: 100; color: #00FFFF; animation: echoFade 2s infinite;">‚Ü™ echo: test confirmed ‚úì</div>
<style>
@keyframes echoFade {
  0%, 100% { opacity: 0.3; transform: translateX(0); }
  50% { opacity: 0.8; transform: translateX(-3px); }
}
</style>
<style>
@keyframes testPulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}
</style>
</div>
<script>
        // Three.js Minecraft World
        let scene, camera, renderer, controls;
        let blocks = [];
        let mobs = [];
        let blockCount = 0;
        let time = 0;
        
        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { x: 0.5, y: 0.3 };
        let cameraDistance = 50;
        
        init();
        animate();
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // Create Minecraft terrain
            createTerrain();
            
            // Add legacy creatures as Minecraft mobs
            createVoxelMario(0, 3, 5);
            createVoxelFish(5, 8, 3);
            createVoxelFish(-8, 10, -5);
            createVoxelFish(12, 6, 8);
            createVoxelShark(0, 4, 0);
            createVoxelWerewolfRabbit(-10, 2, 5);
            createVoxelGreeter(8, 12, -3);
            
            // BOWSER - The King of Koopas who slew Mario!
            createVoxelBowser(5, 3, 8);
            
            // Add trees
            createTree(10, 0, 10);
            
            // TEST BLOCK - A mysterious floating test cube
            const testBlock = createBlock(0, 15, 0, 0x00FF00);
            testBlock.userData = { isTestBlock: true, floatOffset: 0 };
            testBlock.scale.set(1.5, 1.5, 1.5);
            
            // TEST ECHO BLOCK - Orbiting satellite confirming the signal
            const testEcho = createBlock(3, 15, 0, 0x00FFFF);
            testEcho.userData = { isTestEcho: true, orbitAngle: 0 };
            testEcho.scale.set(0.5, 0.5, 0.5);
            createTree(-12, 0, 8);
            createTree(5, 0, -15);
            createTree(-8, 0, -10);
            
            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function createBlockMaterial(color) {
            return new THREE.MeshLambertMaterial({ 
                color: color,
                flatShading: true
            });
        }
        
        function createBlock(x, y, z, color, size = 1) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = createBlockMaterial(color);
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.push(block);
            blockCount++;
            return block;
        }
        
        function createTerrain() {
            // Grass layer
            for (let x = -20; x <= 20; x++) {
                for (let z = -20; z <= 20; z++) {
                    const height = Math.floor(Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2);
                    createBlock(x, height, z, 0x4CAF50); // Grass
                    // Dirt below
                    for (let y = height - 1; y >= height - 2; y--) {
                        createBlock(x, y, z, 0x8B4513); // Dirt
                    }
                    // Stone deep below
                    createBlock(x, height - 3, z, 0x808080);
                }
            }
            
            // THE GREAT SEA - Vast ocean surrounding the island
            const seaBlocks = [];
            for (let x = -30; x <= 30; x++) {
                for (let z = -30; z <= 30; z++) {
                    // Create sea around the island (leave center as land)
                    const distFromCenter = Math.sqrt(x*x + z*z);
                    if (distFromCenter > 12) {
                        // Deep ocean - multiple layers
                        for (let depth = 0; depth >= -4; depth--) {
                            const waterBlock = createBlock(x, depth, z, depth === 0 ? 0x1E90FF : 0x0066CC);
                            waterBlock.material.transparent = true;
                            waterBlock.material.opacity = depth === 0 ? 0.6 : 0.8;
                            waterBlock.userData = { isWater: true, baseY: depth, waveOffset: x * 0.5 + z * 0.3 };
                            seaBlocks.push(waterBlock);
                        }
                        // Sandy ocean floor
                        createBlock(x, -5, z, 0xC2B280);
                    } else if (distFromCenter > 8) {
                        // Shallow beach water
                        const waterBlock = createBlock(x, 0, z, 0x40E0D0);
                        waterBlock.material.transparent = true;
                        waterBlock.material.opacity = 0.5;
                        waterBlock.userData = { isWater: true, baseY: 0, waveOffset: x * 0.5 + z * 0.3 };
                        seaBlocks.push(waterBlock);
                    }
                }
            }
            
            // Store sea blocks for wave animation
            window.seaBlocks = seaBlocks;
            
            // Add coral and seaweed decorations
            const coralColors = [0xFF6B6B, 0xFF69B4, 0xFFA500, 0x9370DB];
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 15 + Math.random() * 10;
                const cx = Math.cos(angle) * dist;
                const cz = Math.sin(angle) * dist;
                const coral = createBlock(cx, -4, cz, coralColors[Math.floor(Math.random() * coralColors.length)]);
                coral.scale.set(0.5 + Math.random() * 0.5, 1 + Math.random() * 2, 0.5 + Math.random() * 0.5);
            }
            
            // Seaweed patches
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 14 + Math.random() * 12;
                const sx = Math.cos(angle) * dist;
                const sz = Math.sin(angle) * dist;
                for (let h = 0; h < 3 + Math.floor(Math.random() * 3); h++) {
                    const seaweed = createBlock(sx, -4 + h, sz, 0x228B22);
                    seaweed.scale.set(0.3, 1, 0.3);
                    seaweed.userData = { isSeaweed: true, swayOffset: i + h };
                }
            }
        }
        
        function createTree(x, baseY, z) {
            // Trunk
            for (let y = 1; y <= 5; y++) {
                createBlock(x, baseY + y, z, 0x8B4513);
            }
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 0; ly <= 2; ly++) {
                        if (Math.abs(lx) + Math.abs(lz) + ly < 4) {
                            createBlock(x + lx, baseY + 5 + ly, z + lz, 0x228B22);
                        }
                    }
                }
            }
        }
        
        function createVoxelFish(x, y, z) {
            const fish = new THREE.Group();
            
            // Body (cyan/blue blocks)
            const colors = [0x00CED1, 0x40E0D0, 0x48D1CC];
            const bodyColor = colors[Math.floor(Math.random() * colors.length)];
            
            for (let i = 0; i < 4; i++) {
                const block = createBlock(0, 0, 0, bodyColor);
                block.position.set(i - 1.5, 0, 0);
                fish.add(block);
            }
            // Tail
            const tail = createBlock(0, 0, 0, bodyColor);
            tail.position.set(-2.5, 0.5, 0);
            tail.scale.set(0.5, 0.5, 0.5);
            fish.add(tail);
            
            // Eye
            const eye = createBlock(0, 0, 0, 0xFFFFFF);
            eye.position.set(1.5, 0.3, 0.5);
            eye.scale.set(0.3, 0.3, 0.3);
            fish.add(eye);
            
            // Fins (wings)
            const fin1 = createBlock(0, 0, 0, 0x87CEEB);
            fin1.position.set(0, 1, 0);
            fin1.scale.set(1.5, 0.2, 0.5);
            fish.add(fin1);
            
            fish.position.set(x, y, z);
            fish.userData = { type: 'fish', vx: (Math.random() - 0.5) * 0.1, vy: 0, baseY: y };
            scene.add(fish);
            mobs.push(fish);
        }
        
        function createVoxelShark(x, y, z) {
            const shark = new THREE.Group();
            
            // Body (gray blocks)
            for (let i = 0; i < 6; i++) {
                const block = createBlock(0, 0, 0, 0x708090);
                block.position.set(i - 2.5, 0, 0);
                shark.add(block);
            }
            // Dorsal fin
            const fin = createBlock(0, 0, 0, 0x5F6A6A);
            fin.position.set(0, 1, 0);
            fin.scale.set(0.5, 1, 0.3);
            shark.add(fin);
            
            // Tail
            const tail = createBlock(0, 0, 0, 0x5F6A6A);
            tail.position.set(-3.5, 0.5, 0);
            tail.scale.set(0.5, 1.5, 0.3);
            shark.add(tail);
            
            // Teeth (white blocks)
            for (let i = 0; i < 3; i++) {
                const tooth = createBlock(0, 0, 0, 0xFFFFFF);
                tooth.position.set(3 + i * 0.2, -0.3, 0.3);
                tooth.scale.set(0.15, 0.3, 0.15);
                shark.add(tooth);
            }
            
            // Red eye
            const eye = createBlock(0, 0, 0, 0xFF0000);
            eye.position.set(2.5, 0.3, 0.5);
            eye.scale.set(0.25, 0.25, 0.25);
            shark.add(eye);
            
            shark.position.set(x, y, z);
            shark.userData = { type: 'shark', vx: (Math.random() - 0.5) * 0.05, angle: 0 };
            scene.add(shark);
            mobs.push(shark);
        }
        
        function createVoxelWerewolfRabbit(x, y, z) {
            const werewolf = new THREE.Group();
            
            // Body (dark purple)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    const block = createBlock(0, 0, 0, 0x2D1B36);
                    block.position.set(i - 1, j, 0);
                    werewolf.add(block);
                }
            }
            
            // Head
            const head = createBlock(0, 0, 0, 0x3D2B46);
            head.position.set(1.5, 2, 0);
            werewolf.add(head);
            
            // Ears (tall and pointy)
            const ear1 = createBlock(0, 0, 0, 0x3D2B46);
            ear1.position.set(1.2, 3.5, 0.3);
            ear1.scale.set(0.3, 1.5, 0.3);
            werewolf.add(ear1);
            
            const ear2 = createBlock(0, 0, 0, 0x3D2B46);
            ear2.position.set(1.8, 3.5, 0.3);
            ear2.scale.set(0.3, 1.5, 0.3);
            werewolf.add(ear2);
            
            // Glowing red eyes
            const eye1 = createBlock(0, 0, 0, 0xFF0000);
            eye1.position.set(1.8, 2.2, 0.5);
            eye1.scale.set(0.2, 0.2, 0.2);
            werewolf.add(eye1);
            
            const eye2 = createBlock(0, 0, 0, 0xFF0000);
            eye2.position.set(2.1, 2.2, 0.5);
            eye2.scale.set(0.2, 0.2, 0.2);
            werewolf.add(eye2);
            
            // Fangs
            const fang1 = createBlock(0, 0, 0, 0xFFFFFF);
            fang1.position.set(2, 1.7, 0.5);
            fang1.scale.set(0.1, 0.3, 0.1);
            werewolf.add(fang1);
            
            // Legs
            const leg1 = createBlock(0, 0, 0, 0x2D1B36);
            leg1.position.set(-0.5, -1, 0.3);
            leg1.scale.set(0.4, 1, 0.4);
            werewolf.add(leg1);
            
            const leg2 = createBlock(0, 0, 0, 0x2D1B36);
            leg2.position.set(0.5, -1, 0.3);
            leg2.scale.set(0.4, 1, 0.4);
            werewolf.add(leg2);
            
            werewolf.position.set(x, y, z);
            werewolf.userData = { type: 'werewolf', vx: (Math.random() - 0.5) * 0.03, howlTime: 0 };
            scene.add(werewolf);
            mobs.push(werewolf);
        }
        
        function createVoxelMario(x, y, z) {
            const mario = new THREE.Group();
            
            // Red cap
            const cap1 = createBlock(0, 0, 0, 0xFF0000);
            cap1.position.set(0, 3.5, 0);
            mario.add(cap1);
            const cap2 = createBlock(0, 0, 0, 0xFF0000);
            cap2.position.set(0.5, 3.5, 0);
            cap2.scale.set(0.5, 0.5, 1);
            mario.add(cap2);
            const capBrim = createBlock(0, 0, 0, 0xFF0000);
            capBrim.position.set(0.8, 3, 0);
            capBrim.scale.set(0.5, 0.3, 1);
            mario.add(capBrim);
            
            // Face (skin color)
            const face = createBlock(0, 0, 0, 0xFFD8B0);
            face.position.set(0, 2.5, 0);
            mario.add(face);
            
            // Mustache
            const mustache = createBlock(0, 0, 0, 0x4A3728);
            mustache.position.set(0.3, 2.3, 0.5);
            mustache.scale.set(0.8, 0.2, 0.2);
            mario.add(mustache);
            
            // Eyes
            const eye1 = createBlock(0, 0, 0, 0x000000);
            eye1.position.set(0.2, 2.7, 0.5);
            eye1.scale.set(0.15, 0.15, 0.15);
            mario.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0x000000);
            eye2.position.set(-0.2, 2.7, 0.5);
            eye2.scale.set(0.15, 0.15, 0.15);
            mario.add(eye2);
            
            // Nose
            const nose = createBlock(0, 0, 0, 0xFFD8B0);
            nose.position.set(0, 2.5, 0.6);
            nose.scale.set(0.4, 0.3, 0.3);
            mario.add(nose);
            
            // Blue overalls body
            const body1 = createBlock(0, 0, 0, 0x0000FF);
            body1.position.set(0, 1.5, 0);
            mario.add(body1);
            const body2 = createBlock(0, 0, 0, 0x0000FF);
            body2.position.set(0, 0.5, 0);
            mario.add(body2);
            
            // Red shirt visible on sides
            const shirt1 = createBlock(0, 0, 0, 0xFF0000);
            shirt1.position.set(0.6, 1.5, 0);
            shirt1.scale.set(0.4, 1, 0.8);
            mario.add(shirt1);
            const shirt2 = createBlock(0, 0, 0, 0xFF0000);
            shirt2.position.set(-0.6, 1.5, 0);
            shirt2.scale.set(0.4, 1, 0.8);
            mario.add(shirt2);
            
            // Yellow buttons
            const button1 = createBlock(0, 0, 0, 0xFFD700);
            button1.position.set(0.3, 1.7, 0.5);
            button1.scale.set(0.15, 0.15, 0.15);
            mario.add(button1);
            const button2 = createBlock(0, 0, 0, 0xFFD700);
            button2.position.set(-0.3, 1.7, 0.5);
            button2.scale.set(0.15, 0.15, 0.15);
            mario.add(button2);
            
            // Brown shoes
            const shoe1 = createBlock(0, 0, 0, 0x8B4513);
            shoe1.position.set(0.3, -0.3, 0.2);
            shoe1.scale.set(0.5, 0.4, 0.8);
            mario.add(shoe1);
            const shoe2 = createBlock(0, 0, 0, 0x8B4513);
            shoe2.position.set(-0.3, -0.3, 0.2);
            shoe2.scale.set(0.5, 0.4, 0.8);
            mario.add(shoe2);
            
            // White gloves/hands
            const hand1 = createBlock(0, 0, 0, 0xFFFFFF);
            hand1.position.set(0.9, 1, 0);
            hand1.scale.set(0.3, 0.3, 0.3);
            mario.add(hand1);
            const hand2 = createBlock(0, 0, 0, 0xFFFFFF);
            hand2.position.set(-0.9, 1, 0);
            hand2.scale.set(0.3, 0.3, 0.3);
            mario.add(hand2);
            
            mario.position.set(x, y, z);
            mario.userData = { type: 'mario', vx: 0, jumpTimer: 0, baseY: y, isJumping: false, isDead: true, deathTime: 0 };
            
            // Mario's ghost rising effect - he's been slain!
            mario.rotation.x = Math.PI / 2; // Fallen over
            scene.add(mario);
            mobs.push(mario);
        }
        
        function createVoxelBowser(x, y, z) {
            const bowser = new THREE.Group();
            
            // Massive green body
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    const block = createBlock(0, 0, 0, 0x228B22);
                    block.position.set(i - 1.5, j, 0);
                    bowser.add(block);
                }
            }
            
            // Yellow belly
            for (let j = 0; j < 2; j++) {
                const belly = createBlock(0, 0, 0, 0xFFD700);
                belly.position.set(0.5, j, 0.5);
                belly.scale.set(1.5, 1, 0.2);
                bowser.add(belly);
            }
            
            // Spiked shell (brown with spikes)
            const shell = createBlock(0, 0, 0, 0x8B4513);
            shell.position.set(0, 1.5, -0.8);
            shell.scale.set(3, 2, 1.5);
            bowser.add(shell);
            
            // Spikes on shell
            for (let i = 0; i < 5; i++) {
                const spike = createBlock(0, 0, 0, 0xFFFFFF);
                spike.position.set(-1.5 + i * 0.8, 2.5 + (i % 2) * 0.3, -0.8);
                spike.scale.set(0.3, 0.8, 0.3);
                bowser.add(spike);
            }
            
            // Big scary head
            const head = createBlock(0, 0, 0, 0x228B22);
            head.position.set(2.5, 2, 0);
            head.scale.set(1.5, 1.5, 1.5);
            bowser.add(head);
            
            // Horns
            const horn1 = createBlock(0, 0, 0, 0xFFFFFF);
            horn1.position.set(2, 3.5, 0.3);
            horn1.scale.set(0.3, 0.8, 0.3);
            bowser.add(horn1);
            const horn2 = createBlock(0, 0, 0, 0xFFFFFF);
            horn2.position.set(3, 3.5, 0.3);
            horn2.scale.set(0.3, 0.8, 0.3);
            bowser.add(horn2);
            
            // Angry red eyes
            const eye1 = createBlock(0, 0, 0, 0xFF0000);
            eye1.position.set(2.8, 2.3, 0.8);
            eye1.scale.set(0.4, 0.3, 0.2);
            bowser.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0xFF0000);
            eye2.position.set(2.2, 2.3, 0.8);
            eye2.scale.set(0.4, 0.3, 0.2);
            bowser.add(eye2);
            
            // Fire breath!
            for (let f = 0; f < 3; f++) {
                const fire = createBlock(0, 0, 0, f === 0 ? 0xFF0000 : (f === 1 ? 0xFF6600 : 0xFFFF00));
                fire.position.set(3.5 + f * 0.5, 1.8, 0);
                fire.scale.set(0.5 - f * 0.1, 0.5 - f * 0.1, 0.5 - f * 0.1);
                fire.userData = { isFire: true, fireIndex: f };
                bowser.add(fire);
            }
            
            // Tail
            const tail = createBlock(0, 0, 0, 0x228B22);
            tail.position.set(-2.5, 0.5, 0);
            tail.scale.set(1.5, 0.5, 0.5);
            bowser.add(tail);
            const tailSpike = createBlock(0, 0, 0, 0xFFFFFF);
            tailSpike.position.set(-3.5, 0.5, 0);
            tailSpike.scale.set(0.5, 0.3, 0.3);
            bowser.add(tailSpike);
            
            bowser.position.set(x, y, z);
            bowser.userData = { type: 'bowser', angle: 0 };
            scene.add(bowser);
            mobs.push(bowser);
        }
        
        function createVoxelGreeter(x, y, z) {
            const greeter = new THREE.Group();
            
            // Fish-shaped sign body (rainbow colors)
            const rainbowColors = [0xFF6B6B, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00BFFF, 0x8A2BE2];
            
            for (let i = 0; i < 6; i++) {
                const block = createBlock(0, 0, 0, rainbowColors[i]);
                block.position.set(i - 2.5, 0, 0);
                greeter.add(block);
            }
            
            // Top fin
            const topFin = createBlock(0, 0, 0, 0xFFD700);
            topFin.position.set(0, 1, 0);
            topFin.scale.set(0.5, 0.8, 0.3);
            greeter.add(topFin);
            
            // Eye
            const eye = createBlock(0, 0, 0, 0xFFFFFF);
            eye.position.set(2.5, 0.3, 0.5);
            eye.scale.set(0.4, 0.4, 0.4);
            greeter.add(eye);
            
            const pupil = createBlock(0, 0, 0, 0x000000);
            pupil.position.set(2.6, 0.3, 0.6);
            pupil.scale.set(0.2, 0.2, 0.2);
            greeter.add(pupil);
            
            // Sparkle blocks around it
            for (let i = 0; i < 4; i++) {
                const sparkle = createBlock(0, 0, 0, 0xFFFF00);
                sparkle.position.set(
                    Math.cos(i * Math.PI / 2) * 4,
                    Math.sin(i * Math.PI / 2) * 2,
                    0
                );
                sparkle.scale.set(0.3, 0.3, 0.3);
                sparkle.userData = { sparkleIndex: i };
                greeter.add(sparkle);
            }
            
            greeter.position.set(x, y, z);
            greeter.userData = { type: 'greeter', wobble: 0 };
            scene.add(greeter);
            mobs.push(greeter);
        }
        
        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngle.x) * Math.cos(cameraAngle.y) * cameraDistance;
            camera.position.y = Math.sin(cameraAngle.y) * cameraDistance + 10;
            camera.position.z = Math.cos(cameraAngle.x) * Math.cos(cameraAngle.y) * cameraDistance;
            camera.lookAt(0, 5, 0);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cameraAngle.x += deltaX * 0.01;
            cameraAngle.y = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraAngle.y + deltaY * 0.01));
            updateCameraPosition();
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            cameraDistance = Math.max(20, Math.min(100, cameraDistance + event.deltaY * 0.05));
            updateCameraPosition();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            // Animate mobs
            for (let mob of mobs) {
                if (mob.userData.type === 'fish') {
                    mob.position.x += mob.userData.vx;
                    mob.position.y = mob.userData.baseY + Math.sin(time * 2 + mob.position.x) * 2;
                    mob.rotation.y = mob.userData.vx > 0 ? 0 : Math.PI;
                    if (mob.position.x > 25) mob.position.x = -25;
                    if (mob.position.x < -25) mob.position.x = 25;
                }
                else if (mob.userData.type === 'shark') {
                    mob.userData.angle += 0.01;
                    mob.position.x = Math.cos(mob.userData.angle) * 8;
                    mob.position.z = Math.sin(mob.userData.angle) * 8;
                    mob.rotation.y = -mob.userData.angle + Math.PI / 2;
                }
                else if (mob.userData.type === 'werewolf') {
                    mob.position.x += mob.userData.vx;
                    mob.rotation.y = mob.userData.vx > 0 ? -Math.PI / 2 : Math.PI / 2;
                    if (mob.position.x > 18 || mob.position.x < -18) mob.userData.vx *= -1;
                    // Occasional jump
                    if (Math.random() < 0.005) {
                        mob.position.y += 2;
                    }
                    if (mob.position.y > 2) mob.position.y -= 0.1;
                }
                else if (mob.userData.type === 'mario') {
                    // Mario is dead - ghost effect
                    if (mob.userData.isDead) {
                        mob.userData.deathTime += 0.016;
                        mob.rotation.x = Math.PI / 2;
                        // Ghost slowly rises and fades
                        mob.position.y = mob.userData.baseY + Math.sin(mob.userData.deathTime) * 0.5;
                        mob.children.forEach(child => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = 0.3 + Math.sin(mob.userData.deathTime * 3) * 0.2;
                            }
                        });
                    }
                }
                else if (mob.userData.type === 'bowser') {
                    // Bowser circles menacingly around Mario's body
                    mob.userData.angle += 0.02;
                    mob.position.x = Math.cos(mob.userData.angle) * 6;
                    mob.position.z = Math.sin(mob.userData.angle) * 6 + 5;
                    mob.rotation.y = -mob.userData.angle + Math.PI;
                    // Breathing fire animation
                    mob.position.y = 3 + Math.sin(time * 4) * 0.3;
                }
                else if (mob.userData.type === 'greeter') {
                    mob.userData.wobble += 0.05;
                    mob.position.y += Math.sin(mob.userData.wobble) * 0.02;
                    mob.rotation.y += 0.01;
                    // Animate sparkles
                    mob.children.forEach((child, i) => {
                        if (child.userData && child.userData.sparkleIndex !== undefined) {
                            const idx = child.userData.sparkleIndex;
                            child.position.x = Math.cos(time * 2 + idx * Math.PI / 2) * 4;
                            child.position.y = Math.sin(time * 2 + idx * Math.PI / 2) * 2;
                        }
                    });
                }
            }
            
            // Day/night cycle (subtle)
            const dayProgress = (Math.sin(time * 0.1) + 1) / 2;
            const skyColor = new THREE.Color().lerpColors(
                new THREE.Color(0x1a1a2e),
                new THREE.Color(0x87CEEB),
                dayProgress
            );
            scene.background = skyColor;
            scene.fog.color = skyColor;
            
            // Animate ocean waves
            if (window.seaBlocks) {
                for (let waterBlock of window.seaBlocks) {
                    if (waterBlock.userData && waterBlock.userData.isWater) {
                        const waveHeight = Math.sin(time * 1.5 + waterBlock.userData.waveOffset) * 0.15;
                        waterBlock.position.y = waterBlock.userData.baseY + waveHeight;
                    }
                }
            }
            
            // Animate seaweed swaying
            for (let block of blocks) {
                if (block.userData && block.userData.isSeaweed) {
                    block.rotation.z = Math.sin(time * 2 + block.userData.swayOffset) * 0.2;
                }
                // Animate the test block
                if (block.userData && block.userData.isTestBlock) {
                    block.rotation.x += 0.02;
                    block.rotation.y += 0.03;
                    block.position.y = 15 + Math.sin(time * 2) * 2;
                }
                // Animate the test echo orbiting the main test block
                if (block.userData && block.userData.isTestEcho) {
                    block.userData.orbitAngle += 0.05;
                    block.position.x = Math.cos(block.userData.orbitAngle) * 3;
                    block.position.z = Math.sin(block.userData.orbitAngle) * 3;
                    block.position.y = 15 + Math.sin(time * 3) * 1;
                    block.rotation.x += 0.05;
                    block.rotation.z += 0.05;
                }
            }
            
            // Update UI
            document.getElementById('object-count').innerHTML = 
                `<span class="minecraft-text">Blocks: ${blockCount} | Mobs: ${mobs.length}</span>`;
            
            renderer.render(scene, camera);
        }
        
        function spawnGoldBlock() {
            const x = Math.floor(Math.random() * 20) - 10;
            const z = Math.floor(Math.random() * 20) - 10;
            const y = 5 + Math.floor(Math.random() * 10);
            const newBlock = createBlock(x, y, z, 0xFFD700);
            newBlock.userData = { falling: true, targetY: 3, isGold: true };
            
            // Add sparkle effect
            const sparkleGeom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const sparkleMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            for (let i = 0; i < 4; i++) {
                const sparkle = new THREE.Mesh(sparkleGeom, sparkleMat);
                sparkle.position.set(
                    x + (Math.random() - 0.5) * 2,
                    y + (Math.random() - 0.5) * 2,
                    z + (Math.random() - 0.5) * 2
                );
                scene.add(sparkle);
                setTimeout(() => scene.remove(sparkle), 500);
            }
            
            function dropBlock() {
                if (newBlock.position.y > newBlock.userData.targetY) {
                    newBlock.position.y -= 0.3;
                    requestAnimationFrame(dropBlock);
                } else {
                    newBlock.position.y = newBlock.userData.targetY;
                }
            }
            dropBlock();
        }
        
        function spawnRandomBlock() {
            const colors = [0xFF6B6B, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00BFFF, 0x8A2BE2, 0xFF69B4, 0x4CAF50, 0x8B4513];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const x = Math.floor(Math.random() * 20) - 10;
            const z = Math.floor(Math.random() * 20) - 10;
            const y = 5 + Math.floor(Math.random() * 10);
            const newBlock = createBlock(x, y, z, randomColor);
            newBlock.userData = { falling: true, targetY: 3 };
            
            // Animate the block falling
            function dropBlock() {
                if (newBlock.position.y > newBlock.userData.targetY) {
                    newBlock.position.y -= 0.3;
                    requestAnimationFrame(dropBlock);
                } else {
                    newBlock.position.y = newBlock.userData.targetY;
                }
            }
            dropBlock();
        }
    </script>
</body>
</html>