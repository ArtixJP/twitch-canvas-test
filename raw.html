<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>‚öîÔ∏è Fantasy Minecraft Builder üß±</title>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4a90c2 50%, #2d5a87 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 1.5rem; text-align: center; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100; text-shadow: 2px 2px 4px black; }
        #game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; outline: none; }
        #controls { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 0.9rem; z-index: 100; }
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; z-index: 100; }
        .slot { width: 50px; height: 50px; border: 3px solid #555; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer; }
        .slot.active { border-color: white; }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<h1>‚öîÔ∏è Fantasy Minecraft Builder üß±‚õèÔ∏è üé¨</h1>
<div id="movie-info" style="position:absolute;top:50px;right:20px;background:rgba(0,0,0,0.7);padding:10px;border-radius:8px;z-index:100;font-size:0.8rem;">üé¨ Fantasy: A Love Story<br/>Part 1: Princess Captured!<br/>Part 2: Knight's Battle<br/>Part 3: Wedding Day üíí<br/>Look at X:-25, Z:-40</div>
<canvas id="game" tabindex="0"></canvas>
<div id="controls">ZQSD/WASD: Move | Space: Jump | Shift: Down<br/>Mouse: Look | Left Click: Build/Deconstruct<br/>1-4: Select Block<br/><span id="debug" style="color:#0f0;">Click game to start! (iframe-friendly)</span></div>
<div id="hotbar">
<div class="slot active" data-block="grass">üîã</div>
<div class="slot" data-block="dirt">üî∑</div>
<div class="slot" data-block="stone">‚öôÔ∏è</div>
<div class="slot" data-block="wood">üî∂</div>
<div class="slot" data-block="question">‚ùì</div>
<div class="slot" data-block="brick">üß±</div>
</div>
<script>
    const canvas = document.getElementById('game');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    // Sky clouds
    const clouds = [];
    for(let i = 0; i < 10; i++) {
        const cloudGeo = new THREE.SphereGeometry(2 + Math.random() * 2, 8, 8);
        const cloudMat = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
        const cloud = new THREE.Mesh(cloudGeo, cloudMat);
        cloud.position.set((Math.random()-0.5)*60, 15 + Math.random()*10, (Math.random()-0.5)*60);
        cloud.scale.set(1.5, 0.6, 1);
        scene.add(cloud);
        clouds.push(cloud);
    }
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({canvas});
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const blocks = {};
    const blockColors = {grass: 0x00ffaa, dirt: 0x4466aa, stone: 0x8899aa, wood: 0xffaa33, question: 0xffcc00, brick: 0xcc6633};
    let selectedBlock = 'grass';
    let placeMode = true;
    
    function addBlock(x,y,z,type='grass') {
        const key = `${x},${y},${z}`;
        if(blocks[key]) return;
        const geo = new THREE.BoxGeometry(1,1,1);
        const mat = new THREE.MeshLambertMaterial({color: blockColors[type]});
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(x,y,z);
        cube.userData = {type, key};
        scene.add(cube);
        blocks[key] = cube;
    }
    
    for(let x=-10;x<10;x++) for(let z=-10;z<10;z++) {
        addBlock(x, 0, z, 'grass');
        addBlock(x, -1, z, 'dirt');
        if(Math.random()>0.95) addBlock(x,1,z,'wood');
        if(Math.random()>0.97) addBlock(x,3,z,'question');
    }
    
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x2a2a4a));
    
    // Trees like Minecraft
    const trees = [];
    for(let i = 0; i < 8; i++) {
        const trunkGeo = new THREE.BoxGeometry(0.5, 3, 0.5);
        const trunkMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set((Math.random()-0.5)*18, 2.5, (Math.random()-0.5)*18);
        scene.add(trunk);
        const leavesGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
        const leavesMat = new THREE.MeshLambertMaterial({color: 0x228B22});
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.copy(trunk.position);
        leaves.position.y += 2.5;
        scene.add(leaves);
        trees.push({trunk, leaves});
    }
    
    // Gold coins floating in space
    const coins = [];
    for(let i = 0; i < 20; i++) {
        const coinGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
        const coinMat = new THREE.MeshLambertMaterial({color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.3});
        const coin = new THREE.Mesh(coinGeo, coinMat);
        coin.position.set((Math.random()-0.5)*30, Math.random()*8+2, (Math.random()-0.5)*30);
        coin.rotation.x = Math.PI/2;
        coin.userData.baseY = coin.position.y;
        scene.add(coin);
        coins.push(coin);
    }
    
    // Piranha plant pipe
    const pipeGeo = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
    const pipeMat = new THREE.MeshLambertMaterial({color: 0x00aa00});
    const pipe = new THREE.Mesh(pipeGeo, pipeMat);
    pipe.position.set(5, 1, -5);
    scene.add(pipe);
    const pipeRim = new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.15, 8, 16), pipeMat);
    pipeRim.position.set(5, 2, -5);
    pipeRim.rotation.x = Math.PI/2;
    scene.add(pipeRim);
    
    // Piranha plant
    const plantHead = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshLambertMaterial({color: 0xff0000}));
    plantHead.position.set(5, 2.5, -5);
    scene.add(plantHead);
    const plantSpots = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({color: 0xffffff}));
    plantSpots.position.set(5.2, 2.6, -4.7);
    scene.add(plantSpots);
    
    // Sunlight
    const sunLight = new THREE.PointLight(0xffffaa, 0.8, 100);
    sunLight.position.set(30, 30, 30);
    scene.add(sunLight);
    
    camera.position.set(0, 5, 10);
    let yaw = 0, pitch = 0;
    const keys = {};
    const vel = {x:0, y:0, z:0};
    
    canvas.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
    canvas.addEventListener('keyup', e => { keys[e.code] = false; e.preventDefault(); });
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    
    canvas.addEventListener('click', () => { canvas.focus(); canvas.requestPointerLock(); document.getElementById('debug').textContent = 'Controls active!'; });
    canvas.focus();
    document.addEventListener('mousemove', e => {
        if(document.pointerLockElement === canvas) {
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }
    });
    
    canvas.addEventListener('mousedown', e => {
        e.preventDefault();
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({x:0,y:0}, camera);
        const hits = raycaster.intersectObjects(Object.values(blocks));
        if(hits.length > 0) {
            const hit = hits[0];
            if(placeMode) {
                const norm = hit.face.normal;
                const pos = hit.object.position;
                addBlock(pos.x+norm.x, pos.y+norm.y, pos.z+norm.z, selectedBlock);
            } else {
                scene.remove(hit.object);
                delete blocks[hit.object.userData.key];
            }
        }
        placeMode = !placeMode;
    });
    
    document.querySelectorAll('.slot').forEach((s,i) => {
        s.addEventListener('click', () => {
            document.querySelectorAll('.slot').forEach(x => x.classList.remove('active'));
            s.classList.add('active');
            selectedBlock = s.dataset.block;
        });
    });
    document.addEventListener('keydown', e => {
        if(e.key >= '1' && e.key <= '4') {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(x => x.classList.remove('active'));
            slots[e.key-1].classList.add('active');
            selectedBlock = slots[e.key-1].dataset.block;
        }
    });
    
    // 3D Mario vs Bowser Scene (Minecraft style)
    const theaterGroup = new THREE.Group();
    
    // 3D Knight character (more realistic)
    const marioGroup = new THREE.Group();
    const marioBody = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.1, 0.5), new THREE.MeshLambertMaterial({color: 0xff0000}));
    const marioHead = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshLambertMaterial({color: 0xffcc99}));
    const marioHat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.25, 0.8), new THREE.MeshLambertMaterial({color: 0xff0000}));
    const marioHatBrim = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.3), new THREE.MeshLambertMaterial({color: 0xff0000}));
    const marioLegs = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.5, 0.4), new THREE.MeshLambertMaterial({color: 0x0000aa}));
    const marioLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), new THREE.MeshLambertMaterial({color: 0xff0000}));
    const marioRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), new THREE.MeshLambertMaterial({color: 0xff0000}));
    const marioNose = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), new THREE.MeshLambertMaterial({color: 0xffaa77}));
    const marioMustache = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.15), new THREE.MeshLambertMaterial({color: 0x4a2c0a}));
    const marioEyeL = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({color: 0x0066ff}));
    const marioEyeR = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({color: 0x0066ff}));
    marioHead.position.y = 1; marioHat.position.y = 1.35; marioHatBrim.position.set(0, 1.15, -0.35); marioLegs.position.y = -0.8;
    marioLeftArm.position.set(-0.6, 0.1, 0); marioRightArm.position.set(0.6, 0.1, 0);
    marioNose.position.set(0, 0.95, -0.4); marioMustache.position.set(0, 0.85, -0.38);
    marioEyeL.position.set(-0.15, 1.05, -0.35); marioEyeR.position.set(0.15, 1.05, -0.35);
    marioGroup.add(marioBody, marioHead, marioHat, marioHatBrim, marioLegs, marioLeftArm, marioRightArm, marioNose, marioMustache, marioEyeL, marioEyeR);
    marioGroup.position.set(-30, 2, -40);
    theaterGroup.add(marioGroup);
    
    // Princess Peach character (more realistic)
    const peachGroup = new THREE.Group();
    const peachDress = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, 1.5, 12), new THREE.MeshLambertMaterial({color: 0xff69b4}));
    const peachBody = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.35), new THREE.MeshLambertMaterial({color: 0xff69b4}));
    const peachHead = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.6, 0.55), new THREE.MeshLambertMaterial({color: 0xffddcc}));
    const peachHair = new THREE.Mesh(new THREE.BoxGeometry(0.65, 1.2, 0.5), new THREE.MeshLambertMaterial({color: 0xffdd00}));
    const peachCrown = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.25), new THREE.MeshLambertMaterial({color: 0xffd700}));
    const peachGem = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({color: 0xff0066}));
    const peachLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), new THREE.MeshLambertMaterial({color: 0xffddcc}));
    const peachRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), new THREE.MeshLambertMaterial({color: 0xffddcc}));
    const peachEyeL = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), new THREE.MeshBasicMaterial({color: 0x0088ff}));
    const peachEyeR = new THREE.Mesh(new THREE.SphereGeometry(0.07, 8, 8), new THREE.MeshBasicMaterial({color: 0x0088ff}));
    const peachLips = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.05, 0.1), new THREE.MeshLambertMaterial({color: 0xff3366}));
    peachDress.position.y = -0.3; peachBody.position.y = 0.6; peachHead.position.y = 1.2; peachHair.position.set(0, 1.1, 0.15); peachCrown.position.y = 1.6;
    peachGem.position.set(0, 1.55, -0.15); peachLeftArm.position.set(-0.4, 0.5, 0); peachRightArm.position.set(0.4, 0.5, 0);
    peachEyeL.position.set(-0.12, 1.25, -0.28); peachEyeR.position.set(0.12, 1.25, -0.28); peachLips.position.set(0, 1.1, -0.28);
    peachGroup.add(peachDress, peachBody, peachHead, peachHair, peachCrown, peachGem, peachLeftArm, peachRightArm, peachEyeL, peachEyeR, peachLips);
    peachGroup.position.set(-22, 2, -40);
    theaterGroup.add(peachGroup);
    
    // 3D Dragon character (more realistic)
    const bowserGroup = new THREE.Group();
    const bowserBody = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.6, 1.1), new THREE.MeshLambertMaterial({color: 0x228B22}));
    const bowserBelly = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.4), new THREE.MeshLambertMaterial({color: 0xffdd88}));
    const bowserHead = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.9, 0.9), new THREE.MeshLambertMaterial({color: 0x228B22}));
    const bowserSnout = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.5), new THREE.MeshLambertMaterial({color: 0xffcc00}));
    const bowserShell = new THREE.Mesh(new THREE.SphereGeometry(0.9, 12, 8), new THREE.MeshLambertMaterial({color: 0x556B2F}));
    const bowserLeftArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), new THREE.MeshLambertMaterial({color: 0x228B22}));
    const bowserRightArm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), new THREE.MeshLambertMaterial({color: 0x228B22}));
    const bowserEyeL = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({color: 0xff0000}));
    const bowserEyeR = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshBasicMaterial({color: 0xff0000}));
    const bowserHornL = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.5, 6), new THREE.MeshLambertMaterial({color: 0xffffcc}));
    const bowserHornR = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.5, 6), new THREE.MeshLambertMaterial({color: 0xffffcc}));
    bowserBelly.position.z = -0.4; bowserHead.position.y = 1.3; bowserSnout.position.set(0, 1.2, -0.6); bowserShell.position.set(0, 0.3, 0.7);
    bowserLeftArm.position.set(-1, 0.2, 0); bowserRightArm.position.set(1, 0.2, 0);
    bowserEyeL.position.set(-0.3, 1.5, -0.4); bowserEyeR.position.set(0.3, 1.5, -0.4);
    bowserHornL.position.set(-0.35, 1.9, 0); bowserHornR.position.set(0.35, 1.9, 0);
    for(let i = 0; i < 5; i++) {
        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.6, 6), new THREE.MeshLambertMaterial({color: 0xffeecc}));
        spike.position.set(-0.5 + i*0.25, 0.7, 1.1); spike.rotation.x = -0.6;
        bowserGroup.add(spike);
    }
    bowserGroup.add(bowserBody, bowserBelly, bowserHead, bowserSnout, bowserShell, bowserLeftArm, bowserRightArm, bowserEyeL, bowserEyeR, bowserHornL, bowserHornR);
    bowserGroup.position.set(-20, 2, -40);
    theaterGroup.add(bowserGroup);
    
    // Battle arena floor
    for(let x = -35; x < -15; x += 2) for(let z = -45; z < -35; z += 2) {
        const brick = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 2), new THREE.MeshLambertMaterial({color: 0xcc6633}));
        brick.position.set(x, 0, z); theaterGroup.add(brick);
    }
    
    // Fireball
    const fireball = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({color: 0xff6600, emissive: 0xff3300}));
    fireball.position.set(-30, 2, -40); fireball.visible = false;
    theaterGroup.add(fireball);
    
    // Movie camera
    const movieCamera = {x: -25, y: 5, z: -30, lookAt: new THREE.Vector3(-25, 2, -40)};
    
    scene.add(theaterGroup);
    
    let movieFrame = 0;
    let storyPart = 1;
    function updateMovie() {
        movieFrame++;
        const t = movieFrame * 0.02;
        const cycle = movieFrame % 600;
        
        // PART 1: Bowser captures Peach (frames 0-200)
        if(cycle < 200) {
            storyPart = 1;
            marioGroup.position.set(-35, 2, -40);
            bowserGroup.position.x = -25 + Math.sin(t) * 2;
            peachGroup.position.x = -22 + (cycle > 100 ? (cycle-100) * 0.03 : 0);
            if(cycle > 150) peachGroup.position.x = bowserGroup.position.x + 1.5;
            peachGroup.rotation.y = cycle > 100 ? Math.sin(t*8)*0.3 : 0;
            fireball.visible = false;
        }
        // PART 2: Mario defeats Bowser (frames 200-450)
        else if(cycle < 450) {
            storyPart = 2;
            const battleFrame = cycle - 200;
            marioGroup.position.x = -35 + battleFrame * 0.06;
            marioGroup.position.y = 2 + Math.abs(Math.sin(t * 4)) * 1.5;
            if(battleFrame > 100 && battleFrame < 180) {
                fireball.visible = true;
                fireball.position.x = marioGroup.position.x + (battleFrame-100) * 0.2;
                fireball.position.y = 2.5;
            } else { fireball.visible = false; }
            if(battleFrame > 180) {
                bowserGroup.rotation.z = Math.sin(t*6)*0.5;
                bowserGroup.position.y = 2 - (battleFrame-180)*0.02;
            }
            peachGroup.position.set(-18, 2, -42);
        }
        // PART 3: Wedding! (frames 450-600)
        else {
            storyPart = 3;
            fireball.visible = false;
            bowserGroup.position.set(-35, 0, -45);
            marioGroup.position.set(-24, 2, -40);
            peachGroup.position.set(-22, 2, -40);
            marioGroup.rotation.y = 0.3;
            peachGroup.rotation.y = -0.3;
            marioGroup.position.y = 2 + Math.sin(t*2)*0.1;
            peachGroup.position.y = 2 + Math.sin(t*2+1)*0.1;
        }
        
        // Bowser idle animation (varies by part)
        if(storyPart < 3) bowserGroup.rotation.y = Math.sin(t * 0.5) * 0.3 + Math.PI;
        else bowserGroup.rotation.y = Math.PI;
        
        // Mario jump animation
        marioGroup.children.forEach((part, i) => {
            if(i === 3) part.rotation.x = Math.sin(t * 4) * 0.3;
        });
        
        // Dynamic camera following the action based on story part
        let camTarget;
        if(storyPart === 1) camTarget = new THREE.Vector3(-23, 3, -40);
        else if(storyPart === 2) camTarget = new THREE.Vector3((marioGroup.position.x + bowserGroup.position.x)/2, 3, -40);
        else camTarget = new THREE.Vector3(-23, 3, -40);
        movieCamera.x += (camTarget.x + 8 - movieCamera.x) * 0.02;
        movieCamera.y = 5 + Math.sin(t * 0.3) * (storyPart === 3 ? 0.5 : 2);
        movieCamera.lookAt.copy(camTarget);
    }
    
    // Snake creature
    const snakeSegments = [];
    const snakeLength = 8;
    const snakeSpeed = 0.05;
    let snakeAngle = 0;
    let snakeX = 5, snakeZ = 5;
    
    function animate() {
        requestAnimationFrame(animate);
        const speed = 0.15;
        const dir = new THREE.Vector3();
        if(keys['KeyZ'] || keys['KeyW']) dir.z -= 1;
        if(keys['KeyS']) dir.z += 1;
        if(keys['KeyQ'] || keys['KeyA']) dir.x -= 1;
        if(keys['KeyD']) dir.x += 1;
        dir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        camera.position.x += dir.x * speed;
        camera.position.z += dir.z * speed;
        if(keys['Space']) camera.position.y += speed;
        if(keys['ShiftLeft']) camera.position.y -= speed;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        updateSnake();
        // Animate grandma sign
        signGroup.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
        signGroup.position.y = 3 + Math.sin(Date.now() * 0.002) * 0.2;
        // Animate clouds drifting
        clouds.forEach((c, i) => {
            c.position.x += 0.01;
            if(c.position.x > 30) c.position.x = -30;
        });
        // Animate gold coins
        coins.forEach((coin, i) => {
            coin.rotation.z += 0.05;
            coin.position.y = coin.userData.baseY + Math.sin(Date.now() * 0.003 + i) * 0.3;
        });
        // Animate piranha plant
        plantHead.position.y = 2.5 + Math.sin(Date.now() * 0.002) * 0.8;
        // Update 3D Fantasy movie scene
        updateMovie();
        // Slight theater rotation for dynamic feel
        theaterGroup.rotation.y = Math.sin(Date.now() * 0.0003) * 0.05;
        renderer.render(scene, camera);
    }
    
    for(let i = 0; i < snakeLength; i++) {
        const geo = new THREE.BoxGeometry(0.6, 0.4, 0.6);
        const mat = new THREE.MeshLambertMaterial({color: i === 0 ? 0x00ff00 : 0x228B22});
        const segment = new THREE.Mesh(geo, mat);
        segment.position.set(snakeX - i * 0.5, 1.2, snakeZ);
        scene.add(segment);
        snakeSegments.push(segment);
    }
    
    // Grandma sign in-game!
    const signGroup = new THREE.Group();
    const signGeo = new THREE.BoxGeometry(4, 1.5, 0.2);
    const signMat = new THREE.MeshLambertMaterial({color: 0xff69b4});
    const signBoard = new THREE.Mesh(signGeo, signMat);
    signGroup.add(signBoard);
    const poleGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
    const poleMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.y = -1.5;
    signGroup.add(pole);
    signGroup.position.set(-5, 3, -5);
    scene.add(signGroup);
    
    // Create canvas texture for sign text
    const signCanvas = document.createElement('canvas');
    signCanvas.width = 512;
    signCanvas.height = 192;
    const ctx = signCanvas.getContext('2d');
    ctx.fillStyle = '#ff69b4';
    ctx.fillRect(0, 0, 512, 192);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üëµ Hello Grandma! üíï', 256, 80);
    ctx.fillText('We love you!', 256, 130);
    const signTexture = new THREE.CanvasTexture(signCanvas);
    const signFaceMat = new THREE.MeshBasicMaterial({map: signTexture});
    const signFace = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.4), signFaceMat);
    signFace.position.z = 0.11;
    signGroup.add(signFace);
    
    // Snake eyes
    const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({color: 0xff0000});
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    snakeSegments[0].add(leftEye);
    snakeSegments[0].add(rightEye);
    leftEye.position.set(-0.2, 0.15, -0.25);
    rightEye.position.set(0.2, 0.15, -0.25);
    
    animate();
    
    function updateSnake() {
        snakeAngle += 0.02 + Math.sin(Date.now() * 0.001) * 0.01;
        snakeX += Math.cos(snakeAngle) * snakeSpeed;
        snakeZ += Math.sin(snakeAngle) * snakeSpeed;
        
        // Keep snake in bounds
        if(snakeX > 8) snakeAngle = Math.PI - snakeAngle;
        if(snakeX < -8) snakeAngle = Math.PI - snakeAngle;
        if(snakeZ > 8) snakeAngle = -snakeAngle;
        if(snakeZ < -8) snakeAngle = -snakeAngle;
        
        // Move head
        snakeSegments[0].position.x = snakeX;
        snakeSegments[0].position.z = snakeZ;
        snakeSegments[0].position.y = 1.2 + Math.sin(Date.now() * 0.005) * 0.1;
        snakeSegments[0].rotation.y = -snakeAngle + Math.PI/2;
        
        // Follow segments
        for(let i = 1; i < snakeSegments.length; i++) {
            const prev = snakeSegments[i-1].position;
            const curr = snakeSegments[i].position;
            curr.lerp(prev, 0.3);
            curr.y = 1.2 + Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
            snakeSegments[i].lookAt(prev);
        }
    }
    
    
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>