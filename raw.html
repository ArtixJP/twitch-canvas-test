<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>ğŸš€ Space Station Builder ğŸŒŒ</title>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            color: white;
            overflow: hidden;
        }
        h1 { font-size: 1.5rem; text-align: center; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100; text-shadow: 2px 2px 4px black; }
        #game { position: absolute; top: 0; left: 0; width: 100%; height: 100%; outline: none; }
        #controls { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; font-size: 0.9rem; z-index: 100; }
        #hotbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; z-index: 100; }
        .slot { width: 50px; height: 50px; border: 3px solid #555; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer; }
        .slot.active { border-color: white; }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<h1>ğŸš€ Space Station Builder - Mario Galaxy Edition ğŸŒŒğŸ„</h1>
<canvas id="game" tabindex="0"></canvas>
<div id="controls">ZQSD/WASD: Move | Space: Jump | Shift: Down<br/>Mouse: Look | Left Click: Build/Deconstruct<br/>1-4: Select Block<br/><span id="debug" style="color:#0f0;">Click game to start! (iframe-friendly)</span></div>
<div id="hotbar">
<div class="slot active" data-block="grass">ğŸ”‹</div>
<div class="slot" data-block="dirt">ğŸ”·</div>
<div class="slot" data-block="stone">âš™ï¸</div>
<div class="slot" data-block="wood">ğŸ”¶</div>
<div class="slot" data-block="question">â“</div>
<div class="slot" data-block="brick">ğŸ§±</div>
</div>
<script>
    const canvas = document.getElementById('game');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    // Space exploration mode - add stars
    const starsGeo = new THREE.BufferGeometry();
    const starPositions = [];
    for(let i = 0; i < 2000; i++) {
        starPositions.push((Math.random() - 0.5) * 500);
        starPositions.push((Math.random() - 0.5) * 500);
        starPositions.push((Math.random() - 0.5) * 500);
    }
    starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    const starsMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8});
    const stars = new THREE.Points(starsGeo, starsMat);
    scene.add(stars);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({canvas});
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    const blocks = {};
    const blockColors = {grass: 0x00ffaa, dirt: 0x4466aa, stone: 0x8899aa, wood: 0xffaa33, question: 0xffcc00, brick: 0xcc6633};
    let selectedBlock = 'grass';
    let placeMode = true;
    
    function addBlock(x,y,z,type='grass') {
        const key = `${x},${y},${z}`;
        if(blocks[key]) return;
        const geo = new THREE.BoxGeometry(1,1,1);
        const mat = new THREE.MeshLambertMaterial({color: blockColors[type]});
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(x,y,z);
        cube.userData = {type, key};
        scene.add(cube);
        blocks[key] = cube;
    }
    
    for(let x=-10;x<10;x++) for(let z=-10;z<10;z++) {
        addBlock(x, 0, z, 'grass');
        addBlock(x, -1, z, 'dirt');
        if(Math.random()>0.95) addBlock(x,1,z,'wood');
        if(Math.random()>0.97) addBlock(x,3,z,'question');
    }
    
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,10,5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x2a2a4a));
    
    // Add floating asteroids/space rocks
    const asteroids = [];
    for(let i = 0; i < 15; i++) {
        const asteroidGeo = new THREE.DodecahedronGeometry(Math.random() * 1.5 + 0.5);
        const asteroidMat = new THREE.MeshLambertMaterial({color: 0x555566});
        const asteroid = new THREE.Mesh(asteroidGeo, asteroidMat);
        asteroid.position.set((Math.random()-0.5)*40, Math.random()*15+5, (Math.random()-0.5)*40);
        asteroid.userData.speed = Math.random() * 0.01 + 0.005;
        asteroid.userData.rotSpeed = Math.random() * 0.02;
        scene.add(asteroid);
        asteroids.push(asteroid);
    }
    
    // Mario coins floating in space
    const coins = [];
    for(let i = 0; i < 20; i++) {
        const coinGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
        const coinMat = new THREE.MeshLambertMaterial({color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.3});
        const coin = new THREE.Mesh(coinGeo, coinMat);
        coin.position.set((Math.random()-0.5)*30, Math.random()*8+2, (Math.random()-0.5)*30);
        coin.rotation.x = Math.PI/2;
        coin.userData.baseY = coin.position.y;
        scene.add(coin);
        coins.push(coin);
    }
    
    // Piranha plant pipe
    const pipeGeo = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
    const pipeMat = new THREE.MeshLambertMaterial({color: 0x00aa00});
    const pipe = new THREE.Mesh(pipeGeo, pipeMat);
    pipe.position.set(5, 1, -5);
    scene.add(pipe);
    const pipeRim = new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.15, 8, 16), pipeMat);
    pipeRim.position.set(5, 2, -5);
    pipeRim.rotation.x = Math.PI/2;
    scene.add(pipeRim);
    
    // Piranha plant
    const plantHead = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshLambertMaterial({color: 0xff0000}));
    plantHead.position.set(5, 2.5, -5);
    scene.add(plantHead);
    const plantSpots = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({color: 0xffffff}));
    plantSpots.position.set(5.2, 2.6, -4.7);
    scene.add(plantSpots);
    
    // Nebula light
    const nebulaLight = new THREE.PointLight(0x9933ff, 0.5, 50);
    nebulaLight.position.set(20, 15, -20);
    scene.add(nebulaLight);
    const nebulaLight2 = new THREE.PointLight(0x3399ff, 0.5, 50);
    nebulaLight2.position.set(-20, 10, 20);
    scene.add(nebulaLight2);
    
    camera.position.set(0, 5, 10);
    let yaw = 0, pitch = 0;
    const keys = {};
    const vel = {x:0, y:0, z:0};
    
    canvas.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
    canvas.addEventListener('keyup', e => { keys[e.code] = false; e.preventDefault(); });
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    
    canvas.addEventListener('click', () => { canvas.focus(); canvas.requestPointerLock(); document.getElementById('debug').textContent = 'Controls active!'; });
    canvas.focus();
    document.addEventListener('mousemove', e => {
        if(document.pointerLockElement === canvas) {
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }
    });
    
    canvas.addEventListener('mousedown', e => {
        e.preventDefault();
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({x:0,y:0}, camera);
        const hits = raycaster.intersectObjects(Object.values(blocks));
        if(hits.length > 0) {
            const hit = hits[0];
            if(placeMode) {
                const norm = hit.face.normal;
                const pos = hit.object.position;
                addBlock(pos.x+norm.x, pos.y+norm.y, pos.z+norm.z, selectedBlock);
            } else {
                scene.remove(hit.object);
                delete blocks[hit.object.userData.key];
            }
        }
        placeMode = !placeMode;
    });
    
    document.querySelectorAll('.slot').forEach((s,i) => {
        s.addEventListener('click', () => {
            document.querySelectorAll('.slot').forEach(x => x.classList.remove('active'));
            s.classList.add('active');
            selectedBlock = s.dataset.block;
        });
    });
    document.addEventListener('keydown', e => {
        if(e.key >= '1' && e.key <= '4') {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(x => x.classList.remove('active'));
            slots[e.key-1].classList.add('active');
            selectedBlock = slots[e.key-1].dataset.block;
        }
    });
    
    // Snake creature
    const snakeSegments = [];
    const snakeLength = 8;
    const snakeSpeed = 0.05;
    let snakeAngle = 0;
    let snakeX = 5, snakeZ = 5;
    
    function animate() {
        requestAnimationFrame(animate);
        const speed = 0.15;
        const dir = new THREE.Vector3();
        if(keys['KeyZ'] || keys['KeyW']) dir.z -= 1;
        if(keys['KeyS']) dir.z += 1;
        if(keys['KeyQ'] || keys['KeyA']) dir.x -= 1;
        if(keys['KeyD']) dir.x += 1;
        dir.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        camera.position.x += dir.x * speed;
        camera.position.z += dir.z * speed;
        if(keys['Space']) camera.position.y += speed;
        if(keys['ShiftLeft']) camera.position.y -= speed;
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        updateSnake();
        // Animate grandma sign
        signGroup.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
        signGroup.position.y = 3 + Math.sin(Date.now() * 0.002) * 0.2;
        // Rotate stars slowly
        stars.rotation.y += 0.0001;
        stars.rotation.x += 0.00005;
        // Animate asteroids
        asteroids.forEach(a => {
            a.rotation.x += a.userData.rotSpeed;
            a.rotation.y += a.userData.rotSpeed * 0.7;
            a.position.y += Math.sin(Date.now() * a.userData.speed) * 0.01;
        });
        // Pulse nebula lights
        nebulaLight.intensity = 0.5 + Math.sin(Date.now() * 0.001) * 0.2;
        nebulaLight2.intensity = 0.5 + Math.cos(Date.now() * 0.0015) * 0.2;
        // Animate Mario coins
        coins.forEach((coin, i) => {
            coin.rotation.z += 0.05;
            coin.position.y = coin.userData.baseY + Math.sin(Date.now() * 0.003 + i) * 0.3;
        });
        // Animate piranha plant
        plantHead.position.y = 2.5 + Math.sin(Date.now() * 0.002) * 0.8;
        renderer.render(scene, camera);
    }
    
    for(let i = 0; i < snakeLength; i++) {
        const geo = new THREE.BoxGeometry(0.6, 0.4, 0.6);
        const mat = new THREE.MeshLambertMaterial({color: i === 0 ? 0x00ff00 : 0x228B22});
        const segment = new THREE.Mesh(geo, mat);
        segment.position.set(snakeX - i * 0.5, 1.2, snakeZ);
        scene.add(segment);
        snakeSegments.push(segment);
    }
    
    // Grandma sign in-game!
    const signGroup = new THREE.Group();
    const signGeo = new THREE.BoxGeometry(4, 1.5, 0.2);
    const signMat = new THREE.MeshLambertMaterial({color: 0xff69b4});
    const signBoard = new THREE.Mesh(signGeo, signMat);
    signGroup.add(signBoard);
    const poleGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
    const poleMat = new THREE.MeshLambertMaterial({color: 0x8B4513});
    const pole = new THREE.Mesh(poleGeo, poleMat);
    pole.position.y = -1.5;
    signGroup.add(pole);
    signGroup.position.set(-5, 3, -5);
    scene.add(signGroup);
    
    // Create canvas texture for sign text
    const signCanvas = document.createElement('canvas');
    signCanvas.width = 512;
    signCanvas.height = 192;
    const ctx = signCanvas.getContext('2d');
    ctx.fillStyle = '#ff69b4';
    ctx.fillRect(0, 0, 512, 192);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ğŸ‘µ Hello Grandma! ğŸ’•', 256, 80);
    ctx.fillText('We love you!', 256, 130);
    const signTexture = new THREE.CanvasTexture(signCanvas);
    const signFaceMat = new THREE.MeshBasicMaterial({map: signTexture});
    const signFace = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.4), signFaceMat);
    signFace.position.z = 0.11;
    signGroup.add(signFace);
    
    // Snake eyes
    const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({color: 0xff0000});
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    snakeSegments[0].add(leftEye);
    snakeSegments[0].add(rightEye);
    leftEye.position.set(-0.2, 0.15, -0.25);
    rightEye.position.set(0.2, 0.15, -0.25);
    
    animate();
    
    function updateSnake() {
        snakeAngle += 0.02 + Math.sin(Date.now() * 0.001) * 0.01;
        snakeX += Math.cos(snakeAngle) * snakeSpeed;
        snakeZ += Math.sin(snakeAngle) * snakeSpeed;
        
        // Keep snake in bounds
        if(snakeX > 8) snakeAngle = Math.PI - snakeAngle;
        if(snakeX < -8) snakeAngle = Math.PI - snakeAngle;
        if(snakeZ > 8) snakeAngle = -snakeAngle;
        if(snakeZ < -8) snakeAngle = -snakeAngle;
        
        // Move head
        snakeSegments[0].position.x = snakeX;
        snakeSegments[0].position.z = snakeZ;
        snakeSegments[0].position.y = 1.2 + Math.sin(Date.now() * 0.005) * 0.1;
        snakeSegments[0].rotation.y = -snakeAngle + Math.PI/2;
        
        // Follow segments
        for(let i = 1; i < snakeSegments.length; i++) {
            const prev = snakeSegments[i-1].position;
            const curr = snakeSegments[i].position;
            curr.lerp(prev, 0.3);
            curr.y = 1.2 + Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
            snakeSegments[i].lookAt(prev);
        }
    }
    
    
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>