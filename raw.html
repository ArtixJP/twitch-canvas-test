<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch Minecraft World Builder</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        body { 
            font-family: 'Courier New', monospace; 
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #87CEEB;
            color: white;
        }
        h1 { 
            font-size: 2rem; 
            text-align: center; 
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            margin: 0;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
            image-rendering: pixelated;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #object-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.9rem;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border: 3px solid #555;
            image-rendering: pixelated;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 0.8rem;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border: 3px solid #555;
        }
        .mc-button {
            background: linear-gradient(180deg, #7a7a7a 0%, #4a4a4a 50%, #3a3a3a 100%);
            border: 3px solid #1a1a1a;
            border-top-color: #8a8a8a;
            border-left-color: #8a8a8a;
            color: #FFFF55;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #3F3F00;
            cursor: pointer;
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            image-rendering: pixelated;
            transition: transform 0.1s;
        }
        .mc-button:hover {
            background: linear-gradient(180deg, #9a9a9a 0%, #6a6a6a 50%, #5a5a5a 100%);
            transform: translateX(-50%) scale(1.05);
        }
        .mc-button:active {
            transform: translateX(-50%) scale(0.95);
            border-top-color: #3a3a3a;
            border-left-color: #3a3a3a;
            border-bottom-color: #8a8a8a;
            border-right-color: #8a8a8a;
        }
        .minecraft-text {
            color: #FFFF55;
            text-shadow: 2px 2px 0 #3F3F00;
        }
    </style>
</head>
<body>
<div id="game-container">
<h1>â›ï¸ MINECRAFT OCEAN WORLD â›ï¸</h1>
<div id="object-count"><span class="minecraft-text">Blocks: 0 | Mobs: 0</span></div>
<button class="mc-button" id="spawn-btn" onclick="spawnRandomBlock()">â›ï¸ SPAWN BLOCK â›ï¸</button>
<button class="mc-button" id="yellow-btn" onclick="spawnGoldBlock()" style="top: 110px; background: linear-gradient(180deg, #FFD700 0%, #DAA520 50%, #B8860B 100%); border-color: #8B6914; border-top-color: #FFE55C; border-left-color: #FFE55C; color: #000; text-shadow: 1px 1px 0 #FFE55C;">ğŸŒŸ GOLD BLOCK ğŸŒŸ</button>
<div id="controls">ğŸ® WASD/Arrows: Move | SPACE: Jump | SHIFT: Sprint | ğŸ–±ï¸ Drag to look | Scroll to zoom</div>
<div id="player-mode-toggle" style="position: absolute; bottom: 50px; right: 10px; z-index: 100;"><button class="mc-button" onclick="togglePlayerMode()" style="position: relative; top: 0; left: 0; transform: none; font-size: 0.8rem; padding: 8px 15px;">ğŸ‘¤ ENTER WORLD</button></div>
<div id="player-hud" style="display: none; position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); z-index: 100; background: rgba(0,0,0,0.6); border: 2px solid #555; padding: 10px 20px;">
<div style="display: flex; gap: 5px;">
<span style="color: #FF5555;">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</span>
</div>
<div style="color: #55FF55; font-size: 0.8rem; text-align: center; margin-top: 5px;">ğŸƒ EXPLORING MODE</div>
</div>
<div id="user-spaces-panel" style="position: absolute; top: 160px; left: 10px; background: rgba(0,0,0,0.8); border: 3px solid #5555FF; padding: 10px; font-size: 0.75rem; z-index: 100; max-height: 200px; overflow-y: auto; min-width: 150px;">
<div style="color: #55FFFF; font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #5555FF; padding-bottom: 3px;">ğŸ  USER PLOTS ğŸ </div>
<div id="user-list" style="color: #AAFFAA;"></div>
<button class="mc-button" onclick="claimPlot()" style="position: relative; top: 5px; left: 0; transform: none; font-size: 0.7rem; padding: 5px 10px;">ğŸ—ï¸ CLAIM PLOT</button>
</div>
<div id="mario-badge" style="position: absolute; top: 150px; right: 10px; background: rgba(100,100,100,0.5); border: 2px solid #666; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #AAA; font-weight: bold; text-decoration: line-through;">ğŸª¦ R.I.P. MARIO ğŸª¦</div>
<div id="bowser-badge" style="position: absolute; top: 190px; right: 10px; background: rgba(255,100,0,0.4); border: 2px solid #FF6600; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFD700; font-weight: bold; animation: bowserRoar 0.5s infinite;">ğŸ”¥ BOWSER WINS! ğŸ”¥</div>
<style>
@keyframes bowserRoar {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}
</style>
<div id="test-badge" style="position: absolute; top: 100px; right: 10px; background: rgba(100,100,100,0.3); border: 2px solid #666; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #888; text-decoration: line-through; opacity: 0.6;">ğŸ§ª TEST ERA CONCLUDED ğŸª¦</div>
<div id="test-echo" style="position: absolute; top: 130px; right: 10px; background: rgba(80,80,80,0.2); border: 1px dotted #555; padding: 3px 8px; font-size: 0.6rem; z-index: 100; color: #777; opacity: 0.5;">â†ª echo: tests retired... ğŸ’¤</div>
<div id="test-ping" style="position: absolute; top: 155px; right: 10px; background: rgba(139,69,19,0.3); border: 1px solid #8B4513; padding: 2px 6px; font-size: 0.5rem; z-index: 100; color: #D2691E;">âš°ï¸ testing complete</div>
<style>
@keyframes pingBlink {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 1; transform: scale(1.02); }
}
</style>
<div id="sandwich-badge" style="position: absolute; top: 230px; right: 10px; background: rgba(210,105,30,0.6); border: 2px solid #D2691E; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFD700; font-weight: bold; animation: sandwichFloat 2s ease-in-out infinite;">ğŸ¥ª LEGENDARY SANDWICH SPAWNED!</div>
<div id="bonjour-badge" style="position: absolute; top: 270px; right: 10px; background: rgba(0,35,149,0.6); border: 2px solid #ED2939; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFFFFF; font-weight: bold; animation: bonjourWave 1.5s ease-in-out infinite;">ğŸ‡«ğŸ‡· BONJOUR! ğŸ¥–</div>
<div id="lol-badge" style="position: absolute; top: 310px; right: 10px; background: rgba(255,255,0,0.5); border: 2px solid #FFD700; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #000; font-weight: bold; animation: lolBounce 0.3s ease-in-out infinite;">ğŸ˜‚ LOL FISH SPAWNED! ğŸ˜‚</div>
<div id="lol-echo" style="position: absolute; top: 340px; right: 10px; background: rgba(255,255,0,0.3); border: 1px dashed #FFD700; padding: 3px 8px; font-size: 0.6rem; z-index: 100; color: #665500; animation: lolEcho 0.5s ease-in-out infinite;">â†ª chat says: lol ğŸ¤£</div>
<style>
@keyframes lolEcho {
  0%, 100% { transform: scale(1); opacity: 0.7; }
  50% { transform: scale(1.05); opacity: 1; }
}
</style>
<div id="banana-badge" style="position: absolute; top: 350px; right: 10px; background: rgba(255,225,0,0.6); border: 2px solid #FFD700; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #4a3000; font-weight: bold; animation: bananaWiggle 0.4s ease-in-out infinite;">ğŸŒ BANANAS ADDED! ğŸŒ</div>
<div id="grandma-badge" style="position: absolute; top: 390px; right: 10px; background: rgba(255,182,193,0.6); border: 2px solid #DDA0DD; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #8B4513; font-weight: bold; animation: grandmaRock 2s ease-in-out infinite;">ğŸ‘µ GRANDMA SAYS HI! ğŸ§¶</div>
<div id="rouge-badge" style="position: absolute; top: 430px; right: 10px; background: rgba(255,0,0,0.5); border: 2px solid #CC0000; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFF; font-weight: bold; animation: rougePulse 1s ease-in-out infinite;">ğŸŸ¥ BLOC ROUGE AJOUTÃ‰! ğŸŸ¥</div>
<div id="bloc-badge" style="position: absolute; top: 470px; right: 10px; background: linear-gradient(90deg, rgba(255,0,0,0.4), rgba(255,165,0,0.4), rgba(255,255,0,0.4), rgba(0,255,0,0.4), rgba(0,191,255,0.4)); border: 2px solid #FFF; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFF; font-weight: bold; text-shadow: 1px 1px 2px #000; animation: blocShimmer 2s ease-in-out infinite;">ğŸ§± BLOC MONUMENT ERECTED! ğŸ§±</div>
<div id="kids-badge" style="position: absolute; top: 510px; right: 10px; background: rgba(255,182,193,0.5); border: 2px solid #FF69B4; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFF; font-weight: bold; animation: kidsPlay 0.6s ease-in-out infinite;">ğŸ‘§ğŸ‘¦ ENFANTS QUI JOUENT! ğŸˆ</div>
<div id="anatole-badge" style="position: absolute; top: 550px; right: 10px; background: linear-gradient(135deg, rgba(65,105,225,0.7), rgba(255,215,0,0.7)); border: 2px solid #FFD700; padding: 5px 10px; font-size: 0.7rem; z-index: 100; color: #FFF; font-weight: bold; text-shadow: 1px 1px 2px #000; animation: anatolePulse 1.5s ease-in-out infinite;">ğŸ‘‹ HI ANATOLE! ğŸ°</div>
<style>
@keyframes anatolePulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 10px #FFD700; }
  50% { transform: scale(1.05); box-shadow: 0 0 20px #00FFFF; }
}
</style>
<style>
@keyframes kidsPlay {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}
</style>
<style>
@keyframes blocShimmer {
  0%, 100% { filter: hue-rotate(0deg); }
  50% { filter: hue-rotate(30deg); }
}
</style>
<style>
@keyframes rougePulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 5px #FF0000; }
  50% { transform: scale(1.05); box-shadow: 0 0 15px #FF0000; }
}
</style>
<style>
@keyframes grandmaRock {
  0%, 100% { transform: rotate(-2deg); }
  50% { transform: rotate(2deg); }
}
</style>
<style>
@keyframes bananaWiggle {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}
</style>
<style>
@keyframes lolBounce {
  0%, 100% { transform: scale(1) rotate(-2deg); }
  50% { transform: scale(1.1) rotate(2deg); }
}
</style>
<style>
@keyframes bonjourWave {
  0%, 100% { transform: rotate(-3deg); }
  50% { transform: rotate(3deg); }
}
</style>
<style>
@keyframes sandwichFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}
</style>
<style>
@keyframes echoFade {
  0%, 100% { opacity: 0.3; transform: translateX(0); }
  50% { opacity: 0.8; transform: translateX(-3px); }
}
</style>
<style>
@keyframes testPulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}
</style>
</div>
<script>
        // Three.js Minecraft World
        let scene, camera, renderer, controls;
        let blocks = [];
        let mobs = [];
        let blockCount = 0;
        let time = 0;
        
        // USER PERSONAL SPACES SYSTEM
        let userPlots = {};
        let plotColors = [0xFF6B6B, 0x6BFF6B, 0x6B6BFF, 0xFFFF6B, 0xFF6BFF, 0x6BFFFF, 0xFFAA6B, 0xAA6BFF];
        let nextPlotIndex = 0;
        const userNames = ['StreamerPro', 'BlockMaster42', 'FishLover99', 'MinecraftFan', 'TwitchViewer1', 'CoolBuilder', 'OceanExplorer', 'VoxelKing'];
        
        // Mouse controls
        let isDragging = false;
        
        // PLAYER CONTROLS - EXPLORE THE WORLD!
        let playerMode = false;
        let playerPos = { x: 0, y: 5, z: 10 };
        let playerVelocity = { x: 0, y: 0, z: 0 };
        let playerYaw = 0;
        let playerPitch = 0;
        let isJumping = false;
        let isSprinting = false;
        let keys = {};
        let pointerLocked = false;
        
        // Player character (Steve-like)
        let playerMesh = null;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { x: 0.5, y: 0.3 };
        let cameraDistance = 50;
        
        init();
        animate();
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // Create Minecraft terrain
            createTerrain();
            
            // Add legacy creatures as Minecraft mobs
            createVoxelMario(0, 3, 5);
            createVoxelFish(5, 8, 3);
            createVoxelFish(-8, 10, -5);
            createVoxelFish(12, 6, 8);
            createVoxelShark(0, 4, 0);
            createVoxelWerewolfRabbit(-10, 2, 5);
            createVoxelGreeter(8, 12, -3);
            
            // BOWSER - The King of Koopas who slew Mario!
            createVoxelBowser(5, 3, 8);
            
            // A LEGENDARY SANDWICH - Rare food drop!
            createVoxelSandwich(-5, 6, -8);
            
            // FRENCH FISH - Bonjour villager!
            createVoxelFrenchFish(-12, 8, 10);
            
            // LOL FISH - The rare laughing fish!
            createVoxelLolFish(15, 7, -10);
            
            // BANANAS - Tropical fruit invasion!
            createVoxelBanana(10, 5, 12);
            createVoxelBanana(-8, 7, -12);
            createVoxelBanana(0, 9, 15);
            
            // GRANDMA - The wise village elder!
            createVoxelGrandma(-5, 2, 3);
            
            // BLOC ROUGE - A mysterious red block from the French request!
            const blocRouge = createBlock(7, 8, -5, 0xFF0000);
            
            // ENFANTS QUI JOUENT - Playful children running around!
            createVoxelChild(-3, 2, -5, 0xFF69B4, 'girl'); // Pink dress girl
            createVoxelChild(4, 2, -3, 0x4169E1, 'boy'); // Blue shirt boy
            createVoxelChild(-6, 2, 2, 0x32CD32, 'boy'); // Green shirt boy
            
            // ANATOLE'S GREETING TOWER - A grand monument saying HI!
            createAnatoleTower(12, 3, -12);
            
            // THE BLOC MONUMENT - A tower of colorful blocks!
            createBlocMonument(-15, 3, -15);
            blocRouge.userData = { isBlocRouge: true, floatPhase: 0 };
            blocRouge.scale.set(1.2, 1.2, 1.2);
            
            // Add trees
            createTree(10, 0, 10);
            
            // RETIRED TEST MONUMENT - The testing era has ended!
            const testTombstone = createBlock(0, 15, 0, 0x808080);
            testTombstone.userData = { isTombstone: true, restPhase: 0 };
            testTombstone.scale.set(1.5, 2, 0.5);
            
            // MEMORIAL FLOWERS - In honor of all the tests
            const flower1 = createBlock(-1, 14, 0.5, 0xFF69B4);
            flower1.userData = { isFlower: true };
            flower1.scale.set(0.3, 0.3, 0.3);
            const flower2 = createBlock(1, 14, 0.5, 0xFFFF00);
            flower2.userData = { isFlower: true };
            flower2.scale.set(0.3, 0.3, 0.3);
            
            // PEACE DOVE - Testing is finally at rest
            const dove = createBlock(0, 17, 0, 0xFFFFFF);
            dove.userData = { isDove: true, flyPhase: 0 };
            dove.scale.set(0.6, 0.4, 0.8);
            createTree(-12, 0, 8);
            createTree(5, 0, -15);
            createTree(-8, 0, -10);
            
            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            window.addEventListener('resize', onWindowResize);
            
            // Keyboard controls for player mode
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'ShiftLeft') isSprinting = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'ShiftLeft') isSprinting = false;
            });
            
            // Pointer lock for first-person
            renderer.domElement.addEventListener('click', () => {
                if (playerMode && !pointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            document.addEventListener('pointerlockchange', () => {
                pointerLocked = document.pointerLockElement === renderer.domElement;
            });
            document.addEventListener('mousemove', onPlayerLook);
            
            // Create player mesh
            createPlayerCharacter();
        }
        
        function createBlockMaterial(color) {
            return new THREE.MeshLambertMaterial({ 
                color: color,
                flatShading: true
            });
        }
        
        function createBlock(x, y, z, color, size = 1) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = createBlockMaterial(color);
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            blocks.push(block);
            blockCount++;
            return block;
        }
        
        function createTerrain() {
            // Grass layer
            for (let x = -20; x <= 20; x++) {
                for (let z = -20; z <= 20; z++) {
                    const height = Math.floor(Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2);
                    createBlock(x, height, z, 0x4CAF50); // Grass
                    // Dirt below
                    for (let y = height - 1; y >= height - 2; y--) {
                        createBlock(x, y, z, 0x8B4513); // Dirt
                    }
                    // Stone deep below
                    createBlock(x, height - 3, z, 0x808080);
                }
            }
            
            // THE GREAT SEA - Vast ocean surrounding the island
            const seaBlocks = [];
            for (let x = -30; x <= 30; x++) {
                for (let z = -30; z <= 30; z++) {
                    // Create sea around the island (leave center as land)
                    const distFromCenter = Math.sqrt(x*x + z*z);
                    if (distFromCenter > 12) {
                        // Deep ocean - multiple layers
                        for (let depth = 0; depth >= -4; depth--) {
                            const waterBlock = createBlock(x, depth, z, depth === 0 ? 0x1E90FF : 0x0066CC);
                            waterBlock.material.transparent = true;
                            waterBlock.material.opacity = depth === 0 ? 0.6 : 0.8;
                            waterBlock.userData = { isWater: true, baseY: depth, waveOffset: x * 0.5 + z * 0.3 };
                            seaBlocks.push(waterBlock);
                        }
                        // Sandy ocean floor
                        createBlock(x, -5, z, 0xC2B280);
                    } else if (distFromCenter > 8) {
                        // Shallow beach water
                        const waterBlock = createBlock(x, 0, z, 0x40E0D0);
                        waterBlock.material.transparent = true;
                        waterBlock.material.opacity = 0.5;
                        waterBlock.userData = { isWater: true, baseY: 0, waveOffset: x * 0.5 + z * 0.3 };
                        seaBlocks.push(waterBlock);
                    }
                }
            }
            
            // Store sea blocks for wave animation
            window.seaBlocks = seaBlocks;
            
            // Add coral and seaweed decorations
            const coralColors = [0xFF6B6B, 0xFF69B4, 0xFFA500, 0x9370DB];
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 15 + Math.random() * 10;
                const cx = Math.cos(angle) * dist;
                const cz = Math.sin(angle) * dist;
                const coral = createBlock(cx, -4, cz, coralColors[Math.floor(Math.random() * coralColors.length)]);
                coral.scale.set(0.5 + Math.random() * 0.5, 1 + Math.random() * 2, 0.5 + Math.random() * 0.5);
            }
            
            // Seaweed patches
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 14 + Math.random() * 12;
                const sx = Math.cos(angle) * dist;
                const sz = Math.sin(angle) * dist;
                for (let h = 0; h < 3 + Math.floor(Math.random() * 3); h++) {
                    const seaweed = createBlock(sx, -4 + h, sz, 0x228B22);
                    seaweed.scale.set(0.3, 1, 0.3);
                    seaweed.userData = { isSeaweed: true, swayOffset: i + h };
                }
            }
        }
        
        function createTree(x, baseY, z) {
            // Trunk
            for (let y = 1; y <= 5; y++) {
                createBlock(x, baseY + y, z, 0x8B4513);
            }
            // Leaves
            for (let lx = -2; lx <= 2; lx++) {
                for (let lz = -2; lz <= 2; lz++) {
                    for (let ly = 0; ly <= 2; ly++) {
                        if (Math.abs(lx) + Math.abs(lz) + ly < 4) {
                            createBlock(x + lx, baseY + 5 + ly, z + lz, 0x228B22);
                        }
                    }
                }
            }
        }
        
        function createVoxelFish(x, y, z) {
            const fish = new THREE.Group();
            
            // Body (cyan/blue blocks)
            const colors = [0x00CED1, 0x40E0D0, 0x48D1CC];
            const bodyColor = colors[Math.floor(Math.random() * colors.length)];
            
            for (let i = 0; i < 4; i++) {
                const block = createBlock(0, 0, 0, bodyColor);
                block.position.set(i - 1.5, 0, 0);
                fish.add(block);
            }
            // Tail
            const tail = createBlock(0, 0, 0, bodyColor);
            tail.position.set(-2.5, 0.5, 0);
            tail.scale.set(0.5, 0.5, 0.5);
            fish.add(tail);
            
            // Eye
            const eye = createBlock(0, 0, 0, 0xFFFFFF);
            eye.position.set(1.5, 0.3, 0.5);
            eye.scale.set(0.3, 0.3, 0.3);
            fish.add(eye);
            
            // Fins (wings)
            const fin1 = createBlock(0, 0, 0, 0x87CEEB);
            fin1.position.set(0, 1, 0);
            fin1.scale.set(1.5, 0.2, 0.5);
            fish.add(fin1);
            
            fish.position.set(x, y, z);
            fish.userData = { type: 'fish', vx: (Math.random() - 0.5) * 0.1, vy: 0, baseY: y };
            scene.add(fish);
            mobs.push(fish);
        }
        
        function createVoxelShark(x, y, z) {
            const shark = new THREE.Group();
            
            // Body (gray blocks)
            for (let i = 0; i < 6; i++) {
                const block = createBlock(0, 0, 0, 0x708090);
                block.position.set(i - 2.5, 0, 0);
                shark.add(block);
            }
            // Dorsal fin
            const fin = createBlock(0, 0, 0, 0x5F6A6A);
            fin.position.set(0, 1, 0);
            fin.scale.set(0.5, 1, 0.3);
            shark.add(fin);
            
            // Tail
            const tail = createBlock(0, 0, 0, 0x5F6A6A);
            tail.position.set(-3.5, 0.5, 0);
            tail.scale.set(0.5, 1.5, 0.3);
            shark.add(tail);
            
            // Teeth (white blocks)
            for (let i = 0; i < 3; i++) {
                const tooth = createBlock(0, 0, 0, 0xFFFFFF);
                tooth.position.set(3 + i * 0.2, -0.3, 0.3);
                tooth.scale.set(0.15, 0.3, 0.15);
                shark.add(tooth);
            }
            
            // Red eye
            const eye = createBlock(0, 0, 0, 0xFF0000);
            eye.position.set(2.5, 0.3, 0.5);
            eye.scale.set(0.25, 0.25, 0.25);
            shark.add(eye);
            
            shark.position.set(x, y, z);
            shark.userData = { type: 'shark', vx: (Math.random() - 0.5) * 0.05, angle: 0 };
            scene.add(shark);
            mobs.push(shark);
        }
        
        function createVoxelWerewolfRabbit(x, y, z) {
            const werewolf = new THREE.Group();
            
            // Body (dark purple)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    const block = createBlock(0, 0, 0, 0x2D1B36);
                    block.position.set(i - 1, j, 0);
                    werewolf.add(block);
                }
            }
            
            // Head
            const head = createBlock(0, 0, 0, 0x3D2B46);
            head.position.set(1.5, 2, 0);
            werewolf.add(head);
            
            // Ears (tall and pointy)
            const ear1 = createBlock(0, 0, 0, 0x3D2B46);
            ear1.position.set(1.2, 3.5, 0.3);
            ear1.scale.set(0.3, 1.5, 0.3);
            werewolf.add(ear1);
            
            const ear2 = createBlock(0, 0, 0, 0x3D2B46);
            ear2.position.set(1.8, 3.5, 0.3);
            ear2.scale.set(0.3, 1.5, 0.3);
            werewolf.add(ear2);
            
            // Glowing red eyes
            const eye1 = createBlock(0, 0, 0, 0xFF0000);
            eye1.position.set(1.8, 2.2, 0.5);
            eye1.scale.set(0.2, 0.2, 0.2);
            werewolf.add(eye1);
            
            const eye2 = createBlock(0, 0, 0, 0xFF0000);
            eye2.position.set(2.1, 2.2, 0.5);
            eye2.scale.set(0.2, 0.2, 0.2);
            werewolf.add(eye2);
            
            // Fangs
            const fang1 = createBlock(0, 0, 0, 0xFFFFFF);
            fang1.position.set(2, 1.7, 0.5);
            fang1.scale.set(0.1, 0.3, 0.1);
            werewolf.add(fang1);
            
            // Legs
            const leg1 = createBlock(0, 0, 0, 0x2D1B36);
            leg1.position.set(-0.5, -1, 0.3);
            leg1.scale.set(0.4, 1, 0.4);
            werewolf.add(leg1);
            
            const leg2 = createBlock(0, 0, 0, 0x2D1B36);
            leg2.position.set(0.5, -1, 0.3);
            leg2.scale.set(0.4, 1, 0.4);
            werewolf.add(leg2);
            
            werewolf.position.set(x, y, z);
            werewolf.userData = { type: 'werewolf', vx: (Math.random() - 0.5) * 0.03, howlTime: 0 };
            scene.add(werewolf);
            mobs.push(werewolf);
        }
        
        function createVoxelMario(x, y, z) {
            const mario = new THREE.Group();
            
            // Red cap
            const cap1 = createBlock(0, 0, 0, 0xFF0000);
            cap1.position.set(0, 3.5, 0);
            mario.add(cap1);
            const cap2 = createBlock(0, 0, 0, 0xFF0000);
            cap2.position.set(0.5, 3.5, 0);
            cap2.scale.set(0.5, 0.5, 1);
            mario.add(cap2);
            const capBrim = createBlock(0, 0, 0, 0xFF0000);
            capBrim.position.set(0.8, 3, 0);
            capBrim.scale.set(0.5, 0.3, 1);
            mario.add(capBrim);
            
            // Face (skin color)
            const face = createBlock(0, 0, 0, 0xFFD8B0);
            face.position.set(0, 2.5, 0);
            mario.add(face);
            
            // Mustache
            const mustache = createBlock(0, 0, 0, 0x4A3728);
            mustache.position.set(0.3, 2.3, 0.5);
            mustache.scale.set(0.8, 0.2, 0.2);
            mario.add(mustache);
            
            // Eyes
            const eye1 = createBlock(0, 0, 0, 0x000000);
            eye1.position.set(0.2, 2.7, 0.5);
            eye1.scale.set(0.15, 0.15, 0.15);
            mario.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0x000000);
            eye2.position.set(-0.2, 2.7, 0.5);
            eye2.scale.set(0.15, 0.15, 0.15);
            mario.add(eye2);
            
            // Nose
            const nose = createBlock(0, 0, 0, 0xFFD8B0);
            nose.position.set(0, 2.5, 0.6);
            nose.scale.set(0.4, 0.3, 0.3);
            mario.add(nose);
            
            // Blue overalls body
            const body1 = createBlock(0, 0, 0, 0x0000FF);
            body1.position.set(0, 1.5, 0);
            mario.add(body1);
            const body2 = createBlock(0, 0, 0, 0x0000FF);
            body2.position.set(0, 0.5, 0);
            mario.add(body2);
            
            // Red shirt visible on sides
            const shirt1 = createBlock(0, 0, 0, 0xFF0000);
            shirt1.position.set(0.6, 1.5, 0);
            shirt1.scale.set(0.4, 1, 0.8);
            mario.add(shirt1);
            const shirt2 = createBlock(0, 0, 0, 0xFF0000);
            shirt2.position.set(-0.6, 1.5, 0);
            shirt2.scale.set(0.4, 1, 0.8);
            mario.add(shirt2);
            
            // Yellow buttons
            const button1 = createBlock(0, 0, 0, 0xFFD700);
            button1.position.set(0.3, 1.7, 0.5);
            button1.scale.set(0.15, 0.15, 0.15);
            mario.add(button1);
            const button2 = createBlock(0, 0, 0, 0xFFD700);
            button2.position.set(-0.3, 1.7, 0.5);
            button2.scale.set(0.15, 0.15, 0.15);
            mario.add(button2);
            
            // Brown shoes
            const shoe1 = createBlock(0, 0, 0, 0x8B4513);
            shoe1.position.set(0.3, -0.3, 0.2);
            shoe1.scale.set(0.5, 0.4, 0.8);
            mario.add(shoe1);
            const shoe2 = createBlock(0, 0, 0, 0x8B4513);
            shoe2.position.set(-0.3, -0.3, 0.2);
            shoe2.scale.set(0.5, 0.4, 0.8);
            mario.add(shoe2);
            
            // White gloves/hands
            const hand1 = createBlock(0, 0, 0, 0xFFFFFF);
            hand1.position.set(0.9, 1, 0);
            hand1.scale.set(0.3, 0.3, 0.3);
            mario.add(hand1);
            const hand2 = createBlock(0, 0, 0, 0xFFFFFF);
            hand2.position.set(-0.9, 1, 0);
            hand2.scale.set(0.3, 0.3, 0.3);
            mario.add(hand2);
            
            mario.position.set(x, y, z);
            mario.userData = { type: 'mario', vx: 0, jumpTimer: 0, baseY: y, isJumping: false, isDead: true, deathTime: 0 };
            
            // Mario's ghost rising effect - he's been slain!
            mario.rotation.x = Math.PI / 2; // Fallen over
            scene.add(mario);
            mobs.push(mario);
        }
        
        function createVoxelBowser(x, y, z) {
            const bowser = new THREE.Group();
            
            // Massive green body
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    const block = createBlock(0, 0, 0, 0x228B22);
                    block.position.set(i - 1.5, j, 0);
                    bowser.add(block);
                }
            }
            
            // Yellow belly
            for (let j = 0; j < 2; j++) {
                const belly = createBlock(0, 0, 0, 0xFFD700);
                belly.position.set(0.5, j, 0.5);
                belly.scale.set(1.5, 1, 0.2);
                bowser.add(belly);
            }
            
            // Spiked shell (brown with spikes)
            const shell = createBlock(0, 0, 0, 0x8B4513);
            shell.position.set(0, 1.5, -0.8);
            shell.scale.set(3, 2, 1.5);
            bowser.add(shell);
            
            // Spikes on shell
            for (let i = 0; i < 5; i++) {
                const spike = createBlock(0, 0, 0, 0xFFFFFF);
                spike.position.set(-1.5 + i * 0.8, 2.5 + (i % 2) * 0.3, -0.8);
                spike.scale.set(0.3, 0.8, 0.3);
                bowser.add(spike);
            }
            
            // Big scary head
            const head = createBlock(0, 0, 0, 0x228B22);
            head.position.set(2.5, 2, 0);
            head.scale.set(1.5, 1.5, 1.5);
            bowser.add(head);
            
            // Horns
            const horn1 = createBlock(0, 0, 0, 0xFFFFFF);
            horn1.position.set(2, 3.5, 0.3);
            horn1.scale.set(0.3, 0.8, 0.3);
            bowser.add(horn1);
            const horn2 = createBlock(0, 0, 0, 0xFFFFFF);
            horn2.position.set(3, 3.5, 0.3);
            horn2.scale.set(0.3, 0.8, 0.3);
            bowser.add(horn2);
            
            // Angry red eyes
            const eye1 = createBlock(0, 0, 0, 0xFF0000);
            eye1.position.set(2.8, 2.3, 0.8);
            eye1.scale.set(0.4, 0.3, 0.2);
            bowser.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0xFF0000);
            eye2.position.set(2.2, 2.3, 0.8);
            eye2.scale.set(0.4, 0.3, 0.2);
            bowser.add(eye2);
            
            // Fire breath!
            for (let f = 0; f < 3; f++) {
                const fire = createBlock(0, 0, 0, f === 0 ? 0xFF0000 : (f === 1 ? 0xFF6600 : 0xFFFF00));
                fire.position.set(3.5 + f * 0.5, 1.8, 0);
                fire.scale.set(0.5 - f * 0.1, 0.5 - f * 0.1, 0.5 - f * 0.1);
                fire.userData = { isFire: true, fireIndex: f };
                bowser.add(fire);
            }
            
            // Tail
            const tail = createBlock(0, 0, 0, 0x228B22);
            tail.position.set(-2.5, 0.5, 0);
            tail.scale.set(1.5, 0.5, 0.5);
            bowser.add(tail);
            const tailSpike = createBlock(0, 0, 0, 0xFFFFFF);
            tailSpike.position.set(-3.5, 0.5, 0);
            tailSpike.scale.set(0.5, 0.3, 0.3);
            bowser.add(tailSpike);
            
            bowser.position.set(x, y, z);
            bowser.userData = { type: 'bowser', angle: 0 };
            scene.add(bowser);
            mobs.push(bowser);
        }
        
        function createVoxelSandwich(x, y, z) {
            const sandwich = new THREE.Group();
            
            // Bottom bread (golden brown)
            const bottomBread = createBlock(0, 0, 0, 0xD2691E);
            bottomBread.position.set(0, 0, 0);
            bottomBread.scale.set(2, 0.4, 1.5);
            sandwich.add(bottomBread);
            
            // Lettuce (green wavy)
            const lettuce = createBlock(0, 0, 0, 0x32CD32);
            lettuce.position.set(0, 0.4, 0);
            lettuce.scale.set(2.2, 0.2, 1.6);
            sandwich.add(lettuce);
            
            // Tomato slices (red)
            const tomato = createBlock(0, 0, 0, 0xFF6347);
            tomato.position.set(0, 0.6, 0);
            tomato.scale.set(1.8, 0.2, 1.4);
            sandwich.add(tomato);
            
            // Cheese (yellow)
            const cheese = createBlock(0, 0, 0, 0xFFD700);
            cheese.position.set(0, 0.8, 0);
            cheese.scale.set(2, 0.15, 1.5);
            sandwich.add(cheese);
            
            // Mystery meat (pink/brown)
            const meat = createBlock(0, 0, 0, 0xCD853F);
            meat.position.set(0, 1, 0);
            meat.scale.set(1.9, 0.3, 1.4);
            sandwich.add(meat);
            
            // Top bread (golden brown with sesame seeds)
            const topBread = createBlock(0, 0, 0, 0xD2691E);
            topBread.position.set(0, 1.4, 0);
            topBread.scale.set(2, 0.5, 1.5);
            sandwich.add(topBread);
            
            // Sesame seeds
            for (let i = 0; i < 5; i++) {
                const seed = createBlock(0, 0, 0, 0xFFFACD);
                seed.position.set((Math.random() - 0.5) * 1.5, 1.7, (Math.random() - 0.5) * 1);
                seed.scale.set(0.1, 0.05, 0.1);
                sandwich.add(seed);
            }
            
            // Toothpick flag on top!
            const toothpick = createBlock(0, 0, 0, 0x8B4513);
            toothpick.position.set(0, 2.2, 0);
            toothpick.scale.set(0.08, 1.5, 0.08);
            sandwich.add(toothpick);
            
            const flag = createBlock(0, 0, 0, 0xFF0000);
            flag.position.set(0.2, 2.8, 0);
            flag.scale.set(0.4, 0.3, 0.05);
            sandwich.add(flag);
            
            sandwich.position.set(x, y, z);
            sandwich.userData = { type: 'sandwich', floatOffset: Math.random() * Math.PI * 2, spinSpeed: 0.02 };
            scene.add(sandwich);
            mobs.push(sandwich);
        }
        
        function createVoxelFrenchFish(x, y, z) {
            const frenchFish = new THREE.Group();
            
            // Body (blue like the French flag)
            for (let i = 0; i < 4; i++) {
                const block = createBlock(0, 0, 0, 0x0055A4);
                block.position.set(i - 1.5, 0, 0);
                frenchFish.add(block);
            }
            
            // White stripe
            const whiteStripe = createBlock(0, 0, 0, 0xFFFFFF);
            whiteStripe.position.set(0, 0, 0.5);
            whiteStripe.scale.set(1.5, 0.8, 0.1);
            frenchFish.add(whiteStripe);
            
            // Red stripe
            const redStripe = createBlock(0, 0, 0, 0xED2939);
            redStripe.position.set(1.2, 0, 0.5);
            redStripe.scale.set(0.8, 0.8, 0.1);
            frenchFish.add(redStripe);
            
            // Beret (trÃ¨s franÃ§ais!)
            const beret = createBlock(0, 0, 0, 0x1a1a1a);
            beret.position.set(1.5, 0.8, 0);
            beret.scale.set(1.2, 0.3, 1.2);
            frenchFish.add(beret);
            
            const beretTop = createBlock(0, 0, 0, 0x1a1a1a);
            beretTop.position.set(1.3, 1, 0);
            beretTop.scale.set(0.8, 0.2, 0.8);
            frenchFish.add(beretTop);
            
            // Tiny baguette
            const baguette = createBlock(0, 0, 0, 0xD2691E);
            baguette.position.set(-0.5, -0.5, 0.5);
            baguette.scale.set(1.5, 0.2, 0.2);
            frenchFish.add(baguette);
            
            // Mustache (oui oui!)
            const mustache = createBlock(0, 0, 0, 0x2F2F2F);
            mustache.position.set(1.8, -0.1, 0.6);
            mustache.scale.set(0.6, 0.15, 0.1);
            frenchFish.add(mustache);
            
            // Eye with charm
            const eye = createBlock(0, 0, 0, 0xFFFFFF);
            eye.position.set(1.8, 0.3, 0.5);
            eye.scale.set(0.3, 0.3, 0.2);
            frenchFish.add(eye);
            
            const pupil = createBlock(0, 0, 0, 0x000000);
            pupil.position.set(1.9, 0.3, 0.6);
            pupil.scale.set(0.15, 0.15, 0.1);
            frenchFish.add(pupil);
            
            frenchFish.position.set(x, y, z);
            frenchFish.userData = { type: 'frenchfish', vx: 0.03, baseY: y, bonjourTimer: 0 };
            scene.add(frenchFish);
            mobs.push(frenchFish);
        }
        
        function createVoxelLolFish(x, y, z) {
            const lolFish = new THREE.Group();
            
            // Body (bright yellow - comedy gold!)
            for (let i = 0; i < 4; i++) {
                const block = createBlock(0, 0, 0, 0xFFFF00);
                block.position.set(i - 1.5, 0, 0);
                lolFish.add(block);
            }
            
            // Big goofy smile
            const smile = createBlock(0, 0, 0, 0xFF69B4);
            smile.position.set(1.2, -0.3, 0.5);
            smile.scale.set(0.8, 0.2, 0.1);
            lolFish.add(smile);
            
            // Tear of joy drops
            const tear1 = createBlock(0, 0, 0, 0x00BFFF);
            tear1.position.set(1.5, 0.1, 0.6);
            tear1.scale.set(0.15, 0.25, 0.1);
            tear1.userData = { isTear: true, tearOffset: 0 };
            lolFish.add(tear1);
            
            const tear2 = createBlock(0, 0, 0, 0x00BFFF);
            tear2.position.set(1.9, 0.1, 0.6);
            tear2.scale.set(0.15, 0.25, 0.1);
            tear2.userData = { isTear: true, tearOffset: 0.5 };
            lolFish.add(tear2);
            
            // Squinting happy eyes
            const eye1 = createBlock(0, 0, 0, 0x000000);
            eye1.position.set(1.5, 0.4, 0.5);
            eye1.scale.set(0.4, 0.1, 0.2);
            lolFish.add(eye1);
            
            const eye2 = createBlock(0, 0, 0, 0x000000);
            eye2.position.set(1.9, 0.4, 0.5);
            eye2.scale.set(0.4, 0.1, 0.2);
            lolFish.add(eye2);
            
            // Tail wagging from laughter
            const tail = createBlock(0, 0, 0, 0xFFD700);
            tail.position.set(-2.5, 0.5, 0);
            tail.scale.set(0.5, 0.8, 0.5);
            lolFish.add(tail);
            
            lolFish.position.set(x, y, z);
            lolFish.userData = { type: 'lolfish', vx: 0.06, baseY: y, laughTimer: 0 };
            scene.add(lolFish);
            mobs.push(lolFish);
        }
        
        function createVoxelBanana(x, y, z) {
            const banana = new THREE.Group();
            
            // Curved banana body (yellow blocks in arc)
            const bananaColors = [0xFFE135, 0xFFD700, 0xFFE135];
            
            // Main curved banana shape
            for (let i = 0; i < 5; i++) {
                const block = createBlock(0, 0, 0, 0xFFE135);
                block.position.set(i - 2, Math.sin(i * 0.5) * 0.8, 0);
                block.scale.set(0.6, 0.5, 0.4);
                banana.add(block);
            }
            
            // Brown tips
            const tip1 = createBlock(0, 0, 0, 0x4a3000);
            tip1.position.set(-2.5, 0, 0);
            tip1.scale.set(0.3, 0.3, 0.3);
            banana.add(tip1);
            
            const tip2 = createBlock(0, 0, 0, 0x4a3000);
            tip2.position.set(2.5, Math.sin(2.5) * 0.8, 0);
            tip2.scale.set(0.3, 0.3, 0.3);
            banana.add(tip2);
            
            // Cute face on banana
            const eye1 = createBlock(0, 0, 0, 0x000000);
            eye1.position.set(0.5, 0.5, 0.3);
            eye1.scale.set(0.15, 0.15, 0.1);
            banana.add(eye1);
            
            const eye2 = createBlock(0, 0, 0, 0x000000);
            eye2.position.set(-0.3, 0.5, 0.3);
            eye2.scale.set(0.15, 0.15, 0.1);
            banana.add(eye2);
            
            const smile = createBlock(0, 0, 0, 0x4a3000);
            smile.position.set(0.1, 0.2, 0.3);
            smile.scale.set(0.4, 0.1, 0.1);
            banana.add(smile);
            
            banana.position.set(x, y, z);
            banana.userData = { type: 'banana', floatOffset: Math.random() * Math.PI * 2, wobble: 0 };
            scene.add(banana);
            mobs.push(banana);
        }
        
        function createVoxelGrandma(x, y, z) {
            const grandma = new THREE.Group();
            
            // Rocking chair base (brown wood)
            const chairBase = createBlock(0, 0, 0, 0x8B4513);
            chairBase.position.set(0, -0.5, 0);
            chairBase.scale.set(1.5, 0.3, 1.5);
            grandma.add(chairBase);
            
            // Chair back
            const chairBack = createBlock(0, 0, 0, 0x8B4513);
            chairBack.position.set(0, 0.5, -0.6);
            chairBack.scale.set(1.3, 1.5, 0.2);
            grandma.add(chairBack);
            
            // Grandma's body (lavender dress)
            const body = createBlock(0, 0, 0, 0xE6E6FA);
            body.position.set(0, 0.3, 0);
            body.scale.set(1, 1.2, 0.8);
            grandma.add(body);
            
            // Head (warm skin tone)
            const head = createBlock(0, 0, 0, 0xFFDFC4);
            head.position.set(0, 1.3, 0);
            head.scale.set(0.7, 0.7, 0.7);
            grandma.add(head);
            
            // Gray hair bun
            const hair = createBlock(0, 0, 0, 0xC0C0C0);
            hair.position.set(0, 1.7, -0.1);
            hair.scale.set(0.6, 0.4, 0.5);
            grandma.add(hair);
            
            // Glasses (tiny gold frames)
            const glasses1 = createBlock(0, 0, 0, 0xFFD700);
            glasses1.position.set(0.2, 1.35, 0.35);
            glasses1.scale.set(0.25, 0.15, 0.05);
            grandma.add(glasses1);
            const glasses2 = createBlock(0, 0, 0, 0xFFD700);
            glasses2.position.set(-0.2, 1.35, 0.35);
            glasses2.scale.set(0.25, 0.15, 0.05);
            grandma.add(glasses2);
            
            // Kind eyes
            const eye1 = createBlock(0, 0, 0, 0x4169E1);
            eye1.position.set(0.2, 1.35, 0.4);
            eye1.scale.set(0.1, 0.1, 0.05);
            grandma.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0x4169E1);
            eye2.position.set(-0.2, 1.35, 0.4);
            eye2.scale.set(0.1, 0.1, 0.05);
            grandma.add(eye2);
            
            // Warm smile
            const smile = createBlock(0, 0, 0, 0xFFB6C1);
            smile.position.set(0, 1.15, 0.4);
            smile.scale.set(0.3, 0.1, 0.05);
            grandma.add(smile);
            
            // Knitting needles
            const needle1 = createBlock(0, 0, 0, 0xC0C0C0);
            needle1.position.set(0.5, 0.5, 0.4);
            needle1.scale.set(0.05, 0.8, 0.05);
            needle1.rotation.z = 0.3;
            grandma.add(needle1);
            const needle2 = createBlock(0, 0, 0, 0xC0C0C0);
            needle2.position.set(-0.3, 0.5, 0.4);
            needle2.scale.set(0.05, 0.8, 0.05);
            needle2.rotation.z = -0.3;
            grandma.add(needle2);
            
            // Ball of yarn (pink)
            const yarn = createBlock(0, 0, 0, 0xFF69B4);
            yarn.position.set(0.6, -0.2, 0.3);
            yarn.scale.set(0.4, 0.4, 0.4);
            grandma.add(yarn);
            
            // Cozy shawl (purple)
            const shawl = createBlock(0, 0, 0, 0xDDA0DD);
            shawl.position.set(0, 0.8, -0.2);
            shawl.scale.set(1.2, 0.4, 0.6);
            grandma.add(shawl);
            
            grandma.position.set(x, y, z);
            grandma.userData = { type: 'grandma', rockTimer: 0 };
            scene.add(grandma);
            mobs.push(grandma);
        }
        
        function createVoxelChild(x, y, z, shirtColor, type) {
            const child = new THREE.Group();
            
            // Head (cute round face)
            const head = createBlock(0, 0, 0, 0xFFDFC4);
            head.position.set(0, 1.8, 0);
            head.scale.set(0.6, 0.6, 0.6);
            child.add(head);
            
            // Hair
            const hairColor = type === 'girl' ? 0x8B4513 : 0x2F2F2F;
            const hair = createBlock(0, 0, 0, hairColor);
            hair.position.set(0, 2.1, 0);
            hair.scale.set(0.65, 0.3, 0.65);
            child.add(hair);
            
            // Cute pigtails for girl
            if (type === 'girl') {
                const pigtail1 = createBlock(0, 0, 0, hairColor);
                pigtail1.position.set(0.35, 1.9, 0);
                pigtail1.scale.set(0.2, 0.4, 0.2);
                child.add(pigtail1);
                const pigtail2 = createBlock(0, 0, 0, hairColor);
                pigtail2.position.set(-0.35, 1.9, 0);
                pigtail2.scale.set(0.2, 0.4, 0.2);
                child.add(pigtail2);
            }
            
            // Happy eyes
            const eye1 = createBlock(0, 0, 0, 0x000000);
            eye1.position.set(0.15, 1.85, 0.3);
            eye1.scale.set(0.1, 0.1, 0.05);
            child.add(eye1);
            const eye2 = createBlock(0, 0, 0, 0x000000);
            eye2.position.set(-0.15, 1.85, 0.3);
            eye2.scale.set(0.1, 0.1, 0.05);
            child.add(eye2);
            
            // Big smile
            const smile = createBlock(0, 0, 0, 0xFF6B6B);
            smile.position.set(0, 1.7, 0.3);
            smile.scale.set(0.2, 0.08, 0.05);
            child.add(smile);
            
            // Body (shirt)
            const body = createBlock(0, 0, 0, shirtColor);
            body.position.set(0, 1.1, 0);
            body.scale.set(0.5, 0.6, 0.4);
            child.add(body);
            
            // Shorts/skirt
            const bottomColor = type === 'girl' ? shirtColor : 0x4a4a4a;
            const bottom = createBlock(0, 0, 0, bottomColor);
            bottom.position.set(0, 0.6, 0);
            bottom.scale.set(0.5, 0.4, 0.4);
            child.add(bottom);
            
            // Little legs
            const leg1 = createBlock(0, 0, 0, 0xFFDFC4);
            leg1.position.set(0.15, 0.2, 0);
            leg1.scale.set(0.15, 0.4, 0.15);
            child.add(leg1);
            const leg2 = createBlock(0, 0, 0, 0xFFDFC4);
            leg2.position.set(-0.15, 0.2, 0);
            leg2.scale.set(0.15, 0.4, 0.15);
            child.add(leg2);
            
            // Little arms
            const arm1 = createBlock(0, 0, 0, 0xFFDFC4);
            arm1.position.set(0.35, 1.1, 0);
            arm1.scale.set(0.15, 0.4, 0.15);
            child.add(arm1);
            const arm2 = createBlock(0, 0, 0, 0xFFDFC4);
            arm2.position.set(-0.35, 1.1, 0);
            arm2.scale.set(0.15, 0.4, 0.15);
            child.add(arm2);
            
            // Balloon for one child!
            if (type === 'girl') {
                const string = createBlock(0, 0, 0, 0xFFFFFF);
                string.position.set(0.4, 2.5, 0);
                string.scale.set(0.02, 1, 0.02);
                child.add(string);
                const balloon = createBlock(0, 0, 0, 0xFF0000);
                balloon.position.set(0.4, 3.2, 0);
                balloon.scale.set(0.4, 0.5, 0.4);
                child.add(balloon);
            }
            
            child.position.set(x, y, z);
            child.userData = { type: 'child', vx: (Math.random() - 0.5) * 0.08, vz: (Math.random() - 0.5) * 0.08, playTimer: Math.random() * Math.PI * 2, jumpCooldown: 0 };
            scene.add(child);
            mobs.push(child);
        }
        
        function createAnatoleTower(x, y, z) {
            const tower = new THREE.Group();
            
            // Tower base - sturdy cobblestone
            for (let bx = -2; bx <= 2; bx++) {
                for (let bz = -2; bz <= 2; bz++) {
                    const base = createBlock(bx, 0, bz, 0x808080);
                    tower.add(base);
                }
            }
            
            // Main tower body - alternating colors
            const towerColors = [0x4169E1, 0x6495ED, 0x87CEEB];
            for (let layer = 1; layer <= 12; layer++) {
                for (let tx = -1; tx <= 1; tx++) {
                    for (let tz = -1; tz <= 1; tz++) {
                        if (Math.abs(tx) + Math.abs(tz) <= 1) {
                            const towerBlock = createBlock(tx, layer, tz, towerColors[layer % 3]);
                            tower.add(towerBlock);
                        }
                    }
                }
            }
            
            // "HI" spelled out in gold blocks on the side
            // H
            const hBlocks = [[0, 13, 1.5], [0, 14, 1.5], [0, 15, 1.5], [0, 14, 1.5], [1, 13, 1.5], [1, 14, 1.5], [1, 15, 1.5]];
            hBlocks.forEach(pos => {
                const hb = createBlock(pos[0] - 0.5, pos[1], pos[2], 0xFFD700);
                hb.scale.set(0.4, 0.4, 0.2);
                tower.add(hb);
            });
            
            // I
            for (let iy = 13; iy <= 15; iy++) {
                const ib = createBlock(2, iy, 1.5, 0xFFD700);
                ib.scale.set(0.4, 0.4, 0.2);
                tower.add(ib);
            }
            
            // ANATOLE name sign
            const nameSign = createBlock(0, 10, 2, 0x8B4513);
            nameSign.scale.set(4, 1.5, 0.3);
            tower.add(nameSign);
            
            const namePlate = createBlock(0, 10, 2.2, 0xFFFFFF);
            namePlate.scale.set(3.5, 1, 0.1);
            tower.add(namePlate);
            
            // Crown on top with beacon light
            const crown = createBlock(0, 13, 0, 0xFFD700);
            crown.scale.set(2, 0.5, 2);
            tower.add(crown);
            
            // Beacon light
            const beacon = createBlock(0, 14, 0, 0x00FFFF);
            beacon.scale.set(0.5, 3, 0.5);
            beacon.material.transparent = true;
            beacon.material.opacity = 0.7;
            beacon.userData = { isBeacon: true, beaconPhase: 0 };
            tower.add(beacon);
            
            // Waving flags
            for (let f = 0; f < 4; f++) {
                const flagPole = createBlock(Math.cos(f * Math.PI/2) * 2, 12, Math.sin(f * Math.PI/2) * 2, 0x4a3000);
                flagPole.scale.set(0.15, 2, 0.15);
                tower.add(flagPole);
                
                const flag = createBlock(Math.cos(f * Math.PI/2) * 2.5, 13.5, Math.sin(f * Math.PI/2) * 2, 0xFF6B6B);
                flag.scale.set(0.8, 0.5, 0.1);
                flag.userData = { isAnatolFlag: true, flagIndex: f };
                tower.add(flag);
            }
            
            tower.position.set(x, y, z);
            tower.userData = { type: 'anatoletower', pulsePhase: 0 };
            scene.add(tower);
            mobs.push(tower);
        }
        
        function createBlocMonument(x, y, z) {
            const monument = new THREE.Group();
            const blocColors = [0xFF0000, 0xFF6600, 0xFFFF00, 0x00FF00, 0x00BFFF, 0x8A2BE2, 0xFF69B4];
            
            // Build a spiraling tower of blocks
            for (let layer = 0; layer < 8; layer++) {
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + layer * 0.3;
                    const radius = 2 - layer * 0.15;
                    const block = createBlock(0, 0, 0, blocColors[layer % blocColors.length]);
                    block.position.set(
                        Math.cos(angle) * radius,
                        layer * 1.2,
                        Math.sin(angle) * radius
                    );
                    block.userData = { isMonumentBlock: true, layer: layer, index: i };
                    monument.add(block);
                }
            }
            
            // Crown block at top
            const crown = createBlock(0, 0, 0, 0xFFD700);
            crown.position.set(0, 10, 0);
            crown.scale.set(1.5, 1.5, 1.5);
            crown.userData = { isCrown: true };
            monument.add(crown);
            
            monument.position.set(x, y, z);
            monument.userData = { type: 'blocmonument', rotationSpeed: 0.01 };
            scene.add(monument);
            mobs.push(monument);
        }
        
        function createVoxelGreeter(x, y, z) {
            const greeter = new THREE.Group();
            
            // Fish-shaped sign body (rainbow colors)
            const rainbowColors = [0xFF6B6B, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00BFFF, 0x8A2BE2];
            
            for (let i = 0; i < 6; i++) {
                const block = createBlock(0, 0, 0, rainbowColors[i]);
                block.position.set(i - 2.5, 0, 0);
                greeter.add(block);
            }
            
            // Top fin
            const topFin = createBlock(0, 0, 0, 0xFFD700);
            topFin.position.set(0, 1, 0);
            topFin.scale.set(0.5, 0.8, 0.3);
            greeter.add(topFin);
            
            // Eye
            const eye = createBlock(0, 0, 0, 0xFFFFFF);
            eye.position.set(2.5, 0.3, 0.5);
            eye.scale.set(0.4, 0.4, 0.4);
            greeter.add(eye);
            
            const pupil = createBlock(0, 0, 0, 0x000000);
            pupil.position.set(2.6, 0.3, 0.6);
            pupil.scale.set(0.2, 0.2, 0.2);
            greeter.add(pupil);
            
            // Sparkle blocks around it
            for (let i = 0; i < 4; i++) {
                const sparkle = createBlock(0, 0, 0, 0xFFFF00);
                sparkle.position.set(
                    Math.cos(i * Math.PI / 2) * 4,
                    Math.sin(i * Math.PI / 2) * 2,
                    0
                );
                sparkle.scale.set(0.3, 0.3, 0.3);
                sparkle.userData = { sparkleIndex: i };
                greeter.add(sparkle);
            }
            
            greeter.position.set(x, y, z);
            greeter.userData = { type: 'greeter', wobble: 0 };
            scene.add(greeter);
            mobs.push(greeter);
        }
        
        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngle.x) * Math.cos(cameraAngle.y) * cameraDistance;
            camera.position.y = Math.sin(cameraAngle.y) * cameraDistance + 10;
            camera.position.z = Math.cos(cameraAngle.x) * Math.cos(cameraAngle.y) * cameraDistance;
            camera.lookAt(0, 5, 0);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseMove(event) {
            if (!isDragging) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cameraAngle.x += deltaX * 0.01;
            cameraAngle.y = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraAngle.y + deltaY * 0.01));
            updateCameraPosition();
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            cameraDistance = Math.max(20, Math.min(100, cameraDistance + event.deltaY * 0.05));
            updateCameraPosition();
        }
        
        function createPlayerCharacter() {
            playerMesh = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.2, 0.4),
                new THREE.MeshLambertMaterial({ color: 0x00AAFF })
            );
            body.position.y = 0.6;
            playerMesh.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.6, 0.6),
                new THREE.MeshLambertMaterial({ color: 0xFFDFC4 })
            );
            head.position.y = 1.5;
            playerMesh.add(head);
            
            // Hair
            const hair = new THREE.Mesh(
                new THREE.BoxGeometry(0.65, 0.3, 0.65),
                new THREE.MeshLambertMaterial({ color: 0x4a3000 })
            );
            hair.position.y = 1.8;
            playerMesh.add(hair);
            
            // Legs
            const leg1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.8, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x3333AA })
            );
            leg1.position.set(0.2, -0.4, 0);
            playerMesh.add(leg1);
            
            const leg2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.8, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x3333AA })
            );
            leg2.position.set(-0.2, -0.4, 0);
            playerMesh.add(leg2);
            
            playerMesh.position.set(playerPos.x, playerPos.y, playerPos.z);
            playerMesh.visible = false;
            scene.add(playerMesh);
        }
        
        function togglePlayerMode() {
            playerMode = !playerMode;
            const btn = document.querySelector('#player-mode-toggle button');
            const hud = document.getElementById('player-hud');
            
            if (playerMode) {
                btn.innerHTML = 'ğŸ‘ï¸ SPECTATE';
                hud.style.display = 'block';
                playerMesh.visible = false; // First person, hide own body
                playerPos = { x: 0, y: 5, z: 15 };
                renderer.domElement.requestPointerLock();
            } else {
                btn.innerHTML = 'ğŸ‘¤ ENTER WORLD';
                hud.style.display = 'none';
                document.exitPointerLock();
                updateCameraPosition();
            }
        }
        
        function onPlayerLook(e) {
            if (!playerMode || !pointerLocked) return;
            playerYaw -= e.movementX * 0.002;
            playerPitch -= e.movementY * 0.002;
            playerPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, playerPitch));
        }
        
        function updatePlayer() {
            if (!playerMode) return;
            
            const speed = isSprinting ? 0.25 : 0.12;
            let moveX = 0, moveZ = 0;
            
            // WASD / Arrow movement
            if (keys['KeyW'] || keys['ArrowUp']) moveZ -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) moveZ += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) moveX -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) moveX += 1;
            
            // Apply rotation to movement
            const sin = Math.sin(playerYaw);
            const cos = Math.cos(playerYaw);
            playerVelocity.x = (moveX * cos - moveZ * sin) * speed;
            playerVelocity.z = (moveX * sin + moveZ * cos) * speed;
            
            // Jump
            if ((keys['Space'] || keys['KeySpace']) && !isJumping && playerPos.y <= 5) {
                playerVelocity.y = 0.3;
                isJumping = true;
            }
            
            // Gravity
            playerVelocity.y -= 0.015;
            
            // Apply velocity
            playerPos.x += playerVelocity.x;
            playerPos.y += playerVelocity.y;
            playerPos.z += playerVelocity.z;
            
            // Ground collision (simplified)
            const groundY = 4;
            if (playerPos.y < groundY) {
                playerPos.y = groundY;
                playerVelocity.y = 0;
                isJumping = false;
            }
            
            // World bounds
            playerPos.x = Math.max(-28, Math.min(28, playerPos.x));
            playerPos.z = Math.max(-28, Math.min(28, playerPos.z));
            
            // Update camera to player position (first person)
            camera.position.set(playerPos.x, playerPos.y + 1.6, playerPos.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = playerYaw;
            camera.rotation.x = playerPitch;
            
            // Update player mesh position (for third person later)
            playerMesh.position.set(playerPos.x, playerPos.y, playerPos.z);
            playerMesh.rotation.y = playerYaw;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            // Update player controls
            updatePlayer();
            
            // Animate mobs
            for (let mob of mobs) {
                if (mob.userData.type === 'fish') {
                    mob.position.x += mob.userData.vx;
                    mob.position.y = mob.userData.baseY + Math.sin(time * 2 + mob.position.x) * 2;
                    mob.rotation.y = mob.userData.vx > 0 ? 0 : Math.PI;
                    if (mob.position.x > 25) mob.position.x = -25;
                    if (mob.position.x < -25) mob.position.x = 25;
                }
                else if (mob.userData.type === 'shark') {
                    mob.userData.angle += 0.01;
                    mob.position.x = Math.cos(mob.userData.angle) * 8;
                    mob.position.z = Math.sin(mob.userData.angle) * 8;
                    mob.rotation.y = -mob.userData.angle + Math.PI / 2;
                }
                else if (mob.userData.type === 'werewolf') {
                    mob.position.x += mob.userData.vx;
                    mob.rotation.y = mob.userData.vx > 0 ? -Math.PI / 2 : Math.PI / 2;
                    if (mob.position.x > 18 || mob.position.x < -18) mob.userData.vx *= -1;
                    // Occasional jump
                    if (Math.random() < 0.005) {
                        mob.position.y += 2;
                    }
                    if (mob.position.y > 2) mob.position.y -= 0.1;
                }
                else if (mob.userData.type === 'mario') {
                    // Mario is dead - ghost effect
                    if (mob.userData.isDead) {
                        mob.userData.deathTime += 0.016;
                        mob.rotation.x = Math.PI / 2;
                        // Ghost slowly rises and fades
                        mob.position.y = mob.userData.baseY + Math.sin(mob.userData.deathTime) * 0.5;
                        mob.children.forEach(child => {
                            if (child.material) {
                                child.material.transparent = true;
                                child.material.opacity = 0.3 + Math.sin(mob.userData.deathTime * 3) * 0.2;
                            }
                        });
                    }
                }
                else if (mob.userData.type === 'bowser') {
                    // Bowser circles menacingly around Mario's body
                    mob.userData.angle += 0.02;
                    mob.position.x = Math.cos(mob.userData.angle) * 6;
                    mob.position.z = Math.sin(mob.userData.angle) * 6 + 5;
                    mob.rotation.y = -mob.userData.angle + Math.PI;
                    // Breathing fire animation
                    mob.position.y = 3 + Math.sin(time * 4) * 0.3;
                }
                else if (mob.userData.type === 'sandwich') {
                    // Legendary sandwich floats and spins majestically
                    mob.userData.floatOffset += 0.02;
                    mob.position.y = 6 + Math.sin(mob.userData.floatOffset) * 1.5;
                    mob.rotation.y += mob.userData.spinSpeed;
                    // Gentle tilt
                    mob.rotation.z = Math.sin(time * 1.5) * 0.1;
                }
                else if (mob.userData.type === 'frenchfish') {
                    mob.position.x += mob.userData.vx;
                    mob.position.y = mob.userData.baseY + Math.sin(time * 1.5) * 1;
                    mob.rotation.y = mob.userData.vx > 0 ? 0 : Math.PI;
                    if (mob.position.x > 20 || mob.position.x < -20) mob.userData.vx *= -1;
                    // Occasional tip of the beret
                    mob.userData.bonjourTimer += 0.016;
                    if (Math.sin(mob.userData.bonjourTimer * 2) > 0.95) {
                        mob.rotation.z = Math.sin(time * 10) * 0.2;
                    } else {
                        mob.rotation.z = 0;
                    }
                }
                else if (mob.userData.type === 'lolfish') {
                    mob.position.x += mob.userData.vx;
                    mob.position.y = mob.userData.baseY + Math.sin(time * 3) * 0.8;
                    mob.rotation.y = mob.userData.vx > 0 ? 0 : Math.PI;
                    if (mob.position.x > 22 || mob.position.x < -22) mob.userData.vx *= -1;
                    // Constant giggling shake - EXTRA LOL ENERGY!
                    mob.userData.laughTimer += 0.12;
                    mob.rotation.z = Math.sin(mob.userData.laughTimer * 18) * 0.2;
                    mob.position.y += Math.sin(mob.userData.laughTimer * 10) * 0.15;
                    // Occasional LOL burst
                    if (Math.random() < 0.002) {
                        for (let i = 0; i < 3; i++) {
                            const lolParticle = createBlock(mob.position.x + (Math.random()-0.5)*2, mob.position.y + 1, mob.position.z + (Math.random()-0.5)*2, 0xFFFF00);
                            lolParticle.scale.set(0.2, 0.2, 0.2);
                            setTimeout(() => scene.remove(lolParticle), 800);
                        }
                    }
                }
                else if (mob.userData.type === 'banana') {
                    // Bananas float and wobble tropically
                    mob.userData.floatOffset += 0.03;
                    mob.userData.wobble += 0.05;
                    mob.position.y = mob.userData.baseY || mob.position.y + Math.sin(mob.userData.floatOffset) * 0.02;
                    mob.rotation.z = Math.sin(mob.userData.wobble) * 0.3;
                    mob.rotation.y += 0.01;
                }
                else if (mob.userData.type === 'grandma') {
                    // Grandma rocks gently in her chair and waves
                    mob.userData.rockTimer += 0.02;
                    mob.rotation.z = Math.sin(mob.userData.rockTimer) * 0.1;
                    mob.position.y = 2 + Math.sin(mob.userData.rockTimer * 0.5) * 0.1;
                    // Occasional wave
                    if (Math.sin(time * 0.5) > 0.9) {
                        mob.rotation.y = Math.sin(time * 8) * 0.2;
                    }
                }
                else if (mob.userData.type === 'anatoletower') {
                    // Anatole's tower beacon pulses and flags wave
                    mob.userData.pulsePhase += 0.05;
                    mob.children.forEach(child => {
                        if (child.userData && child.userData.isBeacon) {
                            child.userData.beaconPhase += 0.1;
                            child.scale.y = 3 + Math.sin(child.userData.beaconPhase) * 1;
                            child.material.opacity = 0.5 + Math.sin(child.userData.beaconPhase * 2) * 0.3;
                        }
                        if (child.userData && child.userData.isAnatolFlag) {
                            child.rotation.y = Math.sin(time * 3 + child.userData.flagIndex) * 0.3;
                        }
                    });
                }
                else if (mob.userData.type === 'blocmonument') {
                    // The monument slowly rotates and pulses
                    mob.rotation.y += mob.userData.rotationSpeed;
                    mob.children.forEach((child, idx) => {
                        if (child.userData && child.userData.isMonumentBlock) {
                            child.position.y = child.userData.layer * 1.2 + Math.sin(time * 2 + child.userData.layer * 0.5) * 0.2;
                        }
                        if (child.userData && child.userData.isCrown) {
                            child.rotation.y += 0.03;
                            child.position.y = 10 + Math.sin(time * 3) * 0.5;
                        }
                    });
                }
                else if (mob.userData.type === 'child') {
                    // Children run around and play!
                    mob.userData.playTimer += 0.05;
                    mob.userData.jumpCooldown -= 0.016;
                    
                    // Running movement
                    mob.position.x += mob.userData.vx;
                    mob.position.z += mob.userData.vz;
                    
                    // Bounce in direction of movement
                    mob.rotation.y = Math.atan2(mob.userData.vx, mob.userData.vz);
                    
                    // Running bounce animation
                    mob.position.y = 2 + Math.abs(Math.sin(mob.userData.playTimer * 3)) * 0.3;
                    
                    // Keep them on the island
                    const distFromCenter = Math.sqrt(mob.position.x * mob.position.x + mob.position.z * mob.position.z);
                    if (distFromCenter > 8) {
                        mob.userData.vx *= -0.8;
                        mob.userData.vz *= -0.8;
                        mob.position.x *= 0.95;
                        mob.position.z *= 0.95;
                    }
                    
                    // Random direction changes (playing!)
                    if (Math.random() < 0.01) {
                        mob.userData.vx = (Math.random() - 0.5) * 0.1;
                        mob.userData.vz = (Math.random() - 0.5) * 0.1;
                    }
                    
                    // Occasional big jump!
                    if (Math.random() < 0.005 && mob.userData.jumpCooldown <= 0) {
                        mob.position.y += 1.5;
                        mob.userData.jumpCooldown = 2;
                    }
                    
                    // Arm swing while running
                    mob.children.forEach((child, idx) => {
                        if (idx >= 10 && idx <= 11) { // Arms
                            child.rotation.x = Math.sin(mob.userData.playTimer * 6) * 0.5;
                        }
                    });
                }
                else if (mob.userData.type === 'userplot') {
                    // User plots gently float and their flags wave
                    mob.userData.floatPhase += 0.02;
                    mob.position.y = 8 + Math.sin(mob.userData.floatPhase) * 0.5;
                    mob.rotation.y = Math.sin(mob.userData.floatPhase * 0.3) * 0.05;
                    // Animate flags
                    mob.children.forEach(child => {
                        if (child.userData && child.userData.isUserFlag) {
                            child.userData.wavePhase += 0.1;
                            child.rotation.y = Math.sin(child.userData.wavePhase) * 0.2;
                        }
                    });
                }
                else if (mob.userData.type === 'greeter') {
                    mob.userData.wobble += 0.05;
                    mob.position.y += Math.sin(mob.userData.wobble) * 0.02;
                    mob.rotation.y += 0.01;
                    // Animate sparkles
                    mob.children.forEach((child, i) => {
                        if (child.userData && child.userData.sparkleIndex !== undefined) {
                            const idx = child.userData.sparkleIndex;
                            child.position.x = Math.cos(time * 2 + idx * Math.PI / 2) * 4;
                            child.position.y = Math.sin(time * 2 + idx * Math.PI / 2) * 2;
                        }
                    });
                }
            }
            
            // Day/night cycle (subtle)
            const dayProgress = (Math.sin(time * 0.1) + 1) / 2;
            const skyColor = new THREE.Color().lerpColors(
                new THREE.Color(0x1a1a2e),
                new THREE.Color(0x87CEEB),
                dayProgress
            );
            scene.background = skyColor;
            scene.fog.color = skyColor;
            
            // Animate ocean waves
            if (window.seaBlocks) {
                for (let waterBlock of window.seaBlocks) {
                    if (waterBlock.userData && waterBlock.userData.isWater) {
                        const waveHeight = Math.sin(time * 1.5 + waterBlock.userData.waveOffset) * 0.15;
                        waterBlock.position.y = waterBlock.userData.baseY + waveHeight;
                    }
                }
            }
            
            // Animate seaweed swaying
            for (let block of blocks) {
                if (block.userData && block.userData.isSeaweed) {
                    block.rotation.z = Math.sin(time * 2 + block.userData.swayOffset) * 0.2;
                }
                // Animate the tombstone - gentle rest
                if (block.userData && block.userData.isTombstone) {
                    block.userData.restPhase += 0.01;
                    block.position.y = 15 + Math.sin(block.userData.restPhase) * 0.1;
                }
                // Animate memorial flowers - gentle sway
                if (block.userData && block.userData.isFlower) {
                    block.rotation.z = Math.sin(time * 1.5) * 0.1;
                }
                // Animate peace dove - gentle floating
                if (block.userData && block.userData.isDove) {
                    block.userData.flyPhase += 0.02;
                    block.position.y = 17 + Math.sin(block.userData.flyPhase) * 0.5;
                    block.position.x = Math.sin(block.userData.flyPhase * 0.5) * 2;
                    block.rotation.y = Math.sin(block.userData.flyPhase) * 0.2;
                }
                // Animate the Bloc Rouge - pulsing red glow
                if (block.userData && block.userData.isBlocRouge) {
                    block.userData.floatPhase += 0.03;
                    block.position.y = 8 + Math.sin(block.userData.floatPhase) * 0.8;
                    block.rotation.x += 0.015;
                    block.rotation.y += 0.02;
                }
            }
            
            // Update UI
            document.getElementById('object-count').innerHTML = 
                `<span class="minecraft-text">Blocks: ${blockCount} | Mobs: ${mobs.length}</span>`;
            
            renderer.render(scene, camera);
        }
        
        function spawnGoldBlock() {
            const x = Math.floor(Math.random() * 20) - 10;
            const z = Math.floor(Math.random() * 20) - 10;
            const y = 5 + Math.floor(Math.random() * 10);
            const newBlock = createBlock(x, y, z, 0xFFD700);
            newBlock.userData = { falling: true, targetY: 3, isGold: true };
            
            // Add sparkle effect
            const sparkleGeom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const sparkleMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            for (let i = 0; i < 4; i++) {
                const sparkle = new THREE.Mesh(sparkleGeom, sparkleMat);
                sparkle.position.set(
                    x + (Math.random() - 0.5) * 2,
                    y + (Math.random() - 0.5) * 2,
                    z + (Math.random() - 0.5) * 2
                );
                scene.add(sparkle);
                setTimeout(() => scene.remove(sparkle), 500);
            }
            
            function dropBlock() {
                if (newBlock.position.y > newBlock.userData.targetY) {
                    newBlock.position.y -= 0.3;
                    requestAnimationFrame(dropBlock);
                } else {
                    newBlock.position.y = newBlock.userData.targetY;
                }
            }
            dropBlock();
        }
        
        function claimPlot() {
            const userName = userNames[Math.floor(Math.random() * userNames.length)] + Math.floor(Math.random() * 1000);
            if (Object.keys(userPlots).length >= 8) {
                console.log('Max plots reached!');
                return;
            }
            
            const plotColor = plotColors[nextPlotIndex % plotColors.length];
            nextPlotIndex++;
            
            // Calculate plot position in a circle around the island
            const plotAngle = (Object.keys(userPlots).length / 8) * Math.PI * 2;
            const plotDistance = 22;
            const plotX = Math.cos(plotAngle) * plotDistance;
            const plotZ = Math.sin(plotAngle) * plotDistance;
            
            // Create the user's personal floating island
            const userIsland = new THREE.Group();
            
            // Platform base
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    if (Math.abs(dx) + Math.abs(dz) <= 3) {
                        const platformBlock = createBlock(dx, 0, dz, plotColor);
                        userIsland.add(platformBlock);
                        // Dirt underneath
                        const dirtBlock = createBlock(dx, -1, dz, 0x8B4513);
                        userIsland.add(dirtBlock);
                    }
                }
            }
            
            // User's flag pole
            for (let fy = 1; fy <= 4; fy++) {
                const pole = createBlock(0, fy, 0, 0x4a3000);
                pole.scale.set(0.2, 1, 0.2);
                userIsland.add(pole);
            }
            
            // Flag with user color
            const flag = createBlock(0.5, 4, 0, plotColor);
            flag.scale.set(1.5, 1, 0.1);
            flag.userData = { isUserFlag: true, wavePhase: Math.random() * Math.PI * 2 };
            userIsland.add(flag);
            
            // Name sign
            const sign = createBlock(0, 1.5, 2, 0x8B4513);
            sign.scale.set(2, 1, 0.2);
            userIsland.add(sign);
            
            userIsland.position.set(plotX, 8, plotZ);
            userIsland.userData = { type: 'userplot', owner: userName, floatPhase: Math.random() * Math.PI * 2 };
            scene.add(userIsland);
            mobs.push(userIsland);
            
            userPlots[userName] = { island: userIsland, color: plotColor, x: plotX, z: plotZ };
            
            // Update UI
            updateUserList();
        }
        
        function updateUserList() {
            const listDiv = document.getElementById('user-list');
            if (listDiv) {
                listDiv.innerHTML = Object.keys(userPlots).map(name => {
                    const color = '#' + userPlots[name].color.toString(16).padStart(6, '0');
                    return `<div style="color: ${color}; margin: 2px 0;">ğŸï¸ ${name}</div>`;
                }).join('');
            }
        }
        
        function spawnRandomBlock() {
            const colors = [0xFF6B6B, 0xFFA500, 0xFFFF00, 0x00FF00, 0x00BFFF, 0x8A2BE2, 0xFF69B4, 0x4CAF50, 0x8B4513];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const x = Math.floor(Math.random() * 20) - 10;
            const z = Math.floor(Math.random() * 20) - 10;
            const y = 5 + Math.floor(Math.random() * 10);
            const newBlock = createBlock(x, y, z, randomColor);
            newBlock.userData = { falling: true, targetY: 3 };
            
            // Animate the block falling
            function dropBlock() {
                if (newBlock.position.y > newBlock.userData.targetY) {
                    newBlock.position.y -= 0.3;
                    requestAnimationFrame(dropBlock);
                } else {
                    newBlock.position.y = newBlock.userData.targetY;
                }
            }
            dropBlock();
        }
    </script>
</body>
</html>