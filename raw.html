<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch Minecraft World</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            overflow: hidden;
            background: #87CEEB;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #55FF55;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
            border: 2px solid #333;
            image-rendering: pixelated;
        }
        #info h1 {
            font-size: 18px;
            margin-bottom: 5px;
            color: #FFFF55;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        canvas { display: block; }
    </style>
</head>
<body>
<div id="info">
<h1>‚õèÔ∏è TWITCH MINECRAFT</h1>
<div>Seed: HelloWorld üçå</div>
<div>Chunks: Loading...</div>
</div>
<div id="controls">üéÆ WASD: Move | SPACE: Jump | F: First Person | üñ±Ô∏è Mouse: Look Around</div>
<div id="player-stats" style="position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.7);color:#55FF55;padding:10px;border-radius:5px;z-index:100;border:2px solid #333;font-family:monospace;">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è<br/>üèÉ Playing!</div>
<script>
        // MINECRAFT 3D VOXEL WORLD
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 150);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(30, 40, 30);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Pixelated look
        document.body.appendChild(renderer.domElement);
        
        // Minecraft block colors
        const BLOCKS = {
            grass: 0x4CAF50,
            dirt: 0x8B4513,
            stone: 0x808080,
            water: 0x4169E1,
            sand: 0xF4D03F,
            wood: 0x6B4423,
            leaves: 0x228B22
        };
        
        // Simple noise function for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 3 + 
                   Math.sin(x * 0.05 + 1) * Math.cos(z * 0.07) * 5;
        }
        
        // Create voxel
        function createBlock(x, y, z, color) {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const cube = new THREE.Mesh(geo, mat);
            cube.position.set(x, y, z);
            scene.add(cube);
            return cube;
        }
        
        // Generate terrain
        const worldSize = 24;
        let blockCount = 0;
        for(let x = -worldSize/2; x < worldSize/2; x++) {
            for(let z = -worldSize/2; z < worldSize/2; z++) {
                const height = Math.floor(noise(x, z) + 5);
                for(let y = 0; y <= height; y++) {
                    let color = BLOCKS.stone;
                    if(y === height) color = BLOCKS.grass;
                    else if(y > height - 3) color = BLOCKS.dirt;
                    createBlock(x, y, z, color);
                    blockCount++;
                }
                // Water in low areas
                if(height < 3) {
                    for(let y = height + 1; y <= 3; y++) {
                        createBlock(x, y, z, BLOCKS.water);
                    }
                }
            }
        }
        
        // Add a giant banana monument!
        function createBanana(bx, by, bz) {
            const bananaYellow = 0xFFE135;
            const bananaTip = 0x8B4513;
            // Curved banana body (voxel style)
            const bananaBlocks = [
                [0,0,0], [0,1,0], [0,2,0], [0,3,0], [0,4,0],
                [1,5,0], [1,6,0], [2,7,0], [2,8,0], [3,9,0],
                [0,0,1], [0,1,1], [0,2,1], [0,3,1],
                [1,5,1], [1,6,1], [2,7,1],
                [-1,1,0], [-1,2,0], [-1,3,0]
            ];
            bananaBlocks.forEach(([dx, dy, dz]) => {
                createBlock(bx + dx, by + dy, bz + dz, bananaYellow);
            });
            // Brown tips
            createBlock(bx, by - 1, bz, bananaTip);
            createBlock(bx + 3, by + 10, bz, bananaTip);
        }
        createBanana(8, 8, -5);
        
        // Add some trees
        for(let i = 0; i < 8; i++) {
            const tx = Math.floor(Math.random() * worldSize) - worldSize/2;
            const tz = Math.floor(Math.random() * worldSize) - worldSize/2;
            const th = Math.floor(noise(tx, tz) + 6);
            if(th > 4) {
                for(let y = 0; y < 5; y++) createBlock(tx, th + y, tz, BLOCKS.wood);
                for(let lx = -2; lx <= 2; lx++) {
                    for(let lz = -2; lz <= 2; lz++) {
                        for(let ly = 0; ly < 3; ly++) {
                            if(Math.random() > 0.3) createBlock(tx+lx, th+4+ly, tz+lz, BLOCKS.leaves);
                        }
                    }
                }
            }
        }
        
        // Lighting
        const sun = new THREE.DirectionalLight(0xFFFFFF, 1);
        sun.position.set(50, 100, 50);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));
        
        // Update info
        document.querySelector('#info div:last-child').textContent = 'Blocks: ' + blockCount;
        
        // PLAYABLE CONTROLS!
        let isDragging = false;
        let prevX = 0, prevY = 0;
        let angleX = 0, angleY = 0.5;
        
        // Player state
        const player = {
            x: 0, y: 15, z: 0,
            vx: 0, vy: 0, vz: 0,
            speed: 0.3,
            jumpPower: 0.4,
            onGround: false
        };
        
        // Create player cube (Steve!)
        const playerGeo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
        const playerMat = new THREE.MeshLambertMaterial({ color: 0x00AA00 });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.position.set(player.x, player.y, player.z);
        scene.add(playerMesh);
        
        // Add player head
        const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
        const headMesh = new THREE.Mesh(headGeo, headMat);
        headMesh.position.y = 1.2;
        playerMesh.add(headMesh);
        
        let firstPerson = false;
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if(e.key.toLowerCase() === 'f') firstPerson = !firstPerson;
            if(e.key === ' ' && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        renderer.domElement.addEventListener('mousedown', (e) => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('mousemove', (e) => {
            if(isDragging) {
                angleX += (e.clientX - prevX) * 0.01;
                angleY += (e.clientY - prevY) * 0.005;
                angleY = Math.max(0.1, Math.min(1.5, angleY));
                prevX = e.clientX; prevY = e.clientY;
            }
        });
        
        function updatePlayer() {
            // Movement
            const moveAngle = angleX;
            if(keys['w']) { player.x -= Math.sin(moveAngle) * player.speed; player.z -= Math.cos(moveAngle) * player.speed; }
            if(keys['s']) { player.x += Math.sin(moveAngle) * player.speed; player.z += Math.cos(moveAngle) * player.speed; }
            if(keys['a']) { player.x -= Math.cos(moveAngle) * player.speed; player.z += Math.sin(moveAngle) * player.speed; }
            if(keys['d']) { player.x += Math.cos(moveAngle) * player.speed; player.z -= Math.sin(moveAngle) * player.speed; }
            
            // Gravity
            player.vy -= 0.02;
            player.y += player.vy;
            
            // Ground collision (simple)
            const groundHeight = Math.floor(noise(player.x, player.z) + 7);
            if(player.y < groundHeight) {
                player.y = groundHeight;
                player.vy = 0;
                player.onGround = true;
            }
            
            playerMesh.position.set(player.x, player.y, player.z);
            playerMesh.rotation.y = -angleX;
        }
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            
            if(firstPerson) {
                // First person view
                camera.position.x = player.x;
                camera.position.y = player.y + 1.5;
                camera.position.z = player.z;
                camera.lookAt(
                    player.x - Math.sin(angleX) * 10,
                    player.y + 1.5 - angleY * 5,
                    player.z - Math.cos(angleX) * 10
                );
                playerMesh.visible = false;
            } else {
                // Third person view
                const radius = 15;
                camera.position.x = player.x + Math.sin(angleX) * radius;
                camera.position.z = player.z + Math.cos(angleX) * radius;
                camera.position.y = player.y + 5 + angleY * 10;
                camera.lookAt(player.x, player.y + 1, player.z);
                playerMesh.visible = true;
            }
            
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>