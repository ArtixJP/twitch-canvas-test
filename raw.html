<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Othello Game</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-family: 'Segoe UI', system-ui, sans-serif;
        padding: 20px;
    }
    h1 {
        font-size: 2.5rem;
        color: white;
        margin-bottom: 10px;
        text-shadow: 0 0 10px #2ecc71, 0 0 20px #2ecc71;
    }
    .score-board {
        display: flex;
        gap: 40px;
        margin-bottom: 20px;
        color: white;
        font-size: 1.2rem;
    }
    .score {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 20px;
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        transition: transform 0.3s;
    }
    .score.active {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
    }
    .disc-preview {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        box-shadow: inset -3px -3px 8px rgba(0,0,0,0.3);
    }
    .disc-preview.black { background: radial-gradient(circle at 30% 30%, #444, #111); }
    .disc-preview.white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }
    .board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 2px;
        background: #111;
        padding: 10px;
        border-radius: 10px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .cell {
        width: 50px;
        height: 50px;
        background: #2d5016;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background 0.2s;
        position: relative;
    }
    .cell:hover {
        background: #3d6a1e;
    }
    .cell.valid-move::after {
        content: '';
        width: 15px;
        height: 15px;
        background: rgba(46, 204, 113, 0.4);
        border-radius: 50%;
        animation: pulse 1s infinite;
    }
    @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 0.4; }
        50% { transform: scale(1.2); opacity: 0.7; }
    }
    .disc {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        transition: transform 0.5s;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3), inset -3px -3px 8px rgba(0,0,0,0.2);
    }
    .disc.black {
        background: radial-gradient(circle at 30% 30%, #444, #111);
    }
    .disc.white {
        background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }
    .disc.flip {
        animation: flip 0.5s ease-in-out;
    }
    @keyframes flip {
        0% { transform: rotateY(0deg); }
        50% { transform: rotateY(90deg); }
        100% { transform: rotateY(180deg); }
    }
    .disc.new {
        animation: pop 0.3s ease-out;
    }
    @keyframes pop {
        0% { transform: scale(0); }
        70% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    .message {
        margin-top: 20px;
        color: #2ecc71;
        font-size: 1.3rem;
        min-height: 30px;
    }
    .restart-btn {
        margin-top: 15px;
        padding: 12px 30px;
        font-size: 1rem;
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .restart-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
    }
    .firework {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
    }
    .particle {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        animation: explode 1s ease-out forwards;
    }
    @keyframes explode {
        0% {
            transform: translate(0, 0) scale(1);
            opacity: 1;
        }
        100% {
            transform: translate(var(--tx), var(--ty)) scale(0);
            opacity: 0;
        }
    }
    .test-badge {
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        font-weight: bold;
        animation: testPop 0.5s ease-out, testFloat 2s ease-in-out infinite, testGlow 1.5s ease-in-out infinite;
        box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
        z-index: 1000;
    }
    @keyframes testPop {
        0% { transform: scale(0) rotate(-10deg); opacity: 0; }
        70% { transform: scale(1.2) rotate(5deg); }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    @keyframes testGlow {
        0%, 100% { box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4); }
        50% { box-shadow: 0 5px 30px rgba(46, 204, 113, 0.8), 0 0 40px rgba(241, 196, 15, 0.5); }
    }
    @keyframes testFloat {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }
    .sparkle {
        position: fixed;
        width: 4px;
        height: 4px;
        background: gold;
        border-radius: 50%;
        pointer-events: none;
        z-index: 1000;
        animation: sparkle 0.8s ease-out forwards;
    }
    @keyframes sparkle {
        0% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: scale(0) rotate(180deg);
            opacity: 0;
        }
    }
</style>
</head>
<body>
<h1>üéÆ Othello</h1>
<div class="test-badge">üß™ Test #3 Active! üß™</div>
<div class="score-board">
<div class="score" id="black-score">
<div class="disc-preview black"></div>
<span>Black: <strong id="black-count">2</strong></span>
</div>
<div class="score" id="white-score">
<div class="disc-preview white"></div>
<span>White: <strong id="white-count">2</strong></span>
</div>
</div>
<div class="board" id="board"></div>
<div class="message" id="message">Black's turn</div>
<div style="display: flex; gap: 15px; margin-top: 15px;">
<button class="restart-btn" onclick="initGame()">üîÑ New Game</button>
<button class="restart-btn" onclick="passTurn()" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">‚è≠Ô∏è Pass Turn</button>
<button class="restart-btn" onclick="showHint()" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">üí° Hint</button>
</div>
<script>
const DIRECTIONS = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],          [0, 1],
    [1, -1], [1, 0], [1, 1]
];

let board = [];
let currentPlayer = 'black';
let gameOver = false;

function initGame() {
    board = Array(8).fill(null).map(() => Array(8).fill(null));
    board[3][3] = 'white';
    board[3][4] = 'black';
    board[4][3] = 'black';
    board[4][4] = 'white';
    currentPlayer = 'black';
    gameOver = false;
    renderBoard();
    updateScore();
    updateMessage();
}

function renderBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    const validMoves = getValidMoves(currentPlayer);
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (validMoves.some(m => m.row === row && m.col === col)) {
                cell.classList.add('valid-move');
            }
            
            if (board[row][col]) {
                const disc = document.createElement('div');
                disc.className = `disc ${board[row][col]}`;
                cell.appendChild(disc);
            }
            
            cell.addEventListener('click', () => handleClick(row, col));
            boardEl.appendChild(cell);
        }
    }
}

function getValidMoves(player) {
    const moves = [];
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (isValidMove(row, col, player)) {
                moves.push({ row, col });
            }
        }
    }
    return moves;
}

function isValidMove(row, col, player) {
    if (board[row][col] !== null) return false;
    
    const opponent = player === 'black' ? 'white' : 'black';
    
    for (const [dr, dc] of DIRECTIONS) {
        let r = row + dr;
        let c = col + dc;
        let foundOpponent = false;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (board[r][c] === opponent) {
                foundOpponent = true;
            } else if (board[r][c] === player && foundOpponent) {
                return true;
            } else {
                break;
            }
            r += dr;
            c += dc;
        }
    }
    return false;
}

function getFlips(row, col, player) {
    const flips = [];
    const opponent = player === 'black' ? 'white' : 'black';
    
    for (const [dr, dc] of DIRECTIONS) {
        const dirFlips = [];
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (board[r][c] === opponent) {
                dirFlips.push({ row: r, col: c });
            } else if (board[r][c] === player) {
                flips.push(...dirFlips);
                break;
            } else {
                break;
            }
            r += dr;
            c += dc;
        }
    }
    return flips;
}

function createFireworks(x, y, color) {
    const colors = color === 'black' 
        ? ['#333', '#555', '#777', '#999', '#2ecc71'] 
        : ['#fff', '#eee', '#ddd', '#ccc', '#f1c40f'];
    
    // Create main firework container
    const firework = document.createElement('div');
    firework.className = 'firework';
    firework.style.left = x + 'px';
    firework.style.top = y + 'px';
    document.body.appendChild(firework);
    
    // Create particles
    for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        const angle = (i / 20) * Math.PI * 2;
        const velocity = 50 + Math.random() * 80;
        const tx = Math.cos(angle) * velocity;
        const ty = Math.sin(angle) * velocity;
        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        particle.style.boxShadow = `0 0 6px ${colors[Math.floor(Math.random() * colors.length)]}`;
        firework.appendChild(particle);
    }
    
    // Create sparkles
    for (let i = 0; i < 15; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        sparkle.style.left = (x + (Math.random() - 0.5) * 100) + 'px';
        sparkle.style.top = (y + (Math.random() - 0.5) * 100) + 'px';
        sparkle.style.background = colors[Math.floor(Math.random() * colors.length)];
        sparkle.style.animationDelay = (Math.random() * 0.3) + 's';
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 1000);
    }
    
    // Remove firework after animation
    setTimeout(() => firework.remove(), 1200);
}

function handleClick(row, col) {
    if (gameOver || !isValidMove(row, col, currentPlayer)) return;
    
    // Get cell position for fireworks
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    const rect = cell.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;
    createFireworks(x, y, currentPlayer);
    
    const flips = getFlips(row, col, currentPlayer);
    board[row][col] = currentPlayer;
    
    flips.forEach(f => {
        board[f.row][f.col] = currentPlayer;
    });
    
    currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
    
    if (getValidMoves(currentPlayer).length === 0) {
        currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
        if (getValidMoves(currentPlayer).length === 0) {
            gameOver = true;
        }
    }
    
    renderBoard();
    updateScore();
    updateMessage();
}

function updateScore() {
    let black = 0, white = 0;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === 'black') black++;
            if (board[row][col] === 'white') white++;
        }
    }
    document.getElementById('black-count').textContent = black;
    document.getElementById('white-count').textContent = white;
    
    document.getElementById('black-score').classList.toggle('active', currentPlayer === 'black' && !gameOver);
    document.getElementById('white-score').classList.toggle('active', currentPlayer === 'white' && !gameOver);
}

function updateMessage() {
    const msg = document.getElementById('message');
    if (gameOver) {
        const black = parseInt(document.getElementById('black-count').textContent);
        const white = parseInt(document.getElementById('white-count').textContent);
        if (black > white) msg.textContent = 'üèÜ Black wins!';
        else if (white > black) msg.textContent = 'üèÜ White wins!';
        else msg.textContent = "ü§ù It's a tie!";
    } else {
        msg.textContent = `${currentPlayer === 'black' ? '‚ö´' : '‚ö™'} ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
    }
}

function passTurn() {
    if (gameOver) return;
    const opponent = currentPlayer === 'black' ? 'white' : 'black';
    if (getValidMoves(opponent).length > 0) {
        currentPlayer = opponent;
        renderBoard();
        updateScore();
        updateMessage();
    }
}

function showHint() {
    if (gameOver) return;
    const validMoves = getValidMoves(currentPlayer);
    if (validMoves.length === 0) return;
    
    // Find the move that flips the most pieces
    let bestMove = validMoves[0];
    let maxFlips = 0;
    
    for (const move of validMoves) {
        const flips = getFlips(move.row, move.col, currentPlayer);
        if (flips.length > maxFlips) {
            maxFlips = flips.length;
            bestMove = move;
        }
    }
    
    // Highlight the best move
    const cell = document.querySelector(`[data-row="${bestMove.row}"][data-col="${bestMove.col}"]`);
    cell.style.background = '#f1c40f';
    cell.style.boxShadow = '0 0 20px #f1c40f, inset 0 0 10px rgba(255,255,255,0.5)';
    
    setTimeout(() => {
        cell.style.background = '';
        cell.style.boxShadow = '';
    }, 1500);
}

initGame();
</script>
</body>
</html>