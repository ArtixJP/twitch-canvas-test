<!DOCTYPE html>

<html lang="fr">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>üåÄ Emergent Canvas</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #e94560;
        }
        
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #e94560, #00ff88, #0f3460, #ff00ff, #e94560);
            background-size: 400% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 2s linear infinite;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
            filter: drop-shadow(0 0 10px #e94560);
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            font-size: 0.9rem;
            color: #888;
        }
        
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Zone de chaos - libre modification */
        #chaos-zone {
            background: rgba(233, 69, 96, 0.1);
            border: 2px dashed #e94560;
            border-radius: 12px;
            padding: 2rem;
            min-height: 300px;
            margin: 2rem 0;
            position: relative;
            box-shadow: 0 0 40px rgba(233, 69, 96, 0.3), inset 0 0 60px rgba(0, 255, 136, 0.05);
            animation: zone-pulse 4s ease-in-out infinite;
        }
        
        @keyframes zone-pulse {
            0%, 100% { box-shadow: 0 0 40px rgba(233, 69, 96, 0.3), inset 0 0 60px rgba(0, 255, 136, 0.05); }
            50% { box-shadow: 0 0 80px rgba(233, 69, 96, 0.5), inset 0 0 100px rgba(0, 255, 136, 0.1); }
        }
        
        #chaos-zone::before {
            content: "üåÄ CHAOS ZONE - Libre cr√©ation";
            position: absolute;
            top: -12px;
            left: 20px;
            background: #1a1a2e;
            padding: 0 10px;
            font-size: 0.8rem;
            color: #e94560;
        }
        
        .chaos-content {
            text-align: center;
            padding: 3rem;
        }
        
        .chaos-content p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 1rem;
        }
        
        .info-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .info-section h2 {
            color: #e94560;
            margin-bottom: 1rem;
        }
        
        .info-section p {
            line-height: 1.6;
            color: #ccc;
        }
        
        .footer {
            text-align: center;
            padding: 2rem;
            color: #666;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
<div class="header">
<h1>‚ú® Emergent Canvas ‚ú®</h1>
<p>Une exp√©rience de cr√©ation collaborative</p>
</div>
<div class="status-bar">
<span>üé≠ Mode: Democracy</span>
<span>üîÑ Cycles: 0</span>
<span>‚è±Ô∏è D√©marr√©</span>
</div>
<div class="main-content">
<div id="chaos-zone">
<div class="chaos-content">
<p style="font-size:1.4rem;text-shadow:0 0 20px #e94560;">üß¨ 3D Cellular Automaton - EXPANDED UNIVERSE üåå Watch patterns evolve! ‚ö°</p>
<div id="automaton-container" style="width:100%;height:400px;position:relative;border-radius:8px;overflow:hidden;"></div>
<p style="margin-top:1rem;font-size:0.8rem;color:#e94560;">‚ö° Generation: <span id="gen-counter">0</span> | Living cells: <span id="cell-counter">0</span></p>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        (function() {
            const container = document.getElementById('automaton-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(45, 45, 45);
            camera.lookAt(0, 0, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            const gridSize = 30;
            let grid = [];
            let meshes = [];
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const cellGroup = new THREE.Group();
            scene.add(cellGroup);
            
            // Known patterns for 3D space (adapted from 2D classics)
            const patterns = {
                // 3D Glider-like pattern
                glider: [[0,0,0],[1,0,0],[2,0,0],[2,1,0],[1,2,0],[0,0,1],[1,0,1]],
                // Small oscillator
                blinker: [[0,0,0],[1,0,0],[2,0,0],[0,1,0],[1,1,0],[2,1,0]],
                // 3D block (still life)
                block: [[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]],
                // Cross pattern
                cross: [[1,0,0],[0,1,0],[1,1,0],[2,1,0],[1,2,0],[1,1,1]],
                // Tetrahedral cluster
                tetra: [[0,0,0],[1,0,0],[0,1,0],[0,0,1]]
            };
            
            function spawnPattern(pattern, ox, oy, oz) {
                pattern.forEach(([dx, dy, dz]) => {
                    const x = (ox + dx) % gridSize;
                    const y = (oy + dy) % gridSize;
                    const z = (oz + dz) % gridSize;
                    if (grid[x] && grid[x][y]) grid[x][y][z] = 1;
                });
            }
            
            // Initialize random grid
            function initGrid() {
                grid = [];
                for (let x = 0; x < gridSize; x++) {
                    grid[x] = [];
                    for (let y = 0; y < gridSize; y++) {
                        grid[x][y] = [];
                        for (let z = 0; z < gridSize; z++) {
                            grid[x][y][z] = 0; // Start empty
                        }
                    }
                }
                // Spawn patterns sparsely (8-15 patterns)
                const patternNames = Object.keys(patterns);
                const numPatterns = 8 + Math.floor(Math.random() * 8);
                for (let i = 0; i < numPatterns; i++) {
                    const patternName = patternNames[Math.floor(Math.random() * patternNames.length)];
                    const ox = Math.floor(Math.random() * gridSize);
                    const oy = Math.floor(Math.random() * gridSize);
                    const oz = Math.floor(Math.random() * gridSize);
                    spawnPattern(patterns[patternName], ox, oy, oz);
                }
                // Add some random noise (very sparse)
                for (let i = 0; i < gridSize * 2; i++) {
                    const x = Math.floor(Math.random() * gridSize);
                    const y = Math.floor(Math.random() * gridSize);
                    const z = Math.floor(Math.random() * gridSize);
                    grid[x][y][z] = 1;
                }
            }
            
            function countNeighbors(x, y, z) {
                let count = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            const nx = (x + dx + gridSize) % gridSize;
                            const ny = (y + dy + gridSize) % gridSize;
                            const nz = (z + dz + gridSize) % gridSize;
                            count += grid[nx][ny][nz];
                        }
                    }
                }
                return count;
            }
            
            function updateGrid() {
                const newGrid = [];
                for (let x = 0; x < gridSize; x++) {
                    newGrid[x] = [];
                    for (let y = 0; y < gridSize; y++) {
                        newGrid[x][y] = [];
                        for (let z = 0; z < gridSize; z++) {
                            const neighbors = countNeighbors(x, y, z);
                            // 3D Game of Life rules (4-5 to survive, 5 to birth)
                            if (grid[x][y][z]) {
                                newGrid[x][y][z] = (neighbors >= 4 && neighbors <= 5) ? 1 : 0;
                            } else {
                                newGrid[x][y][z] = neighbors === 5 ? 1 : 0;
                            }
                        }
                    }
                }
                grid = newGrid;
            }
            
            function renderCells() {
                while(cellGroup.children.length > 0) {
                    cellGroup.remove(cellGroup.children[0]);
                }
                let cellCount = 0;
                const offset = gridSize / 2;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        for (let z = 0; z < gridSize; z++) {
                            if (grid[x][y][z]) {
                                const hue = (x + y + z) / (gridSize * 3);
                                const material = new THREE.MeshBasicMaterial({ 
                                    color: new THREE.Color().setHSL(hue * 0.3 + 0.9, 0.8, 0.5),
                                    transparent: true,
                                    opacity: 0.85
                                });
                                const cube = new THREE.Mesh(geometry, material);
                                cube.position.set(x - offset, y - offset, z - offset);
                                cellGroup.add(cube);
                                cellCount++;
                            }
                        }
                    }
                }
                document.getElementById('cell-counter').textContent = cellCount;
                if (cellCount < 10) initGrid(); // Respawn if dying - larger world needs more cells
            }
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            // Add cool point lights
            const pointLight1 = new THREE.PointLight(0xe94560, 2, 50);
            pointLight1.position.set(15, 15, 15);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x00ff88, 2, 50);
            pointLight2.position.set(-15, -15, 15);
            scene.add(pointLight2);
            
            // Starfield background
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for(let i = 0; i < 500; i++) {
                starVertices.push((Math.random() - 0.5) * 200);
                starVertices.push((Math.random() - 0.5) * 200);
                starVertices.push((Math.random() - 0.5) * 200);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            initGrid();
            let generation = 0;
            let angle = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                angle += 0.008;
                camera.position.x = Math.cos(angle) * 55;
                camera.position.z = Math.sin(angle) * 55;
                camera.position.y = Math.sin(angle * 0.5) * 20 + 30;
                camera.lookAt(0, 0, 0);
                
                // Animate lights
                if(typeof pointLight1 !== 'undefined') {
                    pointLight1.position.x = Math.cos(angle * 2) * 20;
                    pointLight1.position.z = Math.sin(angle * 2) * 20;
                    pointLight2.position.x = Math.cos(angle * 2 + Math.PI) * 20;
                    pointLight2.position.z = Math.sin(angle * 2 + Math.PI) * 20;
                }
                
                // Rotate starfield slowly
                if(typeof stars !== 'undefined') {
                    stars.rotation.y += 0.0002;
                    stars.rotation.x += 0.0001;
                }
                
                renderer.render(scene, camera);
            }
            
            setInterval(() => {
                updateGrid();
                renderCells();
                generation++;
                document.getElementById('gen-counter').textContent = generation;
            }, 500);
            
            renderCells();
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        })();
        </script>
<div class="info-section">
<h2>üìã Comment participer ?</h2>
<p>
                Visitez le <strong>/backlog</strong> pour proposer des id√©es.
                Votez pour vos id√©es pr√©f√©r√©es.
                L'IA modifiera cette page selon les demandes les plus populaires.
            </p>
</div>
</div>
<div class="footer">
<p>Twitch Emergent Coding ‚Ä¢ Exp√©rience d'intelligence collective</p>
</div>
</body>
</html>