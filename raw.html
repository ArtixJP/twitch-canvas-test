<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Othello Game</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        min-height: 100vh;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-family: 'Segoe UI', system-ui, sans-serif;
        padding: 20px;
    }
    h1 {
        font-size: 2.5rem;
        color: white;
        margin-bottom: 10px;
        text-shadow: 0 0 10px #2ecc71, 0 0 20px #2ecc71;
    }
    .score-board {
        display: flex;
        gap: 40px;
        margin-bottom: 20px;
        color: white;
        font-size: 1.2rem;
    }
    .score {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 20px;
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        transition: transform 0.3s;
    }
    .score.active {
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
    }
    .disc-preview {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        box-shadow: inset -3px -3px 8px rgba(0,0,0,0.3);
    }
    .disc-preview.black { background: radial-gradient(circle at 30% 30%, #444, #111); }
    .disc-preview.white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); }
    .board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 2px;
        background: #111;
        padding: 10px;
        border-radius: 10px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .cell {
        width: 50px;
        height: 50px;
        background: #2d5016;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: background 0.2s;
        position: relative;
    }
    .cell:hover {
        background: #3d6a1e;
    }
    .cell.valid-move::after {
        content: '';
        width: 15px;
        height: 15px;
        background: rgba(46, 204, 113, 0.4);
        border-radius: 50%;
        animation: pulse 1s infinite;
    }
    @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 0.4; }
        50% { transform: scale(1.2); opacity: 0.7; }
    }
    .disc {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        transition: transform 0.5s;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3), inset -3px -3px 8px rgba(0,0,0,0.2);
    }
    .disc.black {
        background: radial-gradient(circle at 30% 30%, #444, #111);
    }
    .disc.white {
        background: radial-gradient(circle at 30% 30%, #fff, #ccc);
    }
    .disc.flip {
        animation: flip 0.5s ease-in-out;
    }
    @keyframes flip {
        0% { transform: rotateY(0deg); }
        50% { transform: rotateY(90deg); }
        100% { transform: rotateY(180deg); }
    }
    .disc.new {
        animation: pop 0.3s ease-out;
    }
    @keyframes pop {
        0% { transform: scale(0); }
        70% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    .message {
        margin-top: 20px;
        color: #2ecc71;
        font-size: 1.3rem;
        min-height: 30px;
    }
    .restart-btn {
        margin-top: 15px;
        padding: 12px 30px;
        font-size: 1rem;
        background: linear-gradient(135deg, #2ecc71, #27ae60);
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .restart-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 5px 20px rgba(46, 204, 113, 0.4);
    }
</style>
</head>
<body>
<h1>üéÆ Othello</h1>
<div class="score-board">
<div class="score" id="black-score">
<div class="disc-preview black"></div>
<span>Black: <strong id="black-count">2</strong></span>
</div>
<div class="score" id="white-score">
<div class="disc-preview white"></div>
<span>White: <strong id="white-count">2</strong></span>
</div>
</div>
<div class="board" id="board"></div>
<div class="message" id="message">Black's turn</div>
<button class="restart-btn" onclick="initGame()">üîÑ New Game</button>
<script>
const DIRECTIONS = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],          [0, 1],
    [1, -1], [1, 0], [1, 1]
];

let board = [];
let currentPlayer = 'black';
let gameOver = false;

function initGame() {
    board = Array(8).fill(null).map(() => Array(8).fill(null));
    board[3][3] = 'white';
    board[3][4] = 'black';
    board[4][3] = 'black';
    board[4][4] = 'white';
    currentPlayer = 'black';
    gameOver = false;
    renderBoard();
    updateScore();
    updateMessage();
}

function renderBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    const validMoves = getValidMoves(currentPlayer);
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (validMoves.some(m => m.row === row && m.col === col)) {
                cell.classList.add('valid-move');
            }
            
            if (board[row][col]) {
                const disc = document.createElement('div');
                disc.className = `disc ${board[row][col]}`;
                cell.appendChild(disc);
            }
            
            cell.addEventListener('click', () => handleClick(row, col));
            boardEl.appendChild(cell);
        }
    }
}

function getValidMoves(player) {
    const moves = [];
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (isValidMove(row, col, player)) {
                moves.push({ row, col });
            }
        }
    }
    return moves;
}

function isValidMove(row, col, player) {
    if (board[row][col] !== null) return false;
    
    const opponent = player === 'black' ? 'white' : 'black';
    
    for (const [dr, dc] of DIRECTIONS) {
        let r = row + dr;
        let c = col + dc;
        let foundOpponent = false;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (board[r][c] === opponent) {
                foundOpponent = true;
            } else if (board[r][c] === player && foundOpponent) {
                return true;
            } else {
                break;
            }
            r += dr;
            c += dc;
        }
    }
    return false;
}

function getFlips(row, col, player) {
    const flips = [];
    const opponent = player === 'black' ? 'white' : 'black';
    
    for (const [dr, dc] of DIRECTIONS) {
        const dirFlips = [];
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (board[r][c] === opponent) {
                dirFlips.push({ row: r, col: c });
            } else if (board[r][c] === player) {
                flips.push(...dirFlips);
                break;
            } else {
                break;
            }
            r += dr;
            c += dc;
        }
    }
    return flips;
}

function handleClick(row, col) {
    if (gameOver || !isValidMove(row, col, currentPlayer)) return;
    
    const flips = getFlips(row, col, currentPlayer);
    board[row][col] = currentPlayer;
    
    flips.forEach(f => {
        board[f.row][f.col] = currentPlayer;
    });
    
    currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
    
    if (getValidMoves(currentPlayer).length === 0) {
        currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
        if (getValidMoves(currentPlayer).length === 0) {
            gameOver = true;
        }
    }
    
    renderBoard();
    updateScore();
    updateMessage();
}

function updateScore() {
    let black = 0, white = 0;
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === 'black') black++;
            if (board[row][col] === 'white') white++;
        }
    }
    document.getElementById('black-count').textContent = black;
    document.getElementById('white-count').textContent = white;
    
    document.getElementById('black-score').classList.toggle('active', currentPlayer === 'black' && !gameOver);
    document.getElementById('white-score').classList.toggle('active', currentPlayer === 'white' && !gameOver);
}

function updateMessage() {
    const msg = document.getElementById('message');
    if (gameOver) {
        const black = parseInt(document.getElementById('black-count').textContent);
        const white = parseInt(document.getElementById('white-count').textContent);
        if (black > white) msg.textContent = 'üèÜ Black wins!';
        else if (white > black) msg.textContent = 'üèÜ White wins!';
        else msg.textContent = "ü§ù It's a tie!";
    } else {
        msg.textContent = `${currentPlayer === 'black' ? '‚ö´' : '‚ö™'} ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
    }
}

initGame();
</script>
</body>
</html>