<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Minecraft-like Voxel Game</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #87CEEB;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px black;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            font-size: 16px;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.5);
            border: 3px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
        }
        .hotbar-slot.selected {
            border-color: white;
            background: rgba(255,255,255,0.2);
        }
        .hotbar-slot span {
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            max-width: 400px;
        }
        #instructions h1 {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #7CFC00;
        }
        #instructions p {
            margin: 10px 0;
            font-size: 14px;
        }
        #instructions button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #instructions button:hover {
            transform: scale(1.05);
        }
        .key {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
<div id="game-container"></div>
<div id="crosshair"></div>
<div id="ui">
<p>Position: <span id="pos">0, 0, 0</span></p>
<p>Block: <span id="current-block">Grass</span></p>
</div>
<div id="hotbar">
<div class="hotbar-slot selected" data-block="grass"><span>üü©</span></div>
<div class="hotbar-slot" data-block="dirt"><span>üü´</span></div>
<div class="hotbar-slot" data-block="stone"><span>‚¨ú</span></div>
<div class="hotbar-slot" data-block="wood"><span>ü™µ</span></div>
<div class="hotbar-slot" data-block="leaves"><span>üåø</span></div>
<div class="hotbar-slot" data-block="sand"><span>üü®</span></div>
<div class="hotbar-slot" data-block="water"><span>üíß</span></div>
<div class="hotbar-slot" data-block="brick"><span>üß±</span></div>
<div class="hotbar-slot" data-block="glass"><span>üî≤</span></div>
</div>
<div id="instructions">
<h1>‚õèÔ∏è Voxel Builder</h1>
<p><span class="key">W A S D</span> - Move around</p>
<p><span class="key">SPACE</span> - Jump / Fly up</p>
<p><span class="key">SHIFT</span> - Fly down</p>
<p><span class="key">Left Click</span> - Break block</p>
<p><span class="key">Right Click</span> - Place block</p>
<p><span class="key">1-9</span> - Select block type</p>
<p><span class="key">Mouse</span> - Look around</p>
<button onclick="startGame()">Click to Play!</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        let scene, camera, renderer, controls;
        let blocks = new Map();
        let selectedBlock = 'grass';
        let velocity = { x: 0, y: 0, z: 0 };
        let isPlaying = false;
        let keys = {};
        
        const BLOCK_SIZE = 1;
        const WORLD_SIZE = 16;
        const GRAVITY = -0.015;
        const JUMP_FORCE = 0.25;
        const MOVE_SPEED = 0.15;
        const FLY_SPEED = 0.2;
        
        const blockColors = {
            grass: { top: 0x7CFC00, side: 0x8B4513, bottom: 0x8B4513 },
            dirt: { top: 0x8B4513, side: 0x8B4513, bottom: 0x8B4513 },
            stone: { top: 0x808080, side: 0x808080, bottom: 0x808080 },
            wood: { top: 0xDEB887, side: 0x8B4513, bottom: 0xDEB887 },
            leaves: { top: 0x228B22, side: 0x228B22, bottom: 0x228B22 },
            sand: { top: 0xF4A460, side: 0xF4A460, bottom: 0xF4A460 },
            water: { top: 0x4169E1, side: 0x4169E1, bottom: 0x4169E1 },
            brick: { top: 0xB22222, side: 0xB22222, bottom: 0xB22222 },
            glass: { top: 0xADD8E6, side: 0xADD8E6, bottom: 0xADD8E6 }
        };
        
        const blockNames = {
            grass: 'Grass', dirt: 'Dirt', stone: 'Stone', wood: 'Wood',
            leaves: 'Leaves', sand: 'Sand', water: 'Water', brick: 'Brick', glass: 'Glass'
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(WORLD_SIZE/2, 10, WORLD_SIZE/2);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // Generate terrain
            generateTerrain();
            
            // Event listeners
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            window.addEventListener('resize', onWindowResize);
            
            // Hotbar selection
            document.querySelectorAll('.hotbar-slot').forEach((slot, index) => {
                slot.addEventListener('click', () => selectSlot(index));
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key >= '1' && e.key <= '9') {
                    selectSlot(parseInt(e.key) - 1);
                }
            });
            
            animate();
        }
        
        function selectSlot(index) {
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach(s => s.classList.remove('selected'));
            if (slots[index]) {
                slots[index].classList.add('selected');
                selectedBlock = slots[index].dataset.block;
                document.getElementById('current-block').textContent = blockNames[selectedBlock];
            }
        }
        
        function generateTerrain() {
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let z = 0; z < WORLD_SIZE; z++) {
                    // Simple height variation using sine waves
                    const height = Math.floor(3 + Math.sin(x * 0.3) * 2 + Math.cos(z * 0.3) * 2);
                    
                    for (let y = 0; y <= height; y++) {
                        let blockType = 'dirt';
                        if (y === height) blockType = 'grass';
                        else if (y < height - 2) blockType = 'stone';
                        
                        createBlock(x, y, z, blockType);
                    }
                    
                    // Add some trees
                    if (Math.random() < 0.03 && height > 2) {
                        createTree(x, height + 1, z);
                    }
                }
            }
            
            // Create a beautiful tower
            createTower(WORLD_SIZE/2, 4, WORLD_SIZE/2);
            
            // Create Mario!
            createMario(WORLD_SIZE/2 + 8, 5, WORLD_SIZE/2);
        }
        
        function createTower(x, baseY, z) {
            const towerHeight = 15;
            const towerRadius = 3;
            
            // Build circular tower walls
            for (let h = 0; h < towerHeight; h++) {
                for (let dx = -towerRadius; dx <= towerRadius; dx++) {
                    for (let dz = -towerRadius; dz <= towerRadius; dz++) {
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        // Create hollow cylinder
                        if (dist <= towerRadius && dist >= towerRadius - 1) {
                            // Windows every 4 blocks, starting at height 3
                            const isWindow = (h > 2 && h < towerHeight - 2) && (h % 4 === 0) && 
                                           (Math.abs(dx) === towerRadius || Math.abs(dz) === towerRadius) &&
                                           (dx === 0 || dz === 0);
                            
                            if (isWindow) {
                                createBlock(x + dx, baseY + h, z + dz, 'glass');
                            } else {
                                createBlock(x + dx, baseY + h, z + dz, 'stone');
                            }
                        }
                        // Floor every 4 levels
                        if (dist < towerRadius - 0.5 && (h === 0 || h % 5 === 0)) {
                            createBlock(x + dx, baseY + h, z + dz, 'wood');
                        }
                    }
                }
            }
            
            // Battlements at top
            for (let dx = -towerRadius - 1; dx <= towerRadius + 1; dx++) {
                for (let dz = -towerRadius - 1; dz <= towerRadius + 1; dz++) {
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist <= towerRadius + 1 && dist >= towerRadius - 0.5) {
                        // Crenellations
                        if ((dx + dz) % 2 === 0) {
                            createBlock(x + dx, baseY + towerHeight, z + dz, 'stone');
                            createBlock(x + dx, baseY + towerHeight + 1, z + dz, 'stone');
                        } else {
                            createBlock(x + dx, baseY + towerHeight, z + dz, 'stone');
                        }
                    }
                }
            }
            
            // Pointed roof
            for (let level = 0; level < 5; level++) {
                const roofRadius = towerRadius - level * 0.6;
                for (let dx = -Math.ceil(roofRadius); dx <= Math.ceil(roofRadius); dx++) {
                    for (let dz = -Math.ceil(roofRadius); dz <= Math.ceil(roofRadius); dz++) {
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        if (dist <= roofRadius + 0.5) {
                            createBlock(x + dx, baseY + towerHeight + 2 + level, z + dz, 'brick');
                        }
                    }
                }
            }
            
            // Flag pole at top
            for (let i = 0; i < 3; i++) {
                createBlock(x, baseY + towerHeight + 7 + i, z, 'wood');
            }
            // Flag
            createBlock(x + 1, baseY + towerHeight + 9, z, 'brick');
            createBlock(x + 2, baseY + towerHeight + 9, z, 'brick');
            createBlock(x + 1, baseY + towerHeight + 8, z, 'brick');
            
            // Entrance arch
            removeBlock(x, baseY + 1, z + towerRadius);
            removeBlock(x, baseY + 2, z + towerRadius);
            createBlock(x - 1, baseY + 3, z + towerRadius, 'stone');
            createBlock(x + 1, baseY + 3, z + towerRadius, 'stone');
            
            // Torch holders (represented as sand for glow effect)
            createBlock(x - 2, baseY + 2, z + towerRadius + 1, 'sand');
            createBlock(x + 2, baseY + 2, z + towerRadius + 1, 'sand');
        }
        
        function createMario(x, baseY, z) {
            // Mario colors
            const red = 'brick';      // Red for hat and shirt
            const blue = 'water';     // Blue for overalls (using water's blue)
            const skin = 'sand';      // Skin tone
            const brown = 'dirt';     // Brown for hair and shoes
            
            // Layer 0 - Feet (y = baseY)
            createBlock(x - 1, baseY, z, brown);  // Left shoe
            createBlock(x + 1, baseY, z, brown);  // Right shoe
            
            // Layer 1 - Legs
            createBlock(x - 1, baseY + 1, z, blue);
            createBlock(x + 1, baseY + 1, z, blue);
            
            // Layer 2 - Lower body
            createBlock(x - 1, baseY + 2, z, blue);
            createBlock(x, baseY + 2, z, blue);
            createBlock(x + 1, baseY + 2, z, blue);
            
            // Layer 3 - Upper body / overalls
            createBlock(x - 1, baseY + 3, z, blue);
            createBlock(x, baseY + 3, z, red);
            createBlock(x + 1, baseY + 3, z, blue);
            
            // Layer 4 - Chest and arms
            createBlock(x - 2, baseY + 4, z, skin);  // Left hand
            createBlock(x - 1, baseY + 4, z, red);
            createBlock(x, baseY + 4, z, red);
            createBlock(x + 1, baseY + 4, z, red);
            createBlock(x + 2, baseY + 4, z, skin);  // Right hand
            
            // Layer 5 - Neck/chin area
            createBlock(x, baseY + 5, z, skin);
            
            // Layer 6 - Face
            createBlock(x - 1, baseY + 6, z, skin);
            createBlock(x, baseY + 6, z, skin);
            createBlock(x + 1, baseY + 6, z, skin);
            createBlock(x, baseY + 6, z - 1, skin);  // Nose!
            
            // Layer 7 - Upper face and mustache
            createBlock(x - 1, baseY + 7, z, skin);
            createBlock(x, baseY + 7, z, brown);     // Mustache
            createBlock(x + 1, baseY + 7, z, skin);
            
            // Layer 8 - Hair and hat brim
            createBlock(x - 1, baseY + 8, z, brown);  // Hair
            createBlock(x, baseY + 8, z, red);        // Hat
            createBlock(x + 1, baseY + 8, z, brown);  // Hair
            createBlock(x, baseY + 8, z - 1, red);    // Hat brim
            
            // Layer 9 - Hat top
            createBlock(x - 1, baseY + 9, z, red);
            createBlock(x, baseY + 9, z, red);
            createBlock(x + 1, baseY + 9, z, red);
            
            // Layer 10 - Hat tip
            createBlock(x, baseY + 10, z, red);
        }
        
        function createTree(x, y, z) {
            // Trunk
            for (let i = 0; i < 4; i++) {
                createBlock(x, y + i, z, 'wood');
            }
            // Leaves
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = 3; dy <= 5; dy++) {
                        if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy - 4) < 4) {
                            if (dx !== 0 || dz !== 0 || dy > 3) {
                                createBlock(x + dx, y + dy, z + dz, 'leaves');
                            }
                        }
                    }
                }
            }
        }
        
        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (blocks.has(key)) return;
            
            const colors = blockColors[type];
            const materials = [
                new THREE.MeshLambertMaterial({ color: colors.side }),
                new THREE.MeshLambertMaterial({ color: colors.side }),
                new THREE.MeshLambertMaterial({ color: colors.top }),
                new THREE.MeshLambertMaterial({ color: colors.bottom }),
                new THREE.MeshLambertMaterial({ color: colors.side }),
                new THREE.MeshLambertMaterial({ color: colors.side })
            ];
            
            if (type === 'glass') {
                materials.forEach(m => { m.transparent = true; m.opacity = 0.5; });
            }
            if (type === 'water') {
                materials.forEach(m => { m.transparent = true; m.opacity = 0.7; });
            }
            
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const mesh = new THREE.Mesh(geometry, materials);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type, key };
            
            scene.add(mesh);
            blocks.set(key, mesh);
        }
        
        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            if (block) {
                scene.remove(block);
                blocks.delete(key);
            }
        }
        
        function startGame() {
            document.getElementById('instructions').style.display = 'none';
            document.body.requestPointerLock();
            isPlaying = true;
        }
        
        let pitch = 0, yaw = 0;
        
        function onMouseMove(e) {
            if (!isPlaying || !document.pointerLockElement) return;
            
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        }
        
        function onMouseDown(e) {
            if (!isPlaying) return;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const meshes = Array.from(blocks.values());
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                const block = hit.object;
                
                if (e.button === 0) {
                    // Left click - break block
                    const pos = block.position;
                    removeBlock(pos.x, pos.y, pos.z);
                } else if (e.button === 2) {
                    // Right click - place block
                    const normal = hit.face.normal;
                    const newPos = block.position.clone().add(normal);
                    createBlock(Math.round(newPos.x), Math.round(newPos.y), Math.round(newPos.z), selectedBlock);
                }
            }
        }
        
        function updatePlayer() {
            if (!isPlaying) return;
            
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            // Movement
            if (keys['KeyW']) camera.position.addScaledVector(forward, MOVE_SPEED);
            if (keys['KeyS']) camera.position.addScaledVector(forward, -MOVE_SPEED);
            if (keys['KeyA']) camera.position.addScaledVector(right, -MOVE_SPEED);
            if (keys['KeyD']) camera.position.addScaledVector(right, MOVE_SPEED);
            
            // Flying
            if (keys['Space']) camera.position.y += FLY_SPEED;
            if (keys['ShiftLeft'] || keys['ShiftRight']) camera.position.y -= FLY_SPEED;
            
            // Keep above ground
            if (camera.position.y < 2) camera.position.y = 2;
            
            // Update position display
            document.getElementById('pos').textContent = 
                `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }
        
        document.addEventListener('pointerlockchange', () => {
            if (!document.pointerLockElement && isPlaying) {
                document.getElementById('instructions').style.display = 'block';
            }
        });
        
        init();
    </script>
</body>
</html>