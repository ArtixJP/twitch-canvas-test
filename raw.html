<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Twitch RPG - French Keyboard Edition</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        body { 
            font-family: system-ui, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
        }
        h1 { font-size: 3rem; text-align: center; }
        #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #ui { position: fixed; top: 20px; left: 20px; z-index: 100; font-size: 14px; }
        .health-bar { width: 200px; height: 20px; background: #333; border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #ff6666); transition: width 0.3s; }
        .stats { margin-top: 10px; }
        #controls { position: fixed; bottom: 20px; left: 20px; z-index: 100; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; }
        .xp-bar { width: 200px; height: 10px; background: #333; border: 2px solid #gold; border-radius: 5px; margin-top: 5px; }
        .xp-fill { height: 100%; background: linear-gradient(90deg, #ffd700, #ffec8b); transition: width 0.3s; }
    </style>
</head>
<body>
<div id="game-container"></div>
<div id="ui">
<h2>üó°Ô∏è Hero</h2>
<div class="health-bar"><div class="health-fill" id="health" style="width: 100%"></div></div>
<div class="stats">HP: <span id="hp-text">100</span>/100</div>
<div class="xp-bar"><div class="xp-fill" id="xp" style="width: 0%"></div></div>
<div class="stats">Level: <span id="level">1</span> | XP: <span id="xp-text">0</span>/100</div>
<div class="stats">Enemies: <span id="enemies">0</span> | Score: <span id="score">0</span></div>
</div>
<div id="controls">
<strong>üéÆ Controls (AZERTY)</strong><br/>
        Z - Forward | S - Back<br/>
        Q - Left | D - Right<br/>
        SPACE - Attack<br/>
        E - Special Attack
    </div>
<h1 style="position:fixed;bottom:60px;right:20px;font-size:1rem;opacity:0.5">Hello World</h1>
<script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    // Lights
    const ambient = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    scene.add(sun);
    
    // Floor
    const floorGeo = new THREE.PlaneGeometry(100, 100);
    const floorMat = new THREE.MeshStandardMaterial({color: 0x2d5a27});
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);
    
    // Player
    const playerGeo = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const playerMat = new THREE.MeshStandardMaterial({color: 0x4488ff});
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.position.y = 1;
    player.castShadow = true;
    scene.add(player);
    
    // Sword
    const swordGeo = new THREE.BoxGeometry(0.1, 1.5, 0.1);
    const swordMat = new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.8});
    const sword = new THREE.Mesh(swordGeo, swordMat);
    sword.position.set(0.7, 0.5, 0);
    player.add(sword);
    
    let hp = 100, xp = 0, level = 1, score = 0;
    const enemies = [];
    const keys = {};
    let attacking = false;
    
    function spawnEnemy() {
        const enemyGeo = new THREE.SphereGeometry(0.6, 8, 8);
        const enemyMat = new THREE.MeshStandardMaterial({color: 0xff4444});
        const enemy = new THREE.Mesh(enemyGeo, enemyMat);
        const angle = Math.random() * Math.PI * 2;
        const dist = 15 + Math.random() * 10;
        enemy.position.set(Math.cos(angle)*dist, 0.6, Math.sin(angle)*dist);
        enemy.castShadow = true;
        enemy.userData = {hp: 30, speed: 0.02 + level*0.005};
        scene.add(enemy);
        enemies.push(enemy);
        document.getElementById('enemies').textContent = enemies.length;
    }
    for(let i=0;i<5;i++) spawnEnemy();
    setInterval(spawnEnemy, 3000);
    
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    camera.position.set(0, 8, 10);
    camera.lookAt(player.position);
    
    function attack() {
        if(attacking) return;
        attacking = true;
        sword.rotation.x = -Math.PI/2;
        enemies.forEach((e,i) => {
            if(player.position.distanceTo(e.position) < 3) {
                e.userData.hp -= 20 + level*5;
                e.material.emissive.setHex(0xffffff);
                setTimeout(() => e.material.emissive.setHex(0), 100);
                if(e.userData.hp <= 0) {
                    scene.remove(e);
                    enemies.splice(i, 1);
                    xp += 25;
                    score += 100;
                    if(xp >= 100) { level++; xp = 0; hp = Math.min(100, hp+20); }
                    updateUI();
                }
            }
        });
        setTimeout(() => { sword.rotation.x = 0; attacking = false; }, 300);
    }
    
    function updateUI() {
        document.getElementById('health').style.width = hp+'%';
        document.getElementById('hp-text').textContent = hp;
        document.getElementById('xp').style.width = xp+'%';
        document.getElementById('xp-text').textContent = xp;
        document.getElementById('level').textContent = level;
        document.getElementById('score').textContent = score;
        document.getElementById('enemies').textContent = enemies.length;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        const speed = 0.15;
        if(keys['z']) player.position.z -= speed;
        if(keys['s']) player.position.z += speed;
        if(keys['q']) player.position.x -= speed;
        if(keys['d']) player.position.x += speed;
        if(keys[' ']) attack();
        
        enemies.forEach(e => {
            const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
            e.position.add(dir.multiplyScalar(e.userData.speed));
            if(e.position.distanceTo(player.position) < 1.2) {
                hp -= 0.5;
                updateUI();
                if(hp <= 0) { alert('Game Over! Score: '+score); location.reload(); }
            }
        });
        
        camera.position.x = player.position.x;
        camera.position.z = player.position.z + 10;
        camera.lookAt(player.position);
        renderer.render(scene, camera);
    }
    animate();
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>