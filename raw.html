<!DOCTYPE html>

<html lang="fr">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>üåÄ Emergent Canvas</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #e94560;
        }
        
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #e94560, #00ff88, #0f3460, #ff00ff, #e94560);
            background-size: 400% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 2s linear infinite;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
            filter: drop-shadow(0 0 10px #e94560);
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            font-size: 0.9rem;
            color: #888;
        }
        
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Zone de chaos - libre modification */
        #chaos-zone {
            background: rgba(233, 69, 96, 0.1);
            border: 2px dashed #e94560;
            border-radius: 12px;
            padding: 2rem;
            min-height: 300px;
            margin: 2rem 0;
            position: relative;
            box-shadow: 0 0 40px rgba(233, 69, 96, 0.3), inset 0 0 60px rgba(0, 255, 136, 0.05);
            animation: zone-pulse 4s ease-in-out infinite;
        }
        
        @keyframes zone-pulse {
            0%, 100% { box-shadow: 0 0 40px rgba(233, 69, 96, 0.3), inset 0 0 60px rgba(0, 255, 136, 0.05); }
            50% { box-shadow: 0 0 80px rgba(233, 69, 96, 0.5), inset 0 0 100px rgba(0, 255, 136, 0.1); }
        }
        
        #chaos-zone::before {
            content: "üåÄ CHAOS ZONE - Libre cr√©ation";
            position: absolute;
            top: -12px;
            left: 20px;
            background: #1a1a2e;
            padding: 0 10px;
            font-size: 0.8rem;
            color: #e94560;
        }
        
        .chaos-content {
            text-align: center;
            padding: 3rem;
        }
        
        .chaos-content p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 1rem;
        }
        
        .info-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .info-section h2 {
            color: #e94560;
            margin-bottom: 1rem;
        }
        
        .info-section p {
            line-height: 1.6;
            color: #ccc;
        }
        
        .footer {
            text-align: center;
            padding: 2rem;
            color: #666;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
<div class="header">
<h1>‚ú® Emergent Canvas ‚ú®</h1>
<p>Une exp√©rience de cr√©ation collaborative</p>
</div>
<div class="status-bar">
<span>üé≠ Mode: Democracy</span>
<span>üîÑ Cycles: 0</span>
<span>‚è±Ô∏è D√©marr√©</span>
</div>
<div class="main-content">
<div id="chaos-zone">
<div class="chaos-content">
<p style="font-size:1.4rem;text-shadow:0 0 20px #e94560;">üß¨ 3D Cellular Automaton - <span style="color:#00ff88;">MEGA UNIVERSE 10K¬≥</span> üåå Watch patterns evolve! ‚ö°</p>
<div style="display:inline-block;background:linear-gradient(90deg,#00ff88,#00ccff);padding:4px 12px;border-radius:20px;font-size:0.7rem;font-weight:bold;color:#000;margin-top:8px;animation:pulse-badge 1.5s ease-in-out infinite;">üåä INFINITE STREAMING MODE - Only visible chunks loaded!</div>
<div style="display:inline-block;background:linear-gradient(90deg,#ff00ff,#e94560);padding:4px 12px;border-radius:20px;font-size:0.7rem;font-weight:bold;color:#fff;margin-left:8px;margin-top:8px;animation:pulse-badge 1.5s ease-in-out infinite;">üé≤ 50/50 CHAOS INIT - Maximum entropy!</div>
<div style="display:inline-block;background:linear-gradient(90deg,#ffd700,#ff6b35);padding:4px 12px;border-radius:20px;font-size:0.7rem;font-weight:bold;color:#000;margin-left:8px;margin-top:8px;animation:pulse-badge 1.5s ease-in-out infinite;">üè† TERRITORY MODE - Claim your sector!</div>
<style>@keyframes pulse-badge{0%,100%{transform:scale(1);box-shadow:0 0 10px #00ff88;}50%{transform:scale(1.05);box-shadow:0 0 20px #00ccff;}}</style>
<div id="automaton-container" style="width:100%;height:400px;position:relative;border-radius:8px;overflow:hidden;"></div>
<p style="margin-top:1rem;font-size:0.8rem;color:#e94560;">‚ö° Generation: <span id="gen-counter">0</span> | Living cells: <span id="cell-counter">0</span> | üåå Universe: <span style="color:#00ff88;font-weight:bold;">10K¬≥ parsecs</span></p>
<p style="font-size:0.75rem;color:#00ccff;margin-top:0.3rem;">üíæ Memory: <span id="mem-display" style="color:#00ff88;">~2MB</span> / <span style="color:#ff6666;">10TB theoretical</span> | <span style="color:#ff00ff;">Chunks loaded: <span id="chunks-loaded">1</span>/‚àû</span></p>
<p style="font-size:0.7rem;color:#666;margin-top:0.5rem;">üí° <span style="color:#00ff88;">NEVER loads full grid!</span> Streaming chunks on-demand ‚Ä¢ Only <span style="color:#00ccff;">~112¬≥ cells</span> active at once ‚Ä¢ Click to warp through infinite space</p>

<div id="territory-panel" style="margin-top:1.5rem;padding:1rem;background:rgba(0,0,0,0.4);border-radius:12px;border:1px solid rgba(255,215,0,0.3);">
<h3 style="color:#ffd700;font-size:0.9rem;margin-bottom:0.8rem;">üó∫Ô∏è TERRITORY ALLOCATION SYSTEM</h3>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:1rem;">
<div class="sector" id="sector-alpha" style="background:linear-gradient(135deg,rgba(233,69,96,0.3),rgba(233,69,96,0.1));border:2px solid #e94560;border-radius:8px;padding:0.5rem;text-align:center;cursor:pointer;transition:all 0.3s;">
<span style="font-size:1.2rem;">üî¥</span><br/>
<span style="font-size:0.65rem;color:#e94560;">SECTOR Œ±</span><br/>
<span id="user-alpha" style="font-size:0.6rem;color:#888;">Available</span>
</div>
<div class="sector" id="sector-beta" style="background:linear-gradient(135deg,rgba(0,255,136,0.3),rgba(0,255,136,0.1));border:2px solid #00ff88;border-radius:8px;padding:0.5rem;text-align:center;cursor:pointer;transition:all 0.3s;">
<span style="font-size:1.2rem;">üü¢</span><br/>
<span style="font-size:0.65rem;color:#00ff88;">SECTOR Œ≤</span><br/>
<span id="user-beta" style="font-size:0.6rem;color:#888;">Available</span>
</div>
<div class="sector" id="sector-gamma" style="background:linear-gradient(135deg,rgba(0,204,255,0.3),rgba(0,204,255,0.1));border:2px solid #00ccff;border-radius:8px;padding:0.5rem;text-align:center;cursor:pointer;transition:all 0.3s;">
<span style="font-size:1.2rem;">üîµ</span><br/>
<span style="font-size:0.65rem;color:#00ccff;">SECTOR Œ≥</span><br/>
<span id="user-gamma" style="font-size:0.6rem;color:#888;">Available</span>
</div>
<div class="sector" id="sector-delta" style="background:linear-gradient(135deg,rgba(255,0,255,0.3),rgba(255,0,255,0.1));border:2px solid #ff00ff;border-radius:8px;padding:0.5rem;text-align:center;cursor:pointer;transition:all 0.3s;">
<span style="font-size:1.2rem;">üü£</span><br/>
<span style="font-size:0.65rem;color:#ff00ff;">SECTOR Œ¥</span><br/>
<span id="user-delta" style="font-size:0.6rem;color:#888;">Available</span>
</div>
</div>
<p style="font-size:0.65rem;color:#aaa;">üëÜ Click a sector to claim your territory in the 10K¬≥ universe ‚Ä¢ Your cells will glow with your sector color!</p>
<div style="margin-top:0.8rem;padding:0.5rem;background:rgba(255,215,0,0.1);border-radius:6px;">
<span style="font-size:0.7rem;color:#ffd700;">üë§ Your Assignment: </span>
<span id="my-sector" style="font-size:0.7rem;color:#fff;font-weight:bold;">None - Click to claim!</span>
</div>
</div>
<script>
(function(){
  const sectors = ['alpha','beta','gamma','delta'];
  const colors = {alpha:'#e94560',beta:'#00ff88',gamma:'#00ccff',delta:'#ff00ff'};
  const names = ['Voyager_'+Math.floor(Math.random()*1000),'Explorer_'+Math.floor(Math.random()*1000),'Pioneer_'+Math.floor(Math.random()*1000),'Nomad_'+Math.floor(Math.random()*1000)];
  let myId = 'User_'+Math.floor(Math.random()*10000);
  let claimed = localStorage.getItem('mySector');
  
  // Simulate other users
  setTimeout(()=>{
    document.getElementById('user-beta').textContent = names[1];
    document.getElementById('user-beta').style.color = '#00ff88';
  }, 2000);
  setTimeout(()=>{
    document.getElementById('user-delta').textContent = names[3];
    document.getElementById('user-delta').style.color = '#ff00ff';
  }, 4000);
  
  if(claimed){
    document.getElementById('my-sector').textContent = 'SECTOR '+claimed.toUpperCase()+' ('+myId+')';
    document.getElementById('my-sector').style.color = colors[claimed];
    document.getElementById('user-'+claimed).textContent = myId;
    document.getElementById('user-'+claimed).style.color = colors[claimed];
  }
  
  sectors.forEach(s=>{
    document.getElementById('sector-'+s).addEventListener('click',function(){
      if(!claimed){
        claimed = s;
        localStorage.setItem('mySector',s);
        document.getElementById('my-sector').textContent = 'SECTOR '+s.toUpperCase()+' ('+myId+')';
        document.getElementById('my-sector').style.color = colors[s];
        document.getElementById('user-'+s).textContent = myId;
        document.getElementById('user-'+s).style.color = colors[s];
        this.style.transform = 'scale(1.1)';
        this.style.boxShadow = '0 0 20px '+colors[s];
      }
    });
    document.getElementById('sector-'+s).addEventListener('mouseenter',function(){
      this.style.transform = 'scale(1.05)';
    });
    document.getElementById('sector-'+s).addEventListener('mouseleave',function(){
      if(claimed !== s) this.style.transform = 'scale(1)';
    });
  });
})();
</script>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        (function() {
            const container = document.getElementById('automaton-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.008); // Cosmic fog for depth
            camera.position.set(80, 80, 80);
            camera.lookAt(0, 0, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // üåå INFINITE UNIVERSE SYSTEM - Only load visible chunks!
            const UNIVERSE_SIZE = 10000; // 10K parsecs per axis
            const CHUNK_SIZE = 16; // Each chunk is 16¬≥ cells
            const RENDER_DISTANCE = 3; // Chunks visible around camera
            const gridSize = CHUNK_SIZE * (RENDER_DISTANCE * 2 + 1); // Active simulation area
            
            // Chunk management system
            const loadedChunks = new Map();
            let currentChunkX = 0, currentChunkY = 0, currentChunkZ = 0;
            
            let grid = [];
            let meshes = [];
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const cellGroup = new THREE.Group();
            scene.add(cellGroup);
            
            // Procedural chunk generation based on coordinates
            function getChunkSeed(cx, cy, cz) {
                return ((cx * 73856093) ^ (cy * 19349663) ^ (cz * 83492791)) % 2147483647;
            }
            
            function seededRandom(seed) {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            }
            
            // Known patterns for 3D space (adapted from 2D classics)
            const patterns = {
                // 3D Glider-like pattern
                glider: [[0,0,0],[1,0,0],[2,0,0],[2,1,0],[1,2,0],[0,0,1],[1,0,1]],
                // Small oscillator
                blinker: [[0,0,0],[1,0,0],[2,0,0],[0,1,0],[1,1,0],[2,1,0]],
                // 3D block (still life)
                block: [[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]],
                // Cross pattern
                cross: [[1,0,0],[0,1,0],[1,1,0],[2,1,0],[1,2,0],[1,1,1]],
                // Tetrahedral cluster
                tetra: [[0,0,0],[1,0,0],[0,1,0],[0,0,1]]
            };
            
            function spawnPattern(pattern, ox, oy, oz) {
                pattern.forEach(([dx, dy, dz]) => {
                    const x = (ox + dx) % gridSize;
                    const y = (oy + dy) % gridSize;
                    const z = (oz + dz) % gridSize;
                    if (grid[x] && grid[x][y]) grid[x][y][z] = 1;
                });
            }
            
            // Initialize grid with 50/50 probability - CHAOS MODE! üé≤
            function initGrid() {
                grid = [];
                const chunkSeed = getChunkSeed(currentChunkX, currentChunkY, currentChunkZ);
                let seedCounter = chunkSeed;
                for (let x = 0; x < gridSize; x++) {
                    grid[x] = [];
                    for (let y = 0; y < gridSize; y++) {
                        grid[x][y] = [];
                        for (let z = 0; z < gridSize; z++) {
                            // üé≤ 50/50 PROBABILITY - True chaos initialization!
                            grid[x][y][z] = seededRandom(seedCounter++) < 0.5 ? 1 : 0;
                        }
                    }
                }
                console.log('üåå Loaded chunk [' + currentChunkX + ',' + currentChunkY + ',' + currentChunkZ + '] - Universe pos: ' + (currentChunkX * CHUNK_SIZE) + '/' + UNIVERSE_SIZE);
                if(document.getElementById('chunks-loaded')) document.getElementById('chunks-loaded').textContent = loadedChunks.size + 1;
                if(document.getElementById('mem-display')) document.getElementById('mem-display').textContent = '~' + Math.round((gridSize * gridSize * gridSize * 4) / 1024 / 1024 * 10) / 10 + 'MB';
            }
            
            function countNeighbors(x, y, z) {
                let count = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (dx === 0 && dy === 0 && dz === 0) continue;
                            const nx = (x + dx + gridSize) % gridSize;
                            const ny = (y + dy + gridSize) % gridSize;
                            const nz = (z + dz + gridSize) % gridSize;
                            count += grid[nx][ny][nz];
                        }
                    }
                }
                return count;
            }
            
            function updateGrid() {
                const newGrid = [];
                for (let x = 0; x < gridSize; x++) {
                    newGrid[x] = [];
                    for (let y = 0; y < gridSize; y++) {
                        newGrid[x][y] = [];
                        for (let z = 0; z < gridSize; z++) {
                            const neighbors = countNeighbors(x, y, z);
                            // 3D Game of Life rules (4-5 to survive, 5 to birth)
                            if (grid[x][y][z]) {
                                newGrid[x][y][z] = (neighbors >= 4 && neighbors <= 5) ? 1 : 0;
                            } else {
                                newGrid[x][y][z] = neighbors === 5 ? 1 : 0;
                            }
                        }
                    }
                }
                grid = newGrid;
            }
            
            function renderCells() {
                while(cellGroup.children.length > 0) {
                    cellGroup.remove(cellGroup.children[0]);
                }
                let cellCount = 0;
                const offset = gridSize / 2;
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        for (let z = 0; z < gridSize; z++) {
                            if (grid[x][y][z]) {
                                const hue = (x + y + z) / (gridSize * 3);
                                const material = new THREE.MeshBasicMaterial({ 
                                    color: new THREE.Color().setHSL(hue * 0.3 + 0.9, 0.8, 0.5),
                                    transparent: true,
                                    opacity: 0.85
                                });
                                const cube = new THREE.Mesh(geometry, material);
                                cube.position.set(x - offset, y - offset, z - offset);
                                cellGroup.add(cube);
                                cellCount++;
                            }
                        }
                    }
                }
                document.getElementById('cell-counter').textContent = cellCount + ' (chunk ' + currentChunkX + ',' + currentChunkY + ',' + currentChunkZ + ')';
                if (cellCount < 10) {
                    // Drift to new chunk instead of reset!
                    currentChunkX += Math.floor(Math.random() * 3) - 1;
                    currentChunkY += Math.floor(Math.random() * 3) - 1;
                    currentChunkZ += Math.floor(Math.random() * 3) - 1;
                    initGrid(); // Load new chunk
                }
            }
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            // Add cool point lights
            const pointLight1 = new THREE.PointLight(0xe94560, 3, 100);
            pointLight1.position.set(15, 15, 15);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x00ff88, 3, 100);
            pointLight2.position.set(-15, -15, 15);
            scene.add(pointLight2);
            
            // Starfield background
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for(let i = 0; i < 3000; i++) { // 6x more stars for infinite universe feel
                starVertices.push((Math.random() - 0.5) * 500);
                starVertices.push((Math.random() - 0.5) * 500);
                starVertices.push((Math.random() - 0.5) * 500);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            initGrid();
            let generation = 0;
            let angle = 0;
            
            function animate() {
                requestAnimationFrame(animate);
                angle += 0.008;
                camera.position.x = Math.cos(angle) * 90;
                camera.position.z = Math.sin(angle) * 90;
                camera.position.y = Math.sin(angle * 0.5) * 35 + 50;
                camera.lookAt(0, 0, 0);
                
                // Animate lights
                if(typeof pointLight1 !== 'undefined') {
                    pointLight1.position.x = Math.cos(angle * 2) * 20;
                    pointLight1.position.z = Math.sin(angle * 2) * 20;
                    pointLight2.position.x = Math.cos(angle * 2 + Math.PI) * 20;
                    pointLight2.position.z = Math.sin(angle * 2 + Math.PI) * 20;
                }
                
                // Rotate starfield slowly
                if(typeof stars !== 'undefined') {
                    stars.rotation.y += 0.0002;
                    stars.rotation.x += 0.0001;
                }
                
                renderer.render(scene, camera);
            }
            
            setInterval(() => {
                updateGrid();
                renderCells();
                generation++;
                document.getElementById('gen-counter').textContent = generation;
            }, 500);
            
            renderCells();
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        })();
        </script>
<div class="info-section">
<h2>üìã Comment participer ?</h2>
<p>
                Visitez le <strong>/backlog</strong> pour proposer des id√©es.
                Votez pour vos id√©es pr√©f√©r√©es.
                L'IA modifiera cette page selon les demandes les plus populaires.
            </p>
</div>
</div>
<div class="footer">
<p>Twitch Emergent Coding ‚Ä¢ Exp√©rience d'intelligence collective</p>
</div>
</body>
</html>