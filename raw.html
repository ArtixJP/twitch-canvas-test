<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Mario's Rescue - A Love Story</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
        font-family: 'Courier New', monospace; 
        overflow: hidden;
        background: #1a1a2e;
    }
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
    }
    .title {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2rem;
        color: #E52521;
        text-shadow: 4px 4px 0 #FFD700, -2px -2px 0 #fff;
        z-index: 100;
        letter-spacing: 4px;
        pointer-events: none;
        animation: titlePulse 2s ease-in-out infinite;
    }
    @keyframes titlePulse {
        0%, 100% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
    }
    .story-text {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-size: 1.5rem;
        text-shadow: 2px 2px 4px #000;
        z-index: 100;
        text-align: center;
        background: rgba(0,0,0,0.7);
        padding: 20px 40px;
        border-radius: 15px;
        max-width: 80%;
        transition: opacity 0.5s;
    }
    .controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-size: 0.9rem;
        z-index: 100;
        text-align: center;
        background: rgba(0,0,0,0.5);
        padding: 10px 20px;
        border-radius: 10px;
    }
    .heart {
        position: fixed;
        font-size: 3rem;
        z-index: 50;
        animation: floatHeart 3s ease-in-out infinite;
        pointer-events: none;
        opacity: 0;
    }
    @keyframes floatHeart {
        0%, 100% { transform: translateY(0) scale(1); }
        50% { transform: translateY(-20px) scale(1.2); }
    }
</style>
</head>
<body>
<div id="canvas-container"></div>
<h1 class="title">MARIO'S RESCUE</h1>
<div class="story-text" id="storyText">Once upon a time in the Mushroom Kingdom...</div>
<p class="controls">Watch the story unfold! | Press SPACE to skip</p>
<div class="heart" id="heart1" style="top: 30%; left: 45%;">‚ù§Ô∏è</div>
<div class="heart" id="heart2" style="top: 25%; left: 55%;">üíï</div>
<div class="heart" id="heart3" style="top: 35%; left: 50%;">üíñ</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 50);
    camera.lookAt(0, 5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xFFD700, 1);
    sunLight.position.set(10, 30, 10);
    sunLight.castShadow = true;
    scene.add(sunLight);

    // Materials
    const redMat = new THREE.MeshLambertMaterial({ color: 0xE52521 });
    const blueMat = new THREE.MeshLambertMaterial({ color: 0x2B5DF5 });
    const skinMat = new THREE.MeshLambertMaterial({ color: 0xFEBB9E });
    const brownMat = new THREE.MeshLambertMaterial({ color: 0x6B3E08 });
    const yellowMat = new THREE.MeshLambertMaterial({ color: 0xFBD000 });
    const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
    const pinkMat = new THREE.MeshLambertMaterial({ color: 0xFFB6C1 });
    const pinkDarkMat = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });
    const greenMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const orangeMat = new THREE.MeshLambertMaterial({ color: 0xFF8C00 });
    const blackMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
    const grassMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x666666 });

    const voxelSize = 0.8;

    function addVoxel(group, x, y, z, material) {
        const geom = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        const voxel = new THREE.Mesh(geom, material);
        voxel.position.set(x * voxelSize, y * voxelSize, z * voxelSize);
        voxel.castShadow = true;
        group.add(voxel);
    }

    // Create Mario
    function createMario() {
        const marioGroup = new THREE.Group();
        
        // Hat
        for (let x = -2; x <= 2; x++) {
            for (let z = -1; z <= 1; z++) {
                addVoxel(marioGroup, x, 12, z, redMat);
            }
        }
        for (let x = -3; x <= 3; x++) {
            addVoxel(marioGroup, x, 11, 0, redMat);
        }
        for (let x = -3; x <= 3; x++) {
            addVoxel(marioGroup, x, 10, 2, redMat);
        }
        
        // Face
        for (let x = -2; x <= 2; x++) {
            for (let y = 7; y <= 10; y++) {
                addVoxel(marioGroup, x, y, 1, skinMat);
            }
        }
        
        // Eyes
        addVoxel(marioGroup, -1, 9, 2, whiteMat);
        addVoxel(marioGroup, 1, 9, 2, whiteMat);
        
        // Mustache
        for (let x = -2; x <= 2; x++) {
            addVoxel(marioGroup, x, 8, 2, brownMat);
        }
        
        // Body - red shirt
        for (let x = -2; x <= 2; x++) {
            for (let y = 4; y <= 6; y++) {
                addVoxel(marioGroup, x, y, 0, redMat);
            }
        }
        
        // Overalls
        for (let x = -2; x <= 2; x++) {
            for (let y = 0; y <= 3; y++) {
                addVoxel(marioGroup, x, y, 0, blueMat);
            }
        }
        
        // Arms
        for (let y = 3; y <= 6; y++) {
            addVoxel(marioGroup, -3, y, 0, redMat);
            addVoxel(marioGroup, 3, y, 0, redMat);
        }
        addVoxel(marioGroup, -4, 3, 0, whiteMat);
        addVoxel(marioGroup, 4, 3, 0, whiteMat);
        
        // Shoes
        addVoxel(marioGroup, -1, -1, 0, brownMat);
        addVoxel(marioGroup, -2, -1, 0, brownMat);
        addVoxel(marioGroup, 1, -1, 0, brownMat);
        addVoxel(marioGroup, 2, -1, 0, brownMat);
        
        return marioGroup;
    }

    // Create Princess Peach
    function createPeach() {
        const peachGroup = new THREE.Group();
        
        // Crown
        addVoxel(peachGroup, 0, 14, 0, yellowMat);
        addVoxel(peachGroup, -1, 13, 0, yellowMat);
        addVoxel(peachGroup, 0, 13, 0, yellowMat);
        addVoxel(peachGroup, 1, 13, 0, yellowMat);
        
        // Hair (blonde)
        for (let x = -2; x <= 2; x++) {
            for (let y = 9; y <= 12; y++) {
                addVoxel(peachGroup, x, y, 0, yellowMat);
            }
        }
        for (let y = 5; y <= 10; y++) {
            addVoxel(peachGroup, -3, y, 0, yellowMat);
            addVoxel(peachGroup, 3, y, 0, yellowMat);
        }
        
        // Face
        for (let x = -1; x <= 1; x++) {
            for (let y = 8; y <= 11; y++) {
                addVoxel(peachGroup, x, y, 1, skinMat);
            }
        }
        
        // Eyes
        addVoxel(peachGroup, -1, 10, 2, new THREE.MeshLambertMaterial({ color: 0x4169E1 }));
        addVoxel(peachGroup, 1, 10, 2, new THREE.MeshLambertMaterial({ color: 0x4169E1 }));
        
        // Lips
        addVoxel(peachGroup, 0, 8, 2, pinkDarkMat);
        
        // Dress (pink)
        for (let x = -3; x <= 3; x++) {
            for (let y = 0; y <= 7; y++) {
                const radius = Math.abs(y - 7) * 0.5 + 2;
                if (Math.abs(x) <= radius) {
                    addVoxel(peachGroup, x, y, 0, pinkMat);
                }
            }
        }
        
        // Dress details
        addVoxel(peachGroup, 0, 6, 1, new THREE.MeshLambertMaterial({ color: 0x0000FF }));
        
        return peachGroup;
    }

    // Create Bowser
    function createBowser() {
        const bowserGroup = new THREE.Group();
        
        // Horns
        addVoxel(bowserGroup, -3, 14, 0, whiteMat);
        addVoxel(bowserGroup, -3, 15, 0, whiteMat);
        addVoxel(bowserGroup, 3, 14, 0, whiteMat);
        addVoxel(bowserGroup, 3, 15, 0, whiteMat);
        
        // Head (green)
        for (let x = -2; x <= 2; x++) {
            for (let y = 10; y <= 13; y++) {
                addVoxel(bowserGroup, x, y, 0, greenMat);
            }
        }
        
        // Face/snout (orange)
        for (let x = -1; x <= 1; x++) {
            for (let y = 10; y <= 12; y++) {
                addVoxel(bowserGroup, x, y, 1, orangeMat);
            }
        }
        addVoxel(bowserGroup, 0, 10, 2, orangeMat);
        
        // Eyes (red angry)
        addVoxel(bowserGroup, -1, 12, 2, redMat);
        addVoxel(bowserGroup, 1, 12, 2, redMat);
        
        // Eyebrows
        addVoxel(bowserGroup, -2, 13, 1, blackMat);
        addVoxel(bowserGroup, 2, 13, 1, blackMat);
        
        // Body (green with shell)
        for (let x = -3; x <= 3; x++) {
            for (let y = 3; y <= 9; y++) {
                addVoxel(bowserGroup, x, y, 0, greenMat);
            }
        }
        
        // Shell (brown with spikes)
        for (let x = -3; x <= 3; x++) {
            for (let y = 4; y <= 8; y++) {
                addVoxel(bowserGroup, x, y, -1, brownMat);
            }
        }
        // Spikes on shell
        addVoxel(bowserGroup, -2, 9, -1, whiteMat);
        addVoxel(bowserGroup, 0, 9, -1, whiteMat);
        addVoxel(bowserGroup, 2, 9, -1, whiteMat);
        addVoxel(bowserGroup, -1, 10, -1, whiteMat);
        addVoxel(bowserGroup, 1, 10, -1, whiteMat);
        
        // Belly (yellow)
        for (let x = -2; x <= 2; x++) {
            for (let y = 4; y <= 7; y++) {
                addVoxel(bowserGroup, x, y, 1, yellowMat);
            }
        }
        
        // Arms
        for (let y = 5; y <= 8; y++) {
            addVoxel(bowserGroup, -4, y, 0, greenMat);
            addVoxel(bowserGroup, 4, y, 0, greenMat);
        }
        addVoxel(bowserGroup, -5, 5, 0, whiteMat);
        addVoxel(bowserGroup, 5, 5, 0, whiteMat);
        
        // Legs
        for (let y = 0; y <= 2; y++) {
            addVoxel(bowserGroup, -2, y, 0, greenMat);
            addVoxel(bowserGroup, 2, y, 0, greenMat);
        }
        
        return bowserGroup;
    }

    // Create ground
    const groundGeom = new THREE.BoxGeometry(100, 2, 100);
    const ground = new THREE.Mesh(groundGeom, grassMat);
    ground.position.y = -2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Create castle
    function createCastle(x, z, color) {
        const castleGroup = new THREE.Group();
        const mat = new THREE.MeshLambertMaterial({ color: color });
        
        // Main tower
        const tower = new THREE.Mesh(new THREE.BoxGeometry(10, 20, 10), mat);
        tower.position.y = 10;
        castleGroup.add(tower);
        
        // Battlements
        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 || Math.abs(j) === 2) {
                    const battlement = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 2), mat);
                    battlement.position.set(i * 2, 22, j * 2);
                    castleGroup.add(battlement);
                }
            }
        }
        
        // Door
        const door = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 1), brownMat);
        door.position.set(0, 2.5, 5.5);
        castleGroup.add(door);
        
        castleGroup.position.set(x, 0, z);
        return castleGroup;
    }

    // Peach's castle (pink)
    const peachCastle = createCastle(-30, -20, 0xFFB6C1);
    scene.add(peachCastle);

    // Bowser's castle (dark)
    const bowserCastle = createCastle(30, -20, 0x444444);
    scene.add(bowserCastle);

    // Add lava around Bowser's castle
    const lavaGeom = new THREE.PlaneGeometry(20, 20);
    const lavaMat = new THREE.MeshBasicMaterial({ color: 0xFF4500 });
    const lava = new THREE.Mesh(lavaGeom, lavaMat);
    lava.rotation.x = -Math.PI / 2;
    lava.position.set(30, 0.1, -5);
    scene.add(lava);

    // Create characters
    const mario = createMario();
    mario.scale.set(0.4, 0.4, 0.4);
    mario.position.set(-30, 0, 0);
    scene.add(mario);

    const peach = createPeach();
    peach.scale.set(0.4, 0.4, 0.4);
    peach.position.set(30, 0, -15);
    scene.add(peach);

    const bowser = createBowser();
    bowser.scale.set(0.5, 0.5, 0.5);
    bowser.position.set(25, 0, -15);
    scene.add(bowser);

    // Sun
    const sun = new THREE.Mesh(
        new THREE.SphereGeometry(5, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xFFD700 })
    );
    sun.position.set(40, 50, -50);
    scene.add(sun);

    // Clouds
    function createCloud(x, y, z) {
        const cloudGroup = new THREE.Group();
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
        for (let i = 0; i < 5; i++) {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(2 + Math.random() * 2, 16, 16), cloudMat);
            sphere.position.set(i * 3 - 6, Math.random() * 2, Math.random() * 2);
            cloudGroup.add(sphere);
        }
        cloudGroup.position.set(x, y, z);
        return cloudGroup;
    }
    scene.add(createCloud(-20, 30, -30));
    scene.add(createCloud(20, 35, -40));
    scene.add(createCloud(0, 28, -20));

    // Story phases
    const storyPhases = [
        { text: "Once upon a time in the Mushroom Kingdom...", duration: 3000 },
        { text: "Princess Peach was captured by the evil Bowser!", duration: 3000 },
        { text: "Mario heard about this and rushed to save her!", duration: 3000 },
        { text: "He ran as fast as he could towards Bowser's castle...", duration: 4000 },
        { text: "Mario confronted the mighty Bowser!", duration: 3000 },
        { text: "'Let her go, Bowser!' shouted Mario", duration: 3000 },
        { text: "An epic battle began!", duration: 3000 },
        { text: "Mario jumped and defeated Bowser with a mighty stomp!", duration: 4000 },
        { text: "Bowser was defeated and fled!", duration: 3000 },
        { text: "'My hero!' said Princess Peach", duration: 3000 },
        { text: "And they lived happily ever after! ‚ù§Ô∏è", duration: 5000 }
    ];

    let currentPhase = 0;
    let phaseStartTime = Date.now();
    let animationTime = 0;

    function updateStory() {
        const storyText = document.getElementById('storyText');
        const elapsed = Date.now() - phaseStartTime;
        
        if (elapsed > storyPhases[currentPhase].duration) {
            currentPhase++;
            phaseStartTime = Date.now();
            if (currentPhase >= storyPhases.length) {
                currentPhase = 0; // Loop the story
                mario.position.set(-30, 0, 0);
                bowser.position.set(25, 0, -15);
                bowser.visible = true;
            }
        }
        
        storyText.textContent = storyPhases[currentPhase].text;
    }

    function animateCharacters() {
        animationTime += 0.016;
        
        // Phase-based animations
        switch(currentPhase) {
            case 0: // Introduction
                camera.position.set(0, 40, 50);
                camera.lookAt(0, 5, 0);
                break;
            case 1: // Peach captured
                camera.position.set(30, 20, 10);
                camera.lookAt(30, 5, -15);
                peach.position.y = Math.sin(animationTime * 3) * 0.5;
                break;
            case 2: // Mario hears
                camera.position.set(-30, 15, 15);
                camera.lookAt(-30, 5, 0);
                mario.rotation.y = Math.sin(animationTime * 5) * 0.3;
                break;
            case 3: // Mario running
                camera.position.set(mario.position.x, 20, mario.position.z + 20);
                camera.lookAt(mario.position);
                mario.position.x += 0.3;
                mario.position.y = Math.abs(Math.sin(animationTime * 10)) * 2;
                mario.rotation.y = 0;
                break;
            case 4: // Confrontation
                camera.position.set(20, 15, 10);
                camera.lookAt(25, 5, -10);
                mario.position.set(15, 0, -10);
                mario.lookAt(bowser.position);
                bowser.lookAt(mario.position);
                break;
            case 5: // Mario speaks
                mario.position.y = Math.sin(animationTime * 5) * 0.5;
                break;
            case 6: // Battle
                camera.position.set(20, 25, 15);
                camera.lookAt(20, 5, -12);
                mario.position.x = 15 + Math.sin(animationTime * 3) * 5;
                mario.position.y = Math.abs(Math.sin(animationTime * 8)) * 3;
                bowser.position.x = 25 + Math.cos(animationTime * 2) * 2;
                bowser.rotation.y = animationTime * 2;
                break;
            case 7: // Mario stomps
                mario.position.set(25, 8 - (animationTime % 1) * 8, -15);
                if (mario.position.y < 0) mario.position.y = 0;
                break;
            case 8: // Bowser flees
                bowser.position.x += 0.5;
                bowser.position.z -= 0.3;
                bowser.rotation.y += 0.1;
                if (bowser.position.x > 60) bowser.visible = false;
                camera.position.set(35, 15, 0);
                camera.lookAt(bowser.position);
                break;
            case 9: // Peach thanks
                camera.position.set(30, 12, 5);
                camera.lookAt(28, 5, -12);
                mario.position.set(25, 0, -12);
                peach.position.set(30, 0, -12);
                mario.lookAt(peach.position);
                peach.lookAt(mario.position);
                break;
            case 10: // Happy ending
                camera.position.set(27, 15, 10);
                camera.lookAt(27, 5, -12);
                mario.position.y = Math.sin(animationTime * 2) * 0.3;
                peach.position.y = Math.sin(animationTime * 2 + 1) * 0.3;
                // Show hearts
                document.querySelectorAll('.heart').forEach((h, i) => {
                    h.style.opacity = '1';
                    h.style.top = (25 + Math.sin(animationTime + i) * 5) + '%';
                });
                break;
            default:
                document.querySelectorAll('.heart').forEach(h => h.style.opacity = '0');
        }
        
        // Character idle animations
        mario.children.forEach((v, i) => {
            if (v.material === redMat) {
                v.position.y += Math.sin(animationTime * 5 + i * 0.1) * 0.002;
            }
        });
    }

    // Skip with space
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            currentPhase++;
            phaseStartTime = Date.now();
            if (currentPhase >= storyPhases.length) {
                currentPhase = 0;
                mario.position.set(-30, 0, 0);
                bowser.position.set(25, 0, -15);
                bowser.visible = true;
            }
        }
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        
        updateStory();
        animateCharacters();
        
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>