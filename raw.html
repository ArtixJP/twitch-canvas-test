<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>üõ°Ô∏è SAFE MODE - SYSTEM RECOVERY üõ°Ô∏è</title>
<style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
        min-height: 100vh;
        background: #0a1628;
        font-family: 'Courier New', monospace;
        color: #4facfe;
        overflow: hidden;
    }
    
    @keyframes glitch {
        0% { transform: translate(0); filter: hue-rotate(0deg); }
        20% { transform: translate(-3px, 3px); filter: hue-rotate(90deg); }
        40% { transform: translate(3px, -3px); filter: hue-rotate(180deg); }
        60% { transform: translate(-3px, -3px); filter: hue-rotate(270deg); }
        80% { transform: translate(3px, 3px); filter: hue-rotate(360deg); }
        100% { transform: translate(0); filter: hue-rotate(0deg); }
    }
    
    @keyframes scanline {
        0% { background-position: 0 0; }
        100% { background-position: 0 100vh; }
    }
    
    body::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            0deg,
            rgba(79, 172, 254, 0.02) 0px,
            rgba(79, 172, 254, 0.02) 1px,
            transparent 1px,
            transparent 2px
        );
        pointer-events: none;
        z-index: 9999;
        animation: scanline 8s linear infinite;
    }
    
    #gameContainer {
        width: 100vw;
        height: 100vh;
        position: relative;
    }
    
    #instructions {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        max-width: 250px;
    }
    
    #instructions h3 {
        color: #4facfe;
        margin-bottom: 10px;
    }
    
    #instructions p {
        margin: 5px 0;
        color: #ccc;
    }
    
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        pointer-events: none;
        z-index: 100;
    }
    
    #crosshair::before, #crosshair::after {
        content: '';
        position: absolute;
        background: white;
        box-shadow: 0 0 3px black;
    }
    
    #crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
    }
    
    #crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
    }
    
    .stats {
        position: fixed;
        bottom: 10px;
        left: 10px;
        display: flex;
        gap: 1rem;
        z-index: 100;
    }
    
    .stat {
        background: rgba(0,0,0,0.7);
        padding: 10px 15px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.2);
    }
    
    .stat-value {
        font-size: 1.2rem;
        color: #4facfe;
        font-weight: bold;
    }
    
    .stat-label {
        font-size: 0.7rem;
        color: #888;
    }
    
    #blockSelector {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 5px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 10px;
        z-index: 100;
    }
    
    .block-option {
        width: 40px;
        height: 40px;
        border: 2px solid #555;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .block-option.selected {
        border-color: #fff;
        transform: scale(1.1);
    }
    
    .block-option:hover {
        border-color: #aaa;
    }
</style>
</head>
<body>
<div id="gameContainer"></div>
<div id="crosshair"></div>
<div id="instructions">
<h3 style="color: #4facfe;">üõ°Ô∏è SAFE MODE ACTIVE üõ°Ô∏è</h3>
<p style="color: #00ff88;">‚úì SYSTEM STABILIZED</p>
<p>INTEGRITY: 98%</p>
<p>All threats contained...</p>
<p style="color: #4facfe;">ENVIRONMENT: PEACEFUL</p>
<p style="color: #ff69b4;">üåà RAINBOW ACTIVE</p>
<p>Click to explore safely</p>
<p style="font-size: 10px; color: #666;">v1.0.0 - RECOVERY MODE</p>
<p style="color: #FF69B4; margin-top: 8px;">üì£ HI MOM! HI GRANDMA!</p>
<p style="color: #00FF00;">üçÑ MARIO BROS ACTIVE!</p>
<p style="color: #FFA500;">üçï PIZZA SPAWNED!</p>
<p style="color: #9400D3;">üåÄ WOW PORTAL OPEN!</p>
<p style="color: #FFD700;">üëã HELLO MO!</p>
</div>
<div class="stats">
<div class="stat">
<div class="stat-value" id="clicks">0</div>
<div class="stat-label">Blocks Placed</div>
</div>
<div class="stat">
<div class="stat-value" id="shapes">0</div>
<div class="stat-label">Blocks Broken</div>
</div>
</div>
<div id="blockSelector">
<div class="block-option selected" data-block="0" style="background: #8B4513;"></div>
<div class="block-option" data-block="1" style="background: #228B22;"></div>
<div class="block-option" data-block="2" style="background: #808080;"></div>
<div class="block-option" data-block="3" style="background: #FFD700;"></div>
<div class="block-option" data-block="4" style="background: #4169E1;"></div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Stats
    let blocksPlaced = 0;
    
    // Pokemon storage
    const pokemons = [];
    const pokemonTypes = [
        { name: 'Pikachu', color: 0xFFD700, size: 1.5, speed: 3 },
        { name: 'Bulbasaur', color: 0x228B22, size: 1.8, speed: 2 },
        { name: 'Charmander', color: 0xFF4500, size: 1.6, speed: 2.5 },
        { name: 'Squirtle', color: 0x1E90FF, size: 1.5, speed: 2 },
        { name: 'Eevee', color: 0xD2691E, size: 1.4, speed: 3.5 },
        { name: 'Jigglypuff', color: 0xFFB6C1, size: 1.3, speed: 1.5 },
        { name: 'Mario', color: 0xFF0000, size: 2.0, speed: 4, isMario: true },
        { name: 'Luigi', color: 0x00FF00, size: 2.1, speed: 3.8, isLuigi: true },
        { name: 'Toad', color: 0xFFFFFF, size: 1.2, speed: 5, isToad: true }
    ];
    let blocksBroken = 0;
    const clicksEl = document.getElementById('clicks');
    const shapesEl = document.getElementById('shapes');
    
    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x808080); // Gray sky as requested!
    scene.fog = new THREE.Fog(0x808080, 40, 120); // Gray fog to match
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 20);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('gameContainer').appendChild(renderer.domElement);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x4facfe, 0.4); // Calm blue glow
    scene.add(ambientLight);
    
    const sunLight = new THREE.DirectionalLight(0xffffff, 0.8); // Peaceful white sun
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    scene.add(sunLight);
    
    // Block types
    const blockColors = [0x8B4513, 0x228B22, 0x808080, 0xFFD700, 0x4169E1];
    let selectedBlock = 0;
    
    // World blocks storage
    const blocks = new Map();
    const blockSize = 2;
    
    function getBlockKey(x, y, z) {
        return `${Math.floor(x/blockSize)},${Math.floor(y/blockSize)},${Math.floor(z/blockSize)}`;
    }
    
    function createBlock(x, y, z, colorIndex = 0) {
        const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const material = new THREE.MeshLambertMaterial({ 
            color: blockColors[colorIndex],
            flatShading: true
        });
        const block = new THREE.Mesh(geometry, material);
        block.position.set(
            Math.floor(x/blockSize) * blockSize + blockSize/2,
            Math.floor(y/blockSize) * blockSize + blockSize/2,
            Math.floor(z/blockSize) * blockSize + blockSize/2
        );
        block.castShadow = true;
        block.receiveShadow = true;
        return block;
    }
    
    // Generate terrain
    for (let x = -20; x < 20; x++) {
        for (let z = -20; z < 20; z++) {
            const height = Math.floor(Math.sin(x * 0.1) * 2 + Math.cos(z * 0.1) * 2);
            for (let y = -2; y <= height; y++) {
                const colorIndex = y === height ? 1 : (y < height - 2 ? 2 : 0);
                const block = createBlock(x * blockSize, y * blockSize, z * blockSize, colorIndex);
                scene.add(block);
                blocks.set(getBlockKey(x * blockSize, y * blockSize, z * blockSize), block);
            }
        }
    }
    
    // Create Pokemon
    function createPokemon(type, x, z) {
        const pokemon = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.SphereGeometry(type.size * 0.5, 8, 8);
        const bodyMat = new THREE.MeshLambertMaterial({ color: type.color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        pokemon.add(body);
        
        // Head
        const headGeo = new THREE.SphereGeometry(type.size * 0.35, 8, 8);
        const head = new THREE.Mesh(headGeo, bodyMat);
        head.position.y = type.size * 0.5;
        head.castShadow = true;
        pokemon.add(head);
        
        // Eyes
        const eyeGeo = new THREE.SphereGeometry(type.size * 0.1, 6, 6);
        const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
        leftEye.position.set(-type.size * 0.15, type.size * 0.55, type.size * 0.25);
        pokemon.add(leftEye);
        const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
        rightEye.position.set(type.size * 0.15, type.size * 0.55, type.size * 0.25);
        pokemon.add(rightEye);
        
        // Ears/features based on type
        if (type.name === 'Pikachu') {
            const earGeo = new THREE.ConeGeometry(type.size * 0.15, type.size * 0.5, 4);
            const earMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const leftEar = new THREE.Mesh(earGeo, earMat);
            leftEar.position.set(-type.size * 0.2, type.size * 0.9, 0);
            leftEar.rotation.z = 0.3;
            pokemon.add(leftEar);
            const rightEar = new THREE.Mesh(earGeo, earMat);
            rightEar.position.set(type.size * 0.2, type.size * 0.9, 0);
            rightEar.rotation.z = -0.3;
            pokemon.add(rightEar);
        }
        
        // Mario special features - REALISTIC MARIO!
        if (type.name === 'Mario') {
            // Remove default body/head
            pokemon.remove(body);
            pokemon.remove(head);
            
            const skinMat = new THREE.MeshLambertMaterial({ color: 0xFFDBB4 });
            const redMat = new THREE.MeshLambertMaterial({ color: 0xE52521 });
            const blueMat = new THREE.MeshLambertMaterial({ color: 0x1D4ED8 });
            const brownMat = new THREE.MeshLambertMaterial({ color: 0x4A3728 });
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const goldMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            
            // Blue overalls (torso)
            const torsoGeo = new THREE.BoxGeometry(type.size * 0.7, type.size * 0.6, type.size * 0.4);
            const torso = new THREE.Mesh(torsoGeo, blueMat);
            torso.position.y = type.size * 0.1;
            torso.castShadow = true;
            pokemon.add(torso);
            
            // Red shirt showing at top
            const shirtGeo = new THREE.BoxGeometry(type.size * 0.72, type.size * 0.2, type.size * 0.42);
            const shirt = new THREE.Mesh(shirtGeo, redMat);
            shirt.position.y = type.size * 0.45;
            pokemon.add(shirt);
            
            // Overalls straps
            const strapGeo = new THREE.BoxGeometry(type.size * 0.12, type.size * 0.35, type.size * 0.08);
            const leftStrap = new THREE.Mesh(strapGeo, blueMat);
            leftStrap.position.set(-type.size * 0.22, type.size * 0.45, type.size * 0.18);
            pokemon.add(leftStrap);
            const rightStrap = new THREE.Mesh(strapGeo, blueMat);
            rightStrap.position.set(type.size * 0.22, type.size * 0.45, type.size * 0.18);
            pokemon.add(rightStrap);
            
            // Golden buttons on straps
            const buttonGeo = new THREE.SphereGeometry(type.size * 0.05, 8, 8);
            const leftButton = new THREE.Mesh(buttonGeo, goldMat);
            leftButton.position.set(-type.size * 0.22, type.size * 0.35, type.size * 0.23);
            pokemon.add(leftButton);
            const rightButton = new THREE.Mesh(buttonGeo, goldMat);
            rightButton.position.set(type.size * 0.22, type.size * 0.35, type.size * 0.23);
            pokemon.add(rightButton);
            
            // Head (skin)
            const headGeo = new THREE.SphereGeometry(type.size * 0.35, 12, 12);
            const marioHead = new THREE.Mesh(headGeo, skinMat);
            marioHead.position.y = type.size * 0.8;
            marioHead.castShadow = true;
            pokemon.add(marioHead);
            
            // Big nose
            const noseGeo = new THREE.SphereGeometry(type.size * 0.12, 8, 8);
            const nose = new THREE.Mesh(noseGeo, skinMat);
            nose.position.set(0, type.size * 0.75, type.size * 0.35);
            nose.scale.set(1, 0.8, 1.2);
            pokemon.add(nose);
            
            // Mustache - curved shape
            const mustacheGeo = new THREE.TorusGeometry(type.size * 0.15, type.size * 0.04, 8, 16, Math.PI);
            const mustacheLeft = new THREE.Mesh(mustacheGeo, brownMat);
            mustacheLeft.position.set(-type.size * 0.08, type.size * 0.65, type.size * 0.32);
            mustacheLeft.rotation.set(0, 0.3, Math.PI);
            pokemon.add(mustacheLeft);
            const mustacheRight = new THREE.Mesh(mustacheGeo, brownMat);
            mustacheRight.position.set(type.size * 0.08, type.size * 0.65, type.size * 0.32);
            mustacheRight.rotation.set(0, -0.3, Math.PI);
            pokemon.add(mustacheRight);
            
            // Eyes (white with black pupils)
            const eyeWhiteGeo = new THREE.SphereGeometry(type.size * 0.08, 8, 8);
            const leftEyeW = new THREE.Mesh(eyeWhiteGeo, whiteMat);
            leftEyeW.position.set(-type.size * 0.12, type.size * 0.85, type.size * 0.28);
            pokemon.add(leftEyeW);
            const rightEyeW = new THREE.Mesh(eyeWhiteGeo, whiteMat);
            rightEyeW.position.set(type.size * 0.12, type.size * 0.85, type.size * 0.28);
            pokemon.add(rightEyeW);
            
            const pupilGeo = new THREE.SphereGeometry(type.size * 0.04, 8, 8);
            const pupilMat = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-type.size * 0.12, type.size * 0.85, type.size * 0.35);
            pokemon.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(type.size * 0.12, type.size * 0.85, type.size * 0.35);
            pokemon.add(rightPupil);
            
            // Red cap
            const capGeo = new THREE.SphereGeometry(type.size * 0.38, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const cap = new THREE.Mesh(capGeo, redMat);
            cap.position.y = type.size * 1.0;
            cap.castShadow = true;
            pokemon.add(cap);
            
            // Cap brim
            const brimGeo = new THREE.CylinderGeometry(type.size * 0.25, type.size * 0.3, type.size * 0.08, 12);
            const brim = new THREE.Mesh(brimGeo, redMat);
            brim.position.set(0, type.size * 0.9, type.size * 0.25);
            brim.rotation.x = Math.PI / 2.5;
            pokemon.add(brim);
            
            // M logo on cap (white circle with M)
            const logoGeo = new THREE.CircleGeometry(type.size * 0.12, 16);
            const logo = new THREE.Mesh(logoGeo, whiteMat);
            logo.position.set(0, type.size * 1.05, type.size * 0.35);
            logo.rotation.x = -0.3;
            pokemon.add(logo);
            
            // Arms (red sleeves)
            const armGeo = new THREE.CylinderGeometry(type.size * 0.1, type.size * 0.12, type.size * 0.4, 8);
            const leftArm = new THREE.Mesh(armGeo, redMat);
            leftArm.position.set(-type.size * 0.45, type.size * 0.3, 0);
            leftArm.rotation.z = Math.PI / 4;
            pokemon.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, redMat);
            rightArm.position.set(type.size * 0.45, type.size * 0.3, 0);
            rightArm.rotation.z = -Math.PI / 4;
            pokemon.add(rightArm);
            
            // Hands (white gloves)
            const handGeo = new THREE.SphereGeometry(type.size * 0.12, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, whiteMat);
            leftHand.position.set(-type.size * 0.6, type.size * 0.15, 0);
            pokemon.add(leftHand);
            const rightHand = new THREE.Mesh(handGeo, whiteMat);
            rightHand.position.set(type.size * 0.6, type.size * 0.15, 0);
            pokemon.add(rightHand);
            
            // Legs (blue overalls)
            const legGeo = new THREE.CylinderGeometry(type.size * 0.12, type.size * 0.14, type.size * 0.35, 8);
            const leftLeg = new THREE.Mesh(legGeo, blueMat);
            leftLeg.position.set(-type.size * 0.18, -type.size * 0.25, 0);
            pokemon.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, blueMat);
            rightLeg.position.set(type.size * 0.18, -type.size * 0.25, 0);
            pokemon.add(rightLeg);
            
            // Brown shoes
            const shoeGeo = new THREE.BoxGeometry(type.size * 0.18, type.size * 0.12, type.size * 0.25);
            const leftShoe = new THREE.Mesh(shoeGeo, brownMat);
            leftShoe.position.set(-type.size * 0.18, -type.size * 0.45, type.size * 0.05);
            pokemon.add(leftShoe);
            const rightShoe = new THREE.Mesh(shoeGeo, brownMat);
            rightShoe.position.set(type.size * 0.18, -type.size * 0.45, type.size * 0.05);
            pokemon.add(rightShoe);
        }
        
        pokemon.position.set(x, 5, z);
        pokemon.userData = {
            type: type,
            targetX: x,
            targetZ: z,
            moveTimer: Math.random() * 3
        };
        
        scene.add(pokemon);
        pokemons.push(pokemon);
        return pokemon;
    }
    
    // Build Mario Tower!
    function buildMarioTower() {
        const towerX = 10;
        const towerZ = 10;
        // Tower base (red blocks)
        for (let y = 0; y < 8; y++) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const block = createBlock((towerX + dx) * blockSize, y * blockSize, (towerZ + dz) * blockSize, 0);
                    block.material.color.setHex(0xE52521); // Mario red
                    scene.add(block);
                    blocks.set(getBlockKey((towerX + dx) * blockSize, y * blockSize, (towerZ + dz) * blockSize), block);
                }
            }
        }
        // Blue accent (overalls)
        for (let y = 8; y < 12; y++) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const block = createBlock((towerX + dx) * blockSize, y * blockSize, (towerZ + dz) * blockSize, 4);
                    scene.add(block);
                    blocks.set(getBlockKey((towerX + dx) * blockSize, y * blockSize, (towerZ + dz) * blockSize), block);
                }
            }
        }
        // Gold top (coin/star)
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                const block = createBlock((towerX + dx) * blockSize, 12 * blockSize, (towerZ + dz) * blockSize, 3);
                scene.add(block);
                blocks.set(getBlockKey((towerX + dx) * blockSize, 12 * blockSize, (towerZ + dz) * blockSize), block);
            }
        }
    }
    buildMarioTower();
    
    // Create Rainbow in the sky
    function createRainbow() {
        const rainbowGroup = new THREE.Group();
        const rainbowColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
        
        for (let i = 0; i < 7; i++) {
            const curve = new THREE.EllipseCurve(
                0, 0,
                50 + i * 3, 35 + i * 2,
                0, Math.PI,
                false,
                0
            );
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: rainbowColors[i],
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            const arc = new THREE.Line(geometry, material);
            arc.rotation.x = -Math.PI / 2;
            rainbowGroup.add(arc);
        }
        
        // Add glowing tubes for more visible rainbow
        for (let i = 0; i < 7; i++) {
            const curve = new THREE.EllipseCurve(
                0, 0,
                50 + i * 3, 35 + i * 2,
                0, Math.PI,
                false,
                0
            );
            const points = curve.getPoints(50);
            const path = new THREE.CatmullRomCurve3(
                points.map(p => new THREE.Vector3(p.x, 0, p.y))
            );
            const tubeGeo = new THREE.TubeGeometry(path, 50, 0.8, 8, false);
            const tubeMat = new THREE.MeshBasicMaterial({
                color: rainbowColors[i],
                transparent: true,
                opacity: 0.5
            });
            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            rainbowGroup.add(tube);
        }
        
        rainbowGroup.position.set(-20, 25, -60);
        rainbowGroup.rotation.y = Math.PI / 6;
        scene.add(rainbowGroup);
        return rainbowGroup;
    }
    const rainbow = createRainbow();
    
    // Create Thank You Mario panel
    function createThankYouPanel() {
        const panelGroup = new THREE.Group();
        
        // Panel background
        const panelGeo = new THREE.BoxGeometry(8, 4, 0.3);
        const panelMat = new THREE.MeshLambertMaterial({ color: 0xE52521 });
        const panel = new THREE.Mesh(panelGeo, panelMat);
        panelGroup.add(panel);
        
        // Gold border
        const borderGeo = new THREE.BoxGeometry(8.5, 4.5, 0.2);
        const borderMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = -0.1;
        panelGroup.add(border);
        
        // Create text using canvas texture
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#E52521';
        ctx.fillRect(0, 0, 512, 256);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('THANK YOU MARIO!', 256, 100);
        ctx.font = '24px Arial';
        ctx.fillText('For your great work! üçÑ‚≠ê', 256, 160);
        ctx.fillText('- The Community', 256, 200);
        
        const texture = new THREE.CanvasTexture(canvas);
        const textGeo = new THREE.PlaneGeometry(7.5, 3.75);
        const textMat = new THREE.MeshBasicMaterial({ map: texture });
        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.z = 0.2;
        panelGroup.add(textMesh);
        
        // Position above Mario tower
        panelGroup.position.set(10 * blockSize, 35, 10 * blockSize);
        
        scene.add(panelGroup);
        return panelGroup;
    }
    const thankYouPanel = createThankYouPanel();
    
    // Community Greeting Panels!
    function createGreetingPanel(text, x, y, z, color) {
        const panelGroup = new THREE.Group();
        
        const panelGeo = new THREE.BoxGeometry(6, 2.5, 0.2);
        const panelMat = new THREE.MeshLambertMaterial({ color: color });
        const panel = new THREE.Mesh(panelGeo, panelMat);
        panelGroup.add(panel);
        
        const canvas = document.createElement('canvas');
        canvas.width = 384;
        canvas.height = 160;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, 384, 160);
        ctx.fillStyle = '#333333';
        ctx.font = 'bold 28px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(text, 192, 90);
        ctx.font = '16px Arial';
        ctx.fillText('üíñ From Twitch Chat üíñ', 192, 130);
        
        const texture = new THREE.CanvasTexture(canvas);
        const textGeo = new THREE.PlaneGeometry(5.5, 2.2);
        const textMat = new THREE.MeshBasicMaterial({ map: texture });
        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.z = 0.15;
        panelGroup.add(textMesh);
        
        panelGroup.position.set(x, y, z);
        scene.add(panelGroup);
        return panelGroup;
    }
    
    const hiMomPanel = createGreetingPanel('HI MOM! üëãüè†', -15, 20, -20, 0xFF69B4);
    const hiGrandmaPanel = createGreetingPanel('HI GRANDMA! üëµüíï', 15, 22, -25, 0x9370DB);
    const helloMoPanel = createGreetingPanel('HELLO MO! üëã‚ú®', 0, 18, -30, 0xFFD700);
    
    // Create floating pizza!
    function createPizza() {
        const pizzaGroup = new THREE.Group();
        
        // Pizza base (cheese)
        const baseGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.3, 16);
        const baseMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
        const base = new THREE.Mesh(baseGeo, baseMat);
        pizzaGroup.add(base);
        
        // Crust ring
        const crustGeo = new THREE.TorusGeometry(2.3, 0.25, 8, 16);
        const crustMat = new THREE.MeshLambertMaterial({ color: 0xD2691E });
        const crust = new THREE.Mesh(crustGeo, crustMat);
        crust.rotation.x = Math.PI / 2;
        crust.position.y = 0.1;
        pizzaGroup.add(crust);
        
        // Pepperoni!
        const pepGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
        const pepMat = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
        for (let i = 0; i < 8; i++) {
            const pep = new THREE.Mesh(pepGeo, pepMat);
            const angle = (i / 8) * Math.PI * 2;
            pep.position.set(Math.cos(angle) * 1.3, 0.2, Math.sin(angle) * 1.3);
            pizzaGroup.add(pep);
        }
        
        pizzaGroup.position.set(-20, 15, 5);
        scene.add(pizzaGroup);
        return pizzaGroup;
    }
    const pizza = createPizza();
    
    // Create WoW Portal!
    function createWoWPortal() {
        const portalGroup = new THREE.Group();
        
        // Portal frame (dark stone)
        const frameGeo = new THREE.TorusGeometry(4, 0.8, 8, 32);
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x2F2F4F });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        portalGroup.add(frame);
        
        // Swirling portal energy
        const portalGeo = new THREE.CircleGeometry(3.5, 32);
        const portalMat = new THREE.MeshBasicMaterial({ 
            color: 0x9400D3, 
            transparent: true, 
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const portal = new THREE.Mesh(portalGeo, portalMat);
        portal.name = 'portalEnergy';
        portalGroup.add(portal);
        
        // Inner glow rings
        for (let i = 0; i < 3; i++) {
            const ringGeo = new THREE.TorusGeometry(2.5 - i * 0.7, 0.15, 8, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: i % 2 === 0 ? 0x00FFFF : 0xFF00FF,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.name = 'portalRing' + i;
            portalGroup.add(ring);
        }
        
        // Runes around frame
        const runeGeo = new THREE.BoxGeometry(0.5, 0.8, 0.2);
        const runeMat = new THREE.MeshBasicMaterial({ color: 0x00FF00 });
        for (let i = 0; i < 8; i++) {
            const rune = new THREE.Mesh(runeGeo, runeMat);
            const angle = (i / 8) * Math.PI * 2;
            rune.position.set(Math.cos(angle) * 4.5, Math.sin(angle) * 4.5, 0.5);
            rune.rotation.z = angle;
            portalGroup.add(rune);
        }
        
        portalGroup.position.set(25, 8, -10);
        portalGroup.rotation.y = -0.5;
        scene.add(portalGroup);
        return portalGroup;
    }
    const wowPortal = createWoWPortal();
    
    // Spawn initial Pokemon
    // Spawn extra Mario Bros characters!
    createPokemon(pokemonTypes.find(p => p.name === 'Mario'), 5, 5);
    createPokemon(pokemonTypes.find(p => p.name === 'Luigi'), -5, 5);
    createPokemon(pokemonTypes.find(p => p.name === 'Toad'), 0, 8);
    
    for (let i = 0; i < 15; i++) {
        const type = pokemonTypes[Math.floor(Math.random() * pokemonTypes.length)];
        const x = (Math.random() - 0.5) * 60;
        const z = (Math.random() - 0.5) * 60;
        createPokemon(type, x, z);
    }
    
    // Player controls
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = true;
    let isLocked = false;
    
    // Euler for camera rotation
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    
    // Pointer lock
    renderer.domElement.addEventListener('click', () => {
        if (!isLocked) {
            renderer.domElement.requestPointerLock();
        }
    });
    
    document.addEventListener('pointerlockchange', () => {
        isLocked = document.pointerLockElement === renderer.domElement;
    });
    
    // Mouse movement
    document.addEventListener('mousemove', (e) => {
        if (!isLocked) return;
        
        euler.setFromQuaternion(camera.quaternion);
        euler.y -= e.movementX * 0.002;
        euler.x -= e.movementY * 0.002;
        euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
        camera.quaternion.setFromEuler(euler);
    });
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
            case 'Space':
                if (canJump) {
                    velocity.y = 15;
                    canJump = false;
                }
                break;
            case 'KeyM': placeBlock(); break;
            case 'Digit1': selectBlock(0); break;
            case 'Digit2': selectBlock(1); break;
            case 'Digit3': selectBlock(2); break;
            case 'Digit4': selectBlock(3); break;
            case 'Digit5': selectBlock(4); break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
    });
    
    // Block selection UI
    document.querySelectorAll('.block-option').forEach(el => {
        el.addEventListener('click', () => {
            selectBlock(parseInt(el.dataset.block));
        });
    });
    
    function selectBlock(index) {
        selectedBlock = index;
        document.querySelectorAll('.block-option').forEach((el, i) => {
            el.classList.toggle('selected', i === index);
        });
    }
    
    // Raycaster for block interaction
    const raycaster = new THREE.Raycaster();
    raycaster.far = 20;
    
    function placeBlock() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children);
        
        if (intersects.length > 0) {
            const hit = intersects[0];
            const normal = hit.face.normal;
            const pos = hit.point.clone().add(normal.multiplyScalar(blockSize/2));
            
            const key = getBlockKey(pos.x, pos.y, pos.z);
            if (!blocks.has(key)) {
                const block = createBlock(pos.x, pos.y, pos.z, selectedBlock);
                scene.add(block);
                blocks.set(key, block);
                blocksPlaced++;
                clicksEl.textContent = blocksPlaced;
            }
        }
    }
    
    // Left click to break
    document.addEventListener('mousedown', (e) => {
        if (!isLocked || e.button !== 0) return;
        
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(scene.children);
        
        if (intersects.length > 0) {
            const block = intersects[0].object;
            const key = getBlockKey(block.position.x, block.position.y, block.position.z);
            if (blocks.has(key)) {
                scene.remove(block);
                blocks.delete(key);
                blocksBroken++;
                shapesEl.textContent = blocksBroken;
            }
        }
    });
    
    // Animation loop
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        
        // Movement
        velocity.x *= 0.9;
        velocity.z *= 0.9;
        velocity.y -= 30 * delta; // Gravity
        
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();
        
        if (moveForward || moveBackward) velocity.z -= direction.z * 50 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 50 * delta;
        
        // Apply movement in camera direction
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        
        camera.position.addScaledVector(forward, -velocity.z * delta);
        camera.position.addScaledVector(right, -velocity.x * delta);
        camera.position.y += velocity.y * delta;
        
        // Ground collision
        if (camera.position.y < 5) {
            camera.position.y = 5;
            velocity.y = 0;
            canJump = true;
        }
        
        // Update Pokemon
        pokemons.forEach(pokemon => {
            const data = pokemon.userData;
            data.moveTimer -= delta;
            
            if (data.moveTimer <= 0) {
                data.targetX = pokemon.position.x + (Math.random() - 0.5) * 20;
                data.targetZ = pokemon.position.z + (Math.random() - 0.5) * 20;
                data.targetX = Math.max(-35, Math.min(35, data.targetX));
                data.targetZ = Math.max(-35, Math.min(35, data.targetZ));
                data.moveTimer = 2 + Math.random() * 3;
            }
            
            const dx = data.targetX - pokemon.position.x;
            const dz = data.targetZ - pokemon.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist > 0.5) {
                pokemon.position.x += (dx / dist) * data.type.speed * delta;
                pokemon.position.z += (dz / dist) * data.type.speed * delta;
                pokemon.rotation.y = Math.atan2(dx, dz);
            }
            
            // SAFE MODE - Pokemon are peaceful and stable
            pokemon.position.y = 5 + Math.sin(Date.now() * 0.002 + pokemon.id) * 0.3;
            pokemon.scale.x = 1;
            pokemon.visible = true; // Stable existence
            
            // Slight rotation animation
            pokemon.children[0].rotation.z = Math.sin(Date.now() * 0.003) * 0.1;
        });
        
        // Animate thank you panel
        if (thankYouPanel) {
            thankYouPanel.position.y = 35 + Math.sin(Date.now() * 0.002) * 0.5;
            thankYouPanel.rotation.y = Math.sin(Date.now() * 0.001) * 0.2;
        }
        
        // Animate greeting panels
        if (hiMomPanel) {
            hiMomPanel.position.y = 20 + Math.sin(Date.now() * 0.0015) * 0.8;
            hiMomPanel.rotation.y = Math.sin(Date.now() * 0.0008) * 0.3;
        }
        if (hiGrandmaPanel) {
            hiGrandmaPanel.position.y = 22 + Math.sin(Date.now() * 0.0018 + 1) * 0.6;
            hiGrandmaPanel.rotation.y = Math.sin(Date.now() * 0.001 + 2) * 0.25;
        }
        
        // Animate Hello Mo panel
        if (helloMoPanel) {
            helloMoPanel.position.y = 18 + Math.sin(Date.now() * 0.002 + 3) * 0.5;
            helloMoPanel.rotation.y = Math.sin(Date.now() * 0.0012) * 0.2;
        }
        
        // Animate floating pizza - spinning deliciously!
        if (pizza) {
            pizza.rotation.y += delta * 0.8;
            pizza.position.y = 15 + Math.sin(Date.now() * 0.003) * 2;
        }
        
        // Animate WoW portal - swirling energy!
        if (wowPortal) {
            wowPortal.children.forEach((child, i) => {
                if (child.name && child.name.includes('portalRing')) {
                    child.rotation.z += delta * (2 + i);
                }
                if (child.name === 'portalEnergy') {
                    child.rotation.z -= delta * 0.5;
                    child.material.opacity = 0.5 + Math.sin(Date.now() * 0.004) * 0.3;
                }
            });
        }
        
        // Animate rainbow with gentle shimmer
        if (rainbow) {
            rainbow.children.forEach((child, i) => {
                if (child.material) {
                    child.material.opacity = 0.4 + Math.sin(Date.now() * 0.001 + i * 0.5) * 0.2;
                }
            });
        }
        
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
</script>
</body>
</html>