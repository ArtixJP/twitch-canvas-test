<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://unpkg.com https://esm.sh https://esm.run https://cdn.tailwindcss.com https://threejs.org https://cdn.threejs.org https://cdn.p5js.org https://code.jquery.com https://d3js.org https://cdn.plot.ly https://cdn.tonejs.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; img-src 'self' data: https:; media-src 'self' https:; font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; worker-src 'self'; frame-src https://www.youtube.com https://www.youtube-nocookie.com https://player.vimeo.com; connect-src 'self' https: wss: ws:; object-src 'none'; base-uri 'self'; form-action 'self';">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>‚ôüÔ∏è Chess Game - Jeu d'√âchecs</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
        font-family: 'Segoe UI', system-ui, sans-serif; 
        min-height: 100vh; 
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
    }
    
    h1 {
        font-size: 2.5rem;
        margin-bottom: 20px;
        background: linear-gradient(90deg, #ffd700, #ff6b6b, #ffd700);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
    }
    
    .game-container {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: flex-start;
    }
    
    .board-container {
        background: linear-gradient(135deg, #2d2d44, #1a1a2e);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    
    .board {
        display: grid;
        grid-template-columns: repeat(8, 60px);
        grid-template-rows: repeat(8, 60px);
        border: 3px solid #ffd700;
        border-radius: 5px;
        overflow: hidden;
    }
    
    .square {
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        cursor: pointer;
        transition: all 0.2s;
        user-select: none;
    }
    
    .square.light { background: #f0d9b5; }
    .square.dark { background: #b58863; }
    .square.selected { background: #7fc97f !important; box-shadow: inset 0 0 10px rgba(0,255,0,0.5); }
    .square.valid-move { background: #aaffaa !important; }
    .square.valid-move::after {
        content: '';
        width: 20px;
        height: 20px;
        background: rgba(0,150,0,0.4);
        border-radius: 50%;
        position: absolute;
    }
    .square:hover { filter: brightness(1.1); }
    .square.last-move { box-shadow: inset 0 0 15px rgba(255,215,0,0.6); }
    .square.check { background: #ff6b6b !important; animation: pulse-check 1s infinite; }
    
    @keyframes pulse-check {
        0%, 100% { box-shadow: inset 0 0 20px rgba(255,0,0,0.8); }
        50% { box-shadow: inset 0 0 30px rgba(255,0,0,1); }
    }
    
    .labels {
        display: flex;
        justify-content: space-around;
        padding: 5px 0;
        color: #ffd700;
        font-weight: bold;
    }
    
    .labels span { width: 60px; text-align: center; }
    
    .side-labels {
        position: absolute;
        left: -25px;
        top: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        color: #ffd700;
        font-weight: bold;
    }
    
    .board-wrapper {
        position: relative;
        padding-left: 30px;
    }
    
    .controls {
        background: linear-gradient(135deg, #2d2d44, #1a1a2e);
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        min-width: 300px;
    }
    
    .turn-indicator {
        text-align: center;
        padding: 15px;
        background: rgba(255,215,0,0.1);
        border: 2px solid #ffd700;
        border-radius: 10px;
        margin-bottom: 20px;
        font-size: 1.2rem;
    }
    
    .turn-indicator .piece {
        font-size: 2rem;
    }
    
    .command-input {
        width: 100%;
        padding: 15px;
        font-size: 1.2rem;
        background: rgba(0,0,0,0.3);
        border: 2px solid rgba(255,215,0,0.5);
        border-radius: 10px;
        color: white;
        margin-bottom: 10px;
    }
    
    .command-input:focus {
        outline: none;
        border-color: #ffd700;
        box-shadow: 0 0 15px rgba(255,215,0,0.3);
    }
    
    .command-input::placeholder { color: #888; }
    
    .btn {
        width: 100%;
        padding: 12px;
        font-size: 1rem;
        font-weight: bold;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        margin-bottom: 10px;
    }
    
    .btn-primary {
        background: linear-gradient(135deg, #ffd700, #ff8c00);
        color: #1a1a2e;
    }
    
    .btn-secondary {
        background: rgba(255,255,255,0.1);
        color: white;
        border: 2px solid rgba(255,255,255,0.3);
    }
    
    .btn:hover { transform: scale(1.02); filter: brightness(1.1); }
    
    .help-section {
        margin-top: 20px;
        padding: 15px;
        background: rgba(0,0,0,0.2);
        border-radius: 10px;
        font-size: 0.85rem;
    }
    
    .help-section h3 {
        color: #ffd700;
        margin-bottom: 10px;
    }
    
    .help-section p {
        color: #aaa;
        margin: 5px 0;
    }
    
    .help-section code {
        background: rgba(255,215,0,0.2);
        padding: 2px 6px;
        border-radius: 4px;
        color: #ffd700;
    }
    
    .move-history {
        max-height: 150px;
        overflow-y: auto;
        background: rgba(0,0,0,0.2);
        border-radius: 10px;
        padding: 10px;
        margin-top: 15px;
    }
    
    .move-history h3 {
        color: #ffd700;
        margin-bottom: 10px;
    }
    
    .move-entry {
        display: flex;
        justify-content: space-between;
        padding: 5px;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        font-size: 0.9rem;
    }
    
    .status-message {
        text-align: center;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        font-weight: bold;
    }
    
    .status-message.error { background: rgba(255,0,0,0.3); color: #ff6b6b; }
    .status-message.success { background: rgba(0,255,0,0.3); color: #7fc97f; }
    .status-message.info { background: rgba(255,215,0,0.3); color: #ffd700; }
    
    .captured-pieces {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        min-height: 40px;
        padding: 10px;
        background: rgba(0,0,0,0.2);
        border-radius: 8px;
        margin-top: 10px;
    }
    
    .captured-pieces span { font-size: 1.5rem; }
</style>
</head>
<body>
<h1>‚ôüÔ∏è Chess Game - Jeu d'√âchecs ‚ôüÔ∏è</h1>
<div class="game-container">
<div class="board-container">
<div class="board-wrapper">
<div class="side-labels">
<span>8</span><span>7</span><span>6</span><span>5</span>
<span>4</span><span>3</span><span>2</span><span>1</span>
</div>
<div class="board" id="board"></div>
</div>
<div class="labels">
<span>a</span><span>b</span><span>c</span><span>d</span>
<span>e</span><span>f</span><span>g</span><span>h</span>
</div>
</div>
<div class="controls">
<div class="turn-indicator" id="turn-indicator">
<span class="piece">‚ôî</span> White's Turn
        </div>
<input autocomplete="off" class="command-input" id="command-input" placeholder="e.g., dame b2, roi e1, e2 e4" type="text"/>
<button class="btn btn-primary" id="submit-move">üéØ Make Move</button>
<button class="btn btn-secondary" id="reset-game">üîÑ New Game</button>
<div class="status-message" id="status-message" style="display:none;"></div>
<div class="help-section">
<h3>üìñ How to Play</h3>
<p><code>dame b2</code> - Move queen to b2</p>
<p><code>roi g1</code> - Move king to g1</p>
<p><code>tour a1</code> - Move rook to a1</p>
<p><code>fou c4</code> - Move bishop to c4</p>
<p><code>cavalier f3</code> - Move knight to f3</p>
<p><code>pion e4</code> - Move pawn to e4</p>
<p><code>e2 e4</code> - Move from e2 to e4</p>
<p>Or click pieces to select and move!</p>
</div>
<div class="move-history" id="move-history">
<h3>üìú Move History</h3>
</div>
<div class="captured-pieces" id="captured-white">
<strong style="color:#ffd700;">‚ö™:</strong>
</div>
<div class="captured-pieces" id="captured-black">
<strong style="color:#ffd700;">‚ö´:</strong>
</div>
</div>
</div>
<script>
const PIECES = {
    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
};

const PIECE_NAMES = {
    'roi': 'K', 'dame': 'Q', 'tour': 'R', 'fou': 'B', 'cavalier': 'N', 'pion': 'P',
    'king': 'K', 'queen': 'Q', 'rook': 'R', 'bishop': 'B', 'knight': 'N', 'pawn': 'P'
};

let board = [];
let currentTurn = 'white';
let selectedSquare = null;
let moveHistory = [];
let capturedWhite = [];
let capturedBlack = [];

function initBoard() {
    board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    currentTurn = 'white';
    selectedSquare = null;
    moveHistory = [];
    capturedWhite = [];
    capturedBlack = [];
    renderBoard();
    updateTurnIndicator();
    updateCaptured();
    document.getElementById('move-history').innerHTML = '<h3>üìú Move History</h3>';
}

function renderBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const square = document.createElement('div');
            const isLight = (row + col) % 2 === 0;
            square.className = `square ${isLight ? 'light' : 'dark'}`;
            square.dataset.row = row;
            square.dataset.col = col;
            
            const piece = board[row][col];
            if (piece) {
                square.textContent = PIECES[piece];
            }
            
            if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                square.classList.add('selected');
            }
            
            square.addEventListener('click', () => handleSquareClick(row, col));
            boardEl.appendChild(square);
        }
    }
}

function handleSquareClick(row, col) {
    const piece = board[row][col];
    const isWhitePiece = piece && piece === piece.toUpperCase();
    const isBlackPiece = piece && piece === piece.toLowerCase();
    const isCurrentPlayerPiece = (currentTurn === 'white' && isWhitePiece) || 
                                  (currentTurn === 'black' && isBlackPiece);
    
    if (selectedSquare) {
        if (selectedSquare.row === row && selectedSquare.col === col) {
            selectedSquare = null;
        } else if (isCurrentPlayerPiece) {
            selectedSquare = { row, col };
        } else {
            const fromRow = selectedSquare.row;
            const fromCol = selectedSquare.col;
            if (isValidMove(fromRow, fromCol, row, col)) {
                makeMove(fromRow, fromCol, row, col);
            } else {
                showStatus('Invalid move!', 'error');
            }
            selectedSquare = null;
        }
    } else if (isCurrentPlayerPiece) {
        selectedSquare = { row, col };
    }
    
    renderBoard();
}

function isValidMove(fromRow, fromCol, toRow, toCol) {
    const piece = board[fromRow][fromCol];
    if (!piece) return false;
    
    const isWhite = piece === piece.toUpperCase();
    const targetPiece = board[toRow][toCol];
    
    if (targetPiece) {
        const targetIsWhite = targetPiece === targetPiece.toUpperCase();
        if (isWhite === targetIsWhite) return false;
    }
    
    const pieceType = piece.toUpperCase();
    const rowDiff = toRow - fromRow;
    const colDiff = toCol - fromCol;
    const absRowDiff = Math.abs(rowDiff);
    const absColDiff = Math.abs(colDiff);
    
    switch (pieceType) {
        case 'P':
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            
            if (colDiff === 0 && !targetPiece) {
                if (rowDiff === direction) return true;
                if (fromRow === startRow && rowDiff === 2 * direction && !board[fromRow + direction][fromCol]) return true;
            }
            if (absColDiff === 1 && rowDiff === direction && targetPiece) return true;
            return false;
            
        case 'R':
            if (rowDiff !== 0 && colDiff !== 0) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
            
        case 'N':
            return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
            
        case 'B':
            if (absRowDiff !== absColDiff) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
            
        case 'Q':
            if (rowDiff !== 0 && colDiff !== 0 && absRowDiff !== absColDiff) return false;
            return isPathClear(fromRow, fromCol, toRow, toCol);
            
        case 'K':
            return absRowDiff <= 1 && absColDiff <= 1;
    }
    
    return false;
}

function isPathClear(fromRow, fromCol, toRow, toCol) {
    const rowStep = Math.sign(toRow - fromRow);
    const colStep = Math.sign(toCol - fromCol);
    
    let row = fromRow + rowStep;
    let col = fromCol + colStep;
    
    while (row !== toRow || col !== toCol) {
        if (board[row][col]) return false;
        row += rowStep;
        col += colStep;
    }
    
    return true;
}

function makeMove(fromRow, fromCol, toRow, toCol) {
    const piece = board[fromRow][fromCol];
    const captured = board[toRow][toCol];
    
    if (captured) {
        if (captured === captured.toUpperCase()) {
            capturedWhite.push(PIECES[captured]);
        } else {
            capturedBlack.push(PIECES[captured]);
        }
        updateCaptured();
    }
    
    board[toRow][toCol] = piece;
    board[fromRow][fromCol] = '';
    
    const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
    const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
    const moveNum = Math.floor(moveHistory.length / 2) + 1;
    const moveText = `${PIECES[piece]} ${fromSquare} ‚Üí ${toSquare}`;
    moveHistory.push(moveText);
    
    addMoveToHistory(moveNum, moveText, currentTurn);
    
    currentTurn = currentTurn === 'white' ? 'black' : 'white';
    updateTurnIndicator();
    showStatus(`Move: ${moveText}`, 'success');
}

function updateTurnIndicator() {
    const indicator = document.getElementById('turn-indicator');
    if (currentTurn === 'white') {
        indicator.innerHTML = '<span class="piece">‚ôî</span> White\'s Turn';
    } else {
        indicator.innerHTML = '<span class="piece">‚ôö</span> Black\'s Turn';
    }
}

function updateCaptured() {
    document.getElementById('captured-white').innerHTML = 
        '<strong style="color:#ffd700;">‚ö™:</strong> ' + capturedWhite.map(p => `<span>${p}</span>`).join('');
    document.getElementById('captured-black').innerHTML = 
        '<strong style="color:#ffd700;">‚ö´:</strong> ' + capturedBlack.map(p => `<span>${p}</span>`).join('');
}

function addMoveToHistory(num, move, color) {
    const history = document.getElementById('move-history');
    const entry = document.createElement('div');
    entry.className = 'move-entry';
    entry.innerHTML = `<span>${num}.</span><span>${move}</span><span>${color}</span>`;
    history.appendChild(entry);
    history.scrollTop = history.scrollHeight;
}

function showStatus(message, type) {
    const status = document.getElementById('status-message');
    status.textContent = message;
    status.className = `status-message ${type}`;
    status.style.display = 'block';
    setTimeout(() => status.style.display = 'none', 3000);
}

function parseCommand(cmd) {
    cmd = cmd.toLowerCase().trim();
    
    // Format: "e2 e4" (from-to)
    const fromToMatch = cmd.match(/^([a-h])([1-8])\s+([a-h])([1-8])$/);
    if (fromToMatch) {
        const fromCol = fromToMatch[1].charCodeAt(0) - 97;
        const fromRow = 8 - parseInt(fromToMatch[2]);
        const toCol = fromToMatch[3].charCodeAt(0) - 97;
        const toRow = 8 - parseInt(fromToMatch[4]);
        return { type: 'fromTo', fromRow, fromCol, toRow, toCol };
    }
    
    // Format: "dame b2" (piece to square)
    for (const [name, pieceCode] of Object.entries(PIECE_NAMES)) {
        const regex = new RegExp(`^${name}\\s+([a-h])([1-8])$`);
        const match = cmd.match(regex);
        if (match) {
            const toCol = match[1].charCodeAt(0) - 97;
            const toRow = 8 - parseInt(match[2]);
            return { type: 'pieceToSquare', pieceCode, toRow, toCol };
        }
    }
    
    return null;
}

function findPieceAndMove(pieceCode, toRow, toCol) {
    const targetPiece = currentTurn === 'white' ? pieceCode.toUpperCase() : pieceCode.toLowerCase();
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            if (board[row][col] === targetPiece) {
                if (isValidMove(row, col, toRow, toCol)) {
                    return { fromRow: row, fromCol: col };
                }
            }
        }
    }
    return null;
}

function executeCommand() {
    const input = document.getElementById('command-input');
    const cmd = input.value;
    const parsed = parseCommand(cmd);
    
    if (!parsed) {
        showStatus('Invalid command format!', 'error');
        return;
    }
    
    if (parsed.type === 'fromTo') {
        const piece = board[parsed.fromRow][parsed.fromCol];
        if (!piece) {
            showStatus('No piece at that square!', 'error');
            return;
        }
        
        const isWhite = piece === piece.toUpperCase();
        if ((currentTurn === 'white' && !isWhite) || (currentTurn === 'black' && isWhite)) {
            showStatus('Not your piece!', 'error');
            return;
        }
        
        if (isValidMove(parsed.fromRow, parsed.fromCol, parsed.toRow, parsed.toCol)) {
            makeMove(parsed.fromRow, parsed.fromCol, parsed.toRow, parsed.toCol);
            renderBoard();
        } else {
            showStatus('Invalid move!', 'error');
        }
    } else if (parsed.type === 'pieceToSquare') {
        const found = findPieceAndMove(parsed.pieceCode, parsed.toRow, parsed.toCol);
        if (found) {
            makeMove(found.fromRow, found.fromCol, parsed.toRow, parsed.toCol);
            renderBoard();
        } else {
            showStatus('No valid move found for that piece!', 'error');
        }
    }
    
    input.value = '';
}

document.getElementById('submit-move').addEventListener('click', executeCommand);
document.getElementById('command-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') executeCommand();
});
document.getElementById('reset-game').addEventListener('click', initBoard);

initBoard();
</script>
</body>
</html>